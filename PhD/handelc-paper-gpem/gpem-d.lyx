#LyX 1.1 created this file. For more info see http://www.lyx.org/
\lyxformat 218
\textclass gpem
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\float_placement !ht
\paperfontsize default
\spacing single 
\papersize a4paper
\paperpackage a4
\use_geometry 1
\use_amsmath 0
\paperorientation portrait
\leftmargin 1.775in
\topmargin 1.75in
\rightmargin 1.5in
\bottommargin 1.8in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip smallskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title
\added_space_top vfill \added_space_bottom vfill 
A Hardware Implementation of a Genetic Programming System Using FPGAs and
 Handel-C
\layout LaTeX


\backslash 
author {Peter Martin}
\layout LaTeX


\backslash 
email {peter.martin@marconi.com}
\layout Affiliation

School of Computer Science, The University of Birmingham, Birmingham, B15
 2TT, UK
\layout LaTeX


\backslash 
abstract {This paper presents an implementation of Genetic Programming using
 a Field Programmable Gate Array.
 This novel implementation uses a high level language to hardware compilation
 system, called Handel-C, to produce a Field Programmable Logic Array capable
 of performing all the functions required of a Genetic Programming System.
 Two simple test problems demonstrate that GP running on a Field Programmable
 Gate Array  can outperform a software version of the same algorithm by
 exploiting the intrinsic parallelism available using hardware, and the
 geometric parallelisation of Genetic Programming.}
\layout Keywords

Genetic Programming, FPGA, Handel-C, parallel genetic algorithm.
\layout Section
\align left 
Introduction
\layout Standard

Genetic Programming (GP) systems are generally realised as programs running
 on general purpose computers.
 This work was motivated by the observation that as problems get harder,
 the performance of traditional computers can be severely stretched.
 This is despite the continuing increase in performance of modern CPUs,
 and the use of multiple processors to exploit the fact that GP can be paralleli
sed.
 By implementing a GP system directly in hardware the aim is to increase
 the performance by a sufficiently large factor so as to make it possible
 to tackle harder problems.
 Using a high speed hardware GP system opens up the possibility of using
 real-time data to drive evolution.
 Examples of this are robotic control, where the hardware can interface
 directly with sensors and motion control, and signal processing applications
 where the data for evaluating fitness is a real-time data stream.
\layout Standard

This paper shows how a GP system that includes initial population creation,
 fitness evaluation and selection and breeding operators can be implemented
 in a Field Programmable Gate Array (FPGA) using a high level language to
 hardware compilation technique.
 The paper begins with a description of the hardware and the hardware compilatio
n language.
 Next, a survey of the use of FPGAs in evolutionary computing is presented.
 This is followed by a description of the GP system in general and a discussion
 of the design decisions that had to be made in order to successfully fit
 a GP system into an FPGA.
 This is followed by some example problems chosen to exercise the implementation.
 The results of running the system and comparisons to a traditional implementati
on follow and then a discussion of the results is given.
 Finally some future work is proposed and some conclusions drawn.
 
\layout Section
\align left 
FPGAs and the Handel-C Hardware Compilation System
\layout Standard

This section gives a brief description of FPGAs, followed by a description
 of the high level language to hardware compilation system.
 This is not intended to be a full description of the tool, but it describes
 the most important features, especially those that influence the design
 decisions described later in this paper.
 For full details of the language and development environment see 
\begin_inset LatexCommand \cite{HandelC:refManual}

\end_inset 

.
\layout Subsection

FPGA introduction
\layout Standard

FPGAs are a class of programmable hardware devices, consists of an array
 of Configurable Logic Blocks (CLBs), Input Output blocks (IOBs) that connect
 the logic to the outside world and configurable interconnections that connect
 the CLBs to each other and the IOBs.
 In the particular case of the Xilinx 
\begin_inset LatexCommand \cite{Xilinx:2001}

\end_inset 

 Virtex device used in this work, each CLB contains two Slices, each Slice
 containing two Logic Circuits (LCs).
 In addition some devices contain on-chip RAM.
 A simplified general model of an FPGA is shown in Figure 
\begin_inset LatexCommand \ref{fig:FPGA-architecture}

\end_inset 

.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 216 150
file Slide1.eps
width 2 3
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:FPGA-architecture}

\end_inset 

General Model of an FPGA.
 It consists of an array of Configurable Logic Blocks (CLBs), Input Output
 blocks (IOBs) that connect the logic to the outside world and configurable
 interconnections that connect the CLBs to each other and the IOBs.
\end_float 
Figure 
\begin_inset LatexCommand \ref{fig:CLB architecture}

\end_inset 

 shows a general model of a Xilinx Virtex Slice containing two logic cells.
 Each Logic Cell consists of a function generator implemented as a Look
 Up Table (LUT) a storage element or Flip Flop (FF) and internal Carry and
 Control logic (CC).
\layout Standard

The configuration of these devices is achieved by loading a configuration
 bit pattern, which in the case of the Virtex is loaded into static RAM
 on the chip.
 This has to be done each time the chip is re-powered.
 The configuration bit patterns are proprietary and are generated using
 software tools that take a high level description of the configuration
 information.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 216 237
file Slide2.ps
width 2 3
flags 1

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:CLB architecture}

\end_inset 

General model of a Configurable Logic Block or Slice.
 Each Slice contains two logic cells.
 Each Logic Cell consists of a function generator implemented as a Look
 Up Table (LUT) a storage element or Flip Flop (FF) and internal Carry and
 Control logic (CC).
 
\end_float 
\layout Subsection

Description of Handel-C
\layout Standard

Handel-C is a high level language that is at the heart of a hardware compilation
 system known as Celoxica DK1 
\begin_inset LatexCommand \cite{Celoxica:website}

\end_inset 

.
 It is designed to compile programs written in a high level language into
 synchronous hardware.
 The output from Handel-C is a file that is used to create the configuration
 data for the FPGA.
 A description of the process used by Handel-C to transform a high level
 language into hardware and examples of the hardware generated can be found
 in 
\begin_inset LatexCommand \cite{page:1996}

\end_inset 

.
 Handel-C has its roots in CSP and Occam.
\layout Standard

Handel-C has a C-like syntax.
 This makes the tool appealing for software engineers with no experience
 of hardware, in that they can quickly translate a software algorithm into
 hardware, without having to learn about FPGAs in detail, or VHDL.
 VHDL is a standard hardware design language.
 It stands for VHSIC Hardware Design Language and VHSIC itself stands for
 Very High Speed Integrated Circuit.
 Examples of how Handel-C may be exploited can be found in work by Page
 
\begin_inset LatexCommand \cite{page:video:1997}

\end_inset 

 where a number of video algorithms were implemented using just an FPGA,
 and in work by Sulik 
\shape italic 
et al
\shape default 
 
\begin_inset LatexCommand \cite{sulik:2000}

\end_inset 

 that describes how a Reduced Instruction Set Computer core was designed
 in 48 hours.
\layout Subsubsection


\begin_inset LatexCommand \label{handel-c-parallelism}

\end_inset 

Parallel Hardware Generation
\layout Standard

One of the advantages of using hardware is the ability to exploit parallelism
 directly.
 This is in contrast to the simulated software parallelism that is found
 on single CPU computers achieved using time-slicing.
 Handel-C has additional constructs to support the parallelisation of code.
 The block
\layout LyX-Code

par {
\newline 
    a=10; 
\newline 
    b=20;
\newline 
}
\layout Standard

would generate hardware to assign the value 10 to 
\family typewriter 
a
\family default 
 and 20 to 
\family typewriter 
b
\family default 
 in a single clock cycle.
 Using arrays of functions or by generating inline code, large blocks of
 functionality can be generated that execute in parallel.
\layout Standard

Hardware can be replicated using the construct
\layout LyX-Code

par (i=0;i<10;i++) { 
\newline 
    a[i] = b[i];
\newline 
}
\layout Standard

which would result in 10 parallel assignment operations resulting in copying
 array 
\family typewriter 
b
\family default 
 to array 
\family typewriter 
a
\family default 
 in one clock cycle.
\layout Subsubsection

Efficient use of FPGA resources
\layout Standard

To make efficient use of the hardware, Handel-C requires the programmer
 to declare the width of all data, for example, 
\layout LyX-Code

int 5 count;
\layout Standard

is a signed integer that is 5 bits wide, and so will be able to represent
 the values 
\begin_inset Formula \( -16\leq count\leq +15 \)
\end_inset 

.
\layout Standard

Handel-C supports only a single Integer data type.
 
\layout Subsubsection

External Communication
\layout Standard

Communication between the hardware and the outside world is performed using
 interfaces.
 These may be specified as input or output, and, as with assignment, a write-to
 or a read-from an interface will take one clock cycle.
 The language allows the designer to target particular hardware, assign
 input and output pins, specify the timing of signals, and generally control
 the low level hardware interfacing details.
 Macros are available to help target particular devices.
\layout Subsubsection

Simple timing semantics
\layout Standard

According to the Handel-C documentation, the simple rule about timing of
 statements is that 
\begin_inset Quotes eld
\end_inset 

assignment takes 1 clock cycle, the rest is free
\begin_inset Quotes erd
\end_inset 

.
 This means that expressions are constructed using combinatorial logic,
 and data is clocked only when an assignment is performed.
 For example, Handel-C would generate hardware for the following statement
 that executed in a single clock cycle.
\layout LyX-Code

y = ((x*x)+3*x);
\layout Standard

This feature makes it easy to predict the performance in terms of clock
 cycles.
 However, there is a penalty in that the more complex the expression, the
 deeper the logic required to implement the expression.
 This in turn limits the maximum clock rate at which the design can be run
 because of the propagation delays associated with deep logic.
 In practice this means that the designer needs to trade clock cycles against
 clock rate, and this is typically an iterative process.
\layout Subsection

Some restrictions when using Handel-C and FPGAs
\layout Standard

Because Handel-C targets hardware, there are some programming restrictions
 compared to using ANSI C, and these need to be taken into consideration
 when designing code that can be compiled by Handel-C.
 Some of these restrictions particularly affect the building of a GP system.
 
\layout Standard

Firstly, there is no stack available, so recursive functions cannot be directly
 supported by the language.
 This in turn means that standard GP, which relies heavily on recursion,
 cannot be implemented without some modification.
 A solution to this restriction is discussed in Section 
\begin_inset LatexCommand \ref{Internal program representation}

\end_inset 

.
\layout Standard

Secondly, there is a limit to the size of memory that can be implemented
 using standard logic cells on an FPGA because implementing memory is expensive
 in terms of silicon real estate.
 However, some FPGAs have internal RAM that can be used by Handel-C.
 For example, the Xlinx Virtex and Spartan series support internal memory
 that Handel-C allows the user to declare as RAM or ROM.
 The definition 
\layout LyX-Code

ram int 8 mem[128]; 
\layout Standard

declares a RAM block of 128 cells, each 8 bits wide, which can be accessed
 as a normal array.
\layout Standard

A limitation of using RAM or ROM is that it cannot be accessed more than
 once per clock cycle, so restricting the potential for parallel execution
 of code that accesses it.
\layout Standard

Thirdly, expressions are not allowed to have side effects, since this would
 break the single cycle assignment rule.
 Therefore code such as 
\layout LyX-Code

a = ++b;
\layout Standard

is not allowed and needs to be re-written as:
\layout LyX-Code

b = b + 1;
\newline 
a = b;
\layout Subsection

Targets supported by Handel-C
\layout Standard

Handel-C supports two targets.
 The first is a simulator target that allows development and testing of
 code without the need to use any hardware.
 This is supported by a debugger and other tools.
 The second target is the synthesis of a netlist for input to place and
 route tools.
 This allows the design to be translated into configuration data for particular
 chips.
 An overview of the process is shown in Figure 
\begin_inset LatexCommand \ref{fig:Process of using Handel-C}

\end_inset 

.
 Analysis of cycle counts is available from the simulator, and an estimate
 of gate count is generated by the Handel-C compiler.
 Although the estimation tool is useful, to get definitive timing information
 and actual hardware usage the place and route tools need to be invoked.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 283 216
file process.eps
height 2 3
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:Process of using Handel-C}

\end_inset 

Overview of the process of translating code into hardware using Handel-C
 and the critical outputs for analysis of the solution
\end_float 
\layout Subsection

Translating ANSI-C to Handel-C and code portability
\layout Standard

With care it is possible to re-use the same code for both a design implemented
 in hardware and a design realised as a traditional software program.
 The differences in syntax and the various extensions can be made portable
 using the C pre-processor.
 For example, the need to supply a width specifier for Handel-C can be hidden
 from an ANSI C compiler as follows:
\layout LyX-Code

#if defined HANDELC
\newline 
#define IW 5
\newline 
#else
\newline 
#define IW
\newline 
#endif
\newline 
...
\newline 
int IW x;
\layout Standard

Similar tricks can be used to allow the parallel portions of code to be
 treated as normal sequential blocks by the ANSI C compiler, and other Handel-C
 keywords to be hidden.
\layout Section
\align left 

\begin_inset LatexCommand \label{Existing fpga implementations}

\end_inset 

Existing GA/GP systems using FPGAs
\layout Standard

FPGAs have featured in the field of evolutionary computing in three main
 areas: 1) as a means of implementing the fitness functions of Genetic Algorithm
s or Genetic Programming; 2) as a platform for implementing the Genetic
 or Evolutionary Algorithm; 3) in relation to evolving hardware by means
 of an evolutionary technique.
 These three strands are surveyed separately.
 A common theme running through previous work is the use of traditional
 hardware design tools and languages such as VHDL.
\layout Subsection


\begin_inset LatexCommand \label{fpga-ga-review}

\end_inset 

FPGAs for speeding up fitness evaluations.
\layout Standard

In this category only the fitness evaluation is performed by an FPGA.
 The creation of the initial population and the breeding phases are carried
 out by a host computer.
\layout Standard

Koza 
\shape italic 
et al.

\shape default 
 
\begin_inset LatexCommand \cite{koza:1997:ASILIMOAR}

\end_inset 

 used an FPGA to speed up the evaluation of fitness of a sorting network,
 in which the FPGA was used solely to perform the fitness evaluation.
 The initial population was created by a host computer, and then individuals
 were downloaded to a pre-programmed FPGA and the FPGA instructed to evaluate
 the fitness of the individual.
 Subsequent selection and breeding were again performed by the host computer.
\layout Standard

Yamaguchi 
\shape italic 
et al
\shape default 
 
\begin_inset LatexCommand \cite{Yamaguchi:2000}

\end_inset 

 used an FPGA to implement a co-processor for evolutionary computation to
 solve the iterated prisoners dilemma (IPD) problem.
 They reported a 200 times performance speedup in processing the IPD functions
 on the FPGA when compared to a 750MHz Pentium processor.
 
\layout Subsection

Implementing the logic for evolution using FPGAs
\layout Standard

In this category the fitness evaluation and breeding and in some cases the
 initial population creation is carried out on the FPGA.
\layout Standard

Graham and Nelson 
\begin_inset LatexCommand \cite{Graham:96}

\end_inset 

 implemented a complete GA system using four FPGAs.
 Each FPGA was programmed to carry out a different function; Selection,
 Crossover, Fitness and Mutation and finally Statistics.
 Each FPGA passed its results to the next forming a pipeline.
 The performance of their system was compared to a software implementation
 running on a 125MHz PA-RISC workstation and they showed an improvement
 of 4 times
\layout Standard

A GA hardware engine is described by Scott 
\shape italic 
el al
\shape default 
 
\begin_inset LatexCommand \cite{Scott:1997}

\end_inset 

 that implements the fitness function, crossover/mutation function and selection
 function on a number of Xilinx XC4005 devices.
 No direct performance comparisons are given.
\layout Standard

Perkins 
\shape italic 
et al
\shape default 
 
\begin_inset LatexCommand \cite{EHW:ICES2000-Perkins}

\end_inset 

 describe a system where a complete GA system is realised on a single Virtex
 300 part.
 Performance is compared to a C implementation, and they report an improvement
 of over 1000 times, though they don't specify the speed of the CPU used
 for the C implementation.
\layout Standard

Shackleford 
\shape italic 
et al
\shape default 
 
\begin_inset LatexCommand \cite{shackleford:2001}

\end_inset 

 have implemented a complete GA system using a Xilinx XCV3200E chip.
 Their implementation uses extensive pipelines and parallel fitness evaluation
 to get a performance increase of 320 times when compared to the same algorithm
 running on a 366MHz Pentium CPU.
\layout Standard

Finally in this category, FPGAs have been been used to implement parts of
 a GP system.
 The system described by Heywood 
\shape italic 
et al
\shape default 
 
\begin_inset LatexCommand \cite{heywood:2000:rbGPFPGA}

\end_inset 

 was simulated using more traditional FPGA tools.
 The proposal in his work was to use the FPGA only for evaluating the individual
s and performing mutation and crossover.
 Initial population creation was done off-line and downloaded to RAM for
 use by the FPGA.
\layout Subsection

Evolutionary hardware using FPGAs
\layout Standard

FPGAs have featured regularly as platforms for evolutionary hardware research.
 Thompson 
\begin_inset LatexCommand \cite{thompson:1996:SiE}

\end_inset 

 demonstrated for the first time how digital FPGAs could be used as the
 target for evolutionary hardware.
 His work is interesting for a number of reasons: firstly it used an FPGA
 - the Xilinx XC6200 - that supported direct reconfiguration of its logic
 cells, in contrast to current FPGAs that only support very limited partial
 reconfiguration.
 Sadly this FPGA is now obsolete.
 Secondly, his work relied on the asynchronous behaviour of the FPGA to
 obtain the results, in contrast to much of the current work using FPGAs
 which is very firmly focussed on the synchronous use of FPGAs.
 Thirdly, the evolutionary approach discovered an analogue behaviour of
 the FPGA that resulted in the circuit operating correctly, but only within
 a limited temperature range.
 Subsequent work by Thompson and Layzell 
\begin_inset LatexCommand \cite{Thompson:1999}

\end_inset 

 describes the physics of this behaviour.
 
\layout Standard

The work by Fogarty 
\shape italic 
et al.

\shape default 
 
\begin_inset LatexCommand \cite{Fogarty:miller:Thompson:1998}

\end_inset 

 describes how circuits can be evolved directly on an FPGA without having
 to place and route a netlist first.
\layout Standard

Tufte and Haddow 
\begin_inset LatexCommand \cite{EHW:NASA99-Tufte}

\end_inset 

 implemented a complete evolutionary hardware system on an FPGA, which used
 a pipeline to evolve hardware.
\layout Standard

Levi and Guccione 
\begin_inset LatexCommand \cite{EHW:NASA99-Levi}

\end_inset 

 describe a method of generating the FPGA configuration data that avoids
 illegal FPGA configurations and ensures the FPGAs are stable.
\layout Section
\align left 
Implementation of a GP system using Handel-C
\layout Standard

This section describes the general design decisions taken to implement GP
 in hardware.
\layout Subsection

A Complete GP system On a Chip
\layout Standard

The primary aim of this work was to realise a complete GP system in hardware.
 That is initial population generation, fitness evaluation, breeding and
 the delivery of the final result.
 This is in contrast to all previous examples of using FPGAs with Genetic
 Programming.
 This high level aim guided many of the following design decisions.
\layout Subsection


\begin_inset LatexCommand \label{Internal program representation}

\end_inset 

Internal Program Representation
\layout Standard

The lack of a built-in stack when using Handel-C makes the use of recursive
 functions difficult.
 Although there are well known methods of removing recursion from algorithms
 
\begin_inset LatexCommand \cite{sedgewick}

\end_inset 

, a stack of some form is still required to store intermediate results.
 An alternative to the standard tree representation as introduced by Koza
 
\begin_inset LatexCommand \cite{koza:book}

\end_inset 

 is the linear GP system as used by Nordin and Banzhaf 
\begin_inset LatexCommand \cite{Nordin:1995:tcp}

\end_inset 

, Banzhaf 
\shape italic 
et al 
\shape default 

\begin_inset LatexCommand \cite{banzhaf:1997:book}

\end_inset 

 and others.
 A linear representation was chosen for this work because of its simplicity
 and the fact that a linear representation has been shown to be able to
 solve hard problems.
\layout Standard

The details of the internal representation depend on the word size, number
 of functions, and number of terminals used, and these are dependent on
 the problem being tackled.
 For this work, a register like machine was chosen for its simplicity, though
 a register machine is by no means the only machine that could be used.
 A program consists of an array of instructions and some control information.
 The programs have a fixed maximum size to simplify the GP system.
 A general layout of an instruction is shown in Figure 
\begin_inset LatexCommand \ref{fig:instruction picture}

\end_inset 

.
 This shows an example in which there are eight possible opcodes and each
 opcode can use zero, one or two effective addresses.
 The details of what the opcodes do and the effective addresses is problem
 specific.
 The fields for an instruction are described in Table 
\begin_inset LatexCommand \ref{table:General layout of an instruction}

\end_inset 

.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 141 35
file instruction.eps
width 1 5
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:instruction picture}

\end_inset 

Layout of an instruction where there are eight possible opcodes and two
 effective addresses.
 The details of what the opcodes do and the effective addresses is problem
 specific.
\end_float 
\begin_float tab 
\layout Caption


\begin_inset LatexCommand \label{table:General layout of an instruction}

\end_inset 

General layout of an instruction
\layout Standard


\begin_inset  Tabular
<lyxtabular version="2" rows="4" columns="2">
<features rotate="false" islongtable="false" endhead="0" endfirsthead="0" endfoot="0" endlastfoot="0">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="1in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="3.5in" special="">
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Field
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Comments
\end_inset 
</cell>
</row>
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Opcode
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

The operation being encoded
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Effective Address 1
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

The primary source operand and the destination address.
 Always a register.
\end_inset 
</cell>
</row>
<row topline="false" bottomline="true" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Effective Address 2
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

The secondary operand.
 Can be a register, a new Program counter or an index into a table of constants.
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_float 
\layout Standard

The representation of a program is shown in Table 
\begin_inset LatexCommand \ref{table:general layout of an individual program}

\end_inset 

.
\layout Standard

\begin_float tab 
\layout Caption


\begin_inset LatexCommand \label{table:general layout of an individual program}

\end_inset 

Layout of an individual program
\layout Standard


\begin_inset  Tabular
<lyxtabular version="2" rows="4" columns="2">
<features rotate="false" islongtable="false" endhead="0" endfirsthead="0" endfoot="0" endlastfoot="0">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="" special="">
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Field
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Comments
\end_inset 
</cell>
</row>
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Length
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

The active length of the program,
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Raw fitness
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

The raw fitness of the program
\end_inset 
</cell>
</row>
<row topline="false" bottomline="true" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Instructions
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

An array of instructions
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_float 
\layout Subsection

Parallelism
\layout Standard

When discussing parallelism it is important to distinguish between different
 forms of parallelism.
 Here four types of parallelism are used; intrinsic, geometric, algorithmic
 and asynchronous.
 These will now be explained.
\layout Standard

Firstly, the Handel-C language supports parallelism directly as already
 discussed in section 
\begin_inset LatexCommand \ref{handel-c-parallelism}

\end_inset 

, enabling efficient implementation of instructions that would normally
 be executed serially on a standard microprocessor.
 This in itself gives a substantial increase in performance when compared
 to a standard microprocessor.
 Since this form of parallelism is built into Handel-C, I will call this
 intrinsic parallelism.
\layout Standard

The second use of parallelism is in the implementation of the Genetic Programmin
g algorithm.
 Genetic Algorithms in general are highly parallelisable and exploiting
 this parallelism can result in substantial performance improvements.
 Cantu-Paz 
\begin_inset LatexCommand \cite{GA:CP98-Cantu-Paz}

\end_inset 

 surveyed parallel GA algorithms in depth and proposed four classifications
 of parallel GA.
 A uniform taxonomy of parallel Genetic Algorithms has been proposed by
 Nowostawski and Poli 
\begin_inset LatexCommand \cite{Nowostawski:1999}

\end_inset 

, which extended the number of classes of parallel GAs to eight: 
\layout Enumerate

master-slave in which a single population exists and the fitness evaluation
 of multiple individuals is carried out in parallel
\layout Enumerate

static subpopulations with migration
\layout Enumerate

static overlapping subpopulations without migration
\layout Enumerate

massively parallel genetic algorithms
\layout Enumerate

dynamic demes
\layout Enumerate

parallel steady-state GA
\layout Enumerate

parallel messy GA
\layout Enumerate

hybrid methods.
\layout Standard

In the field of GP various examples of parallel GP exist, for example the
 work by Andre and Koza 
\begin_inset LatexCommand \cite{andre:1996:aigp2}

\end_inset 

 used a network of Transputers, while Chong and Langdon 
\begin_inset LatexCommand \cite{chong:1999:jDGPi}

\end_inset 

 explored how the computing resources that are potentially available on
 the internet could be exploited.
 Probably the most powerful example of parallel GP is the work done by Koza
 
\shape italic 
et al
\shape default 
 
\begin_inset LatexCommand \cite{koza:2000:ecfvGP}

\end_inset 

 which used a thousand standard Pentium PCs.
 
\layout Standard

The type of parallelism found in all the examples above is geometric parallelism
, where a data set is partitioned into smaller units and the processing
 is replicated on many processors.
\layout Standard

A third form of parallelism - algorithmic parallelism - occurs where a number
 of tasks can be pipelined, so making fuller use of the available resources.
 This technique is common in hardware design, and in particular is found
 in most modern microprocessors.
\layout Standard

Lastly, a form of parallelism called asynchronous or relaxed parallelism
 occurs when two or more processes communicate on an occasional basis but
 operate independently without any synchronisation.
\layout Subsubsection

Intrinsic Parallelism for a Hardware Implementation
\layout Standard

The design used in this work exploits parallel execution of all simple statement
s where possible.
 This is done regardless of the phase of GP (creation, fitness evaluation,
 selection and breeding) since there is no penalty in executing two assignments
 in parallel.
 In any case the hardware will be generated for each assignment.
 This is especially useful when initialising variables at the beginning
 of a function.
\layout Subsubsection

Geometric Parallelism for a Hardware Implementation
\layout Standard

In this work the master-slave parallel architecture is used where the master
 stores the population and the slaves evaluate the fitness of the individuals.
 This form of parallelism is a natural fit where the population is a global
 resource within the FPGA or closely coupled RAM, and parallel fitness evaluatio
ns can be realised by replicating the fitness evaluating hardware.
 Since the entire system is realised on a single chip, the communication
 overhead between the master and the slaves (the evaluation functions) which
 is normally regarded as a bottleneck is almost entirely removed.
\layout Standard

Since it is unlikely that there would be sufficient FPGA resources to be
 able to evaluate an entire population at once, the population is divided
 into a number of smaller subsets and each subset is evaluated in parallel.
 To make this as efficient as possible, and to make the maximum use of the
 hardware, both the total population size and the number of individuals
 in a subset is a power of 2.
 Parallelisation of the evaluation is implemented by using the 
\family typewriter 
inline
\family default 
 keyword in Handel-C which causes as many copies of the hardware to be generated
 as required.
\layout Subsubsection

Algorithmic Parallelism for a Hardware Implementation
\layout Standard

Pipelines have not been used, but the opportunity for using them to speed
 up the design is clear, and future work will investigate them.
\layout Subsubsection

Asynchronous Parallelism for a Hardware Implementation
\layout Standard

There is one task that is ideally suited to an asynchronous implementation
 - that of the random number generator.
 This runs continuously in parallel with everything else, generating a stream
 of random numbers which are used as needed by the rest of the design.
\layout Subsection

Generating Pseudo Random Numbers
\layout Standard

A random number generator (RNG) is used in two of the major steps in GP.
 Firstly, during initial population creation to create a diverse population,
 and secondly, during the breeding phase to select individuals for breeding
 and to choose a particular breeding operator from one of crossover, mutation
 or copy.
 When using Handel-C, the use of the standard multiply and divide instructions
 are inefficient in terms of silicon because of the deep logic generated.
 As a consequence of this the usual linear congruential generators normally
 found were rejected.
 Instead, a linear feedback shift register (LFSR) design was used.
 A word size of 32 was chosen, as this could be implemented efficiently
 on a standard modern CPU, and so the LFSR can be ported easily to ANSI
 C.
 It is important to choose a good polynomial to make sure that the RNG can
 generate a maximal sequence of 
\begin_inset Formula \( 2^{n}-1 \)
\end_inset 

 random numbers, while keeping the number of taps to a minimum for efficiency.
 Schneier 
\begin_inset LatexCommand \cite{schneier:cryptography}

\end_inset 

 page 376 gives a list of such polynomials and for a 32 bit word the polynomial
 
\begin_inset Formula \( x^{32}+x^{7}+x^{6}+x^{2}+x^{0} \)
\end_inset 

 was used.
 The block diagram of the LFSR is shown in 
\begin_inset LatexCommand \ref{fig:LFSR random number generator}

\end_inset 

.
 Only 4 taps are shown since 
\begin_inset Formula \( x^{0} \)
\end_inset 

 is always 1.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 252 100
file lfsr.eps
width 2 3.5
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:LFSR random number generator}

\end_inset 

Linear Feedback Shift Register Random Number Generator for the 32 bit polynomial
 
\begin_inset Formula \( x^{32}+x^{7}+x^{6}+x^{2}+x^{0} \)
\end_inset 

.
 The 
\begin_inset Formula \( \oplus  \)
\end_inset 

 symbol is the 4 input logical exclusive OR function (XOR).
 Only 4 taps are shown since 
\begin_inset Formula \( x^{0} \)
\end_inset 

 is always 1.
\end_float 
\layout Standard

The RNG is designed so that a random number is generated in one cycle.
 The required number of bits are then read from the 32 bit register, starting
 at bit 32 to give a random number.
 For example, if the system has 8 instructions, then 3 bits are needed to
 encode the instruction.
 During initial program creation the random selection of an instruction
 uses the top 3 bits.
 Handel-C allows efficient bit operations, and the code to select the 3
 bits is:
\layout LyX-Code

unsigned int 3 instruction;
\newline 
instruction = randReg[31:29];
\layout Standard

where 
\family typewriter 
randReg
\family default 
 is the shift register variable.
\layout Standard

Seeding of the RNG is done by reading a 32 bit port during the initialisation
 phase.
 This allows the RNG to be seeded from an external source, such as a time
 of day clock, or other source of noise.
 It also allows the RNG to be preset to a known seed for producing repeatable
 results.
\layout Standard

There is a suspicion that this RNG is not ideal because LFSRs are known
 to perform poorly in the serial test described by Knuth 
\begin_inset LatexCommand \cite{Knuth:vol2}

\end_inset 

 and this is an area for further investigation.
\layout Subsection

Breeding Policy and Operators
\layout Standard

To conserve memory, a steady state breeding policy was used.
 Tournament selection is used with a tournament size of two.
 Larger tournament selection makes little sense with very small populations.
\layout Standard

The operators were selected using the following probabilities.
 Mutation 10%, Crossover 70%, copy 20%.
\layout Subsubsection

Mutation
\layout Standard

The mutation operator works by reusing the function that generates a program
 node during initial program creation.
 This is done primarily to economise on hardware.
 The result is that a mutation can change zero, one or more of the instruction
 details.
 This mutation operator is fairly crude and potentially destructive and
 further work needs to be done to evaluate the effect of such a heavy handed
 method.
\layout Subsubsection

Cross-over
\layout Standard

Crossover for a linear program representation causes some problems in that
 generally we want to avoid performing large block memory moves.
 This work maintains a fixed maximum program size, and copies segments from
 one program to another.
 By exploiting the parallel nature of hardware, the effects of performing
 block memory copies can be reduced to an acceptable level.
 This is an area that will benefit from further optimisation.
\layout Subsubsection

Copy individual
\layout Standard

Again by exploiting the parallel nature of the hardware, a copy of an individual
 of length 
\shape italic 

\begin_inset Formula \( l \)
\end_inset 


\shape default 
 requires 
\begin_inset Formula \( l+k \)
\end_inset 

 clock cycles, where 
\begin_inset Formula \( k \)
\end_inset 

 represents the small overhead to set up the copy, currently 3 clock cycles.
\layout Subsection

Performance Comparison Methodology
\layout Standard

As already noted, there are potentially four types of parallelism being
 used in this work.
 To make any performance comparisons meaningful, the different types of
 parallelism in operation must be considered when making any comparisons
 with other implementations of the same algorithm.
 For this reason the performance comparison is made up of two parts.
 Firstly, a comparison of the design to a standard microprocessor is made,
 but without the geometric parallelism.
 That is, only a single fitness evaluation is made at any one time.
 Secondly, a comparison is made for different degrees of geometric parallelism.
\layout Standard

Comparing the performance of the FPGA system without geometric parallelism
 to a modern RISC processor is considered reasonable on the grounds this
 comparison has been used previously in much of the work reviewed in section
 
\begin_inset LatexCommand \ref{fpga-ga-review}

\end_inset 

 as well as literature published by Xilinx and other hardware manufacturers.
\layout Subsection

Other optimisations
\layout Standard

The use of the standard C operators *(multiply) /(divide) and %(modulus)
 operators was avoided, since they produce deep combinatorial logic with
 long delays which in turn severely limits the maximum clock rate at which
 the design can be run.
 Similarly the use of the inequality operators was avoided where possible
 since these also generate deep logic.
 For problems where multiplication or division are essential, these operators
 can be implemented using pipelined architectures.
 These make efficient use of silicon but require careful design of the fitness
 cases to exploit the pipelines efficiently.
\layout Standard

Some variables are overloaded.
 This reduces the logic required to implement some functions that have a
 sequential nature, while making the code somewhat less maintainable.
\layout Section
\align left 
Experimental Setup
\layout Standard

To test the feasibility of implementing a GP system in hardware using Handel-C
 a number of experiments were devised.
 This section describes the environment used for the experiments.
\layout Standard

There were four aims of running these experiments:
\layout Enumerate

to determine whether the system could be implemented using Handel-C and
 to verify that the design would fit on an FPGA
\layout Enumerate

to determine if a limited GP system could solve the problems chosen
\layout Enumerate

to obtain some indicative performance comparisons between a traditional
 C implementation and a hardware implementation
\layout Enumerate

to find out whether the design was realisable as hardware and to implement
 the design in hardware.
\layout Subsection

Test Environments
\layout Standard

To meet the above aims, the problems were run using five different environments.
 Firstly, as a standard C application running under Linux.
 This was to prove the initial program operation, and to enable the application
 to be debugged using standard GNU tools.
 The program was compiled using gcc v2.95.2 and executed on a 200MHz AMD K6
 PC running Linux.
 
\layout Standard

Secondly, the program was compiled using Handel-C and optimisations made
 to the code to reduce logic depth and gate count, and to increase parallelism.
 
\layout Standard

Thirdly, the Handel-C implementation was run using the Handel-C simulator.
 This gave the number of clock cycles needed to execute the program.
 
\layout Standard

Fourthly, the C code was compiled using a cross compiler and executed on
 an instruction simulator for the Motorola Power-PC architecture.
 This was performed to obtain a count of instruction and memory cycles needed
 for a modern processor.
 The choice of the Power-PC for this work was made on the basis of a readily
 available simulator for the Power-PC.
 The Power-PC simulation was performed by using gcc 2.95.2 configured as a
 Power-PC cross compiler.
 This version of the program was optimised so as to have a minimal start-up
 overhead and to not use any I/O.
 It is therefore as close to the FPGA program as possible, allowing a meaningful
 comparison of performance to be made.
 The simulator itself was psim 
\begin_inset LatexCommand \cite{Psim:homepage}

\end_inset 

 which is built into the GNU debugger (gdb) from version 5.0 onwards.
 Psim can also be run as a stand-alone application.
 
\layout Standard

Lastly, the output from Handel-C was used to generate a hardware layout
 for the place and route tools which gave the maximum clock frequency the
 design could achieve, and an indication of the FPGA resources required.
\layout Standard

The design was then transferred to hardware to verify the correct operation
 of the program.
\layout Standard

For the Handel-C simulation and hardware implementation, the code was compiled
 using Handel-C v3.0 using maximum optimisation.
 The final FPGA configuration data was produced using Xlinx Design Manager
 version 3.3i for a Xlinx Virtex XCV2000e-6 chip hosted on a Celoxica RC1000
 development board.
 A block diagram of this board is shown in figure 
\begin_inset LatexCommand \ref{fig:rc1000board}

\end_inset 

.
 This board contains a PCI bridge that communicates between the RC1000 board
 and the host computers PCI bus, four banks of Static Random Access Memory
 (SRAM) and a Xilinx FPGA.
 Logic circuits isolate the FPGA from the SRAM, allowing both the host CPU
 and the FPGA to access the SRAM.
 The SRAM can be configured as either 2Mbytes by 8bits each, or 512Kbytes
 by 32bits and for this work, the SRAM was configured as 32bits wide.
\layout Standard

The host computer is responsible for downloading the configuration data
 to the FPGA.
 The host can then communicate with the FPGA to control the operation, send
 data to and read data from the FPGA.
 In this work, a program written to run on the host performed the following
 operations:
\layout Enumerate

initialise the board
\layout Enumerate

download the FPGA configuration data to the FPGA
\layout Enumerate

set up the random number generator seed in SRAM
\layout Enumerate

start the GP run
\layout Enumerate

wait for the FPGA to signal that the run has finished
\layout Enumerate

read the results back from the GP system 
\layout Enumerate

display the results on the host terminal.
\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 324 171
file rc1000.eps
width 2 4.5
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:rc1000board}

\end_inset 

Block diagram of the Celoxica RC1000 FPGA board.
 It contains a PCI bridge that communicates between the RC1000 board and
 the host computers PCI bus, four banks of Static Random Access Memory (SRAM)
 and a Xilinx FPGA.
 Logic circuits isolate the FPGA from the SRAM, allowing both the host CPU
 and the FPGA to access the SRAM.
\end_float 
\layout Standard

The problems were run 50 times each, using both the native C implementation
 and the FPGA implementation and the results checked against each other.
 In both cases the same sequence of random number seeds were used.
\layout Standard

The FPGA design wrote its output to an 8 bit output port as a sequence of
 key/data pairs.
 This data was read by the host PC and saved to a disk file for later analysis.
 A disassembler was written to decode the output data for analysis.
\layout Standard

When measuring the clock counts of both the Handel-C simulation and the
 Power-PC simulation, the code was modified to run to the maximum number
 of generations.
 They also both used the same random number seed to ensure that comparisons
 were made using identical conditions.
\layout Subsection

Estimating Power-PC clock cycles
\layout Standard

Estimating the number of clock cycles required to execute the Power-PC version
 of this program is a complex process.
 Timing is dependent on how well the compiler has arranged the instruction
 flow to avoid pipeline stalls, accurate branch prediction, how much of
 the program is in instruction cache and how many external memory reads/writes
 are required.
 It also depends how fast the hardware is, especially the memory subsystem.
 From the Motorola data sheet for the MPC860 Users Manual 
\begin_inset LatexCommand \cite{PPCusermanual:1998}

\end_inset 

, an external load (read) takes 2 cycles when the data is in cache and 3
 additional clock cycles when it is not in cache.
 A write to memory requires 1 cycle.
 A best case instruction when executed from data cache requires 1 cycle
 for most common instructions.
 The number of clock cycles is given by: 
\layout Standard


\begin_inset Formula \[
Clock_{total}\simeq (r\times (1-dhit)\times 3)+i\]

\end_inset 


\begin_inset LatexCommand \label{cycle calculation}

\end_inset 


\layout Standard

where: 
\layout Standard


\begin_inset Formula \( r \)
\end_inset 

 = the number of reads from memory.
\layout Standard


\begin_inset Formula \( dhit \)
\end_inset 

 = the percentage of reads satisfied by the data cache.
 This is estimated to be 60%, based on anecdotal evidence.
\layout Standard


\begin_inset Formula \( i \)
\end_inset 

 = the number of cycles required to execute the program, including pipeline
 stalls and branch prediction failures.
 This figure includes all writes to memory and all reads from cache.
\layout Standard

The instruction and read counts are taken from the output of the instruction
 simulator.
 The above assume that there are no external memory wait states caused by
 slow memory or bus contention, and that instruction scheduling is optimal.
\layout Section
\align left 

\begin_inset LatexCommand \label{Experiment descriptions}

\end_inset 

Experiment Descriptions and Results
\layout Standard

Three experiments were devised to prove the general concept of GP in hardware
 using Handel-C and to start to investigate the behaviour of the GP system
 when changing the number of parallel fitness evaluations.
 The limited memory available, without using RAM blocks, meant that the
 problems need to be sufficiently simple to be solved using a small program
 size and small population size.
 During program development, the population size and program size were modified
 until reasonable values were found that a) allowed the problems to be solved,
 and b) could be compiled on the workstation using Handel-C.
 The last point arose because the Handel-C compiler requires substantial
 computational resources so that arbitrarily large designs cannot be compiled
 successfully.
 This resulted in a population size of 16, together with a program size
 of 8 or 16, depending on the problem chosen.
 These figures also allowed up to 4 parallel fitness evaluations to be accommoda
ted.
\layout Standard

The two problems chosen were a regression problem and a boolean logic problem.
 The regression problem uses integer values, since Handel-C does not support
 a native floating point data type.
 The problem chosen is 
\begin_inset Formula \( x=a+2b \)
\end_inset 

.
 The boolean logic problem is the 2 bit XOR function 
\begin_inset Formula \( x=a\oplus b \)
\end_inset 

.
\layout Standard

The problems were realised as a single source file with preprocessor directives
 controlling problem specific sections.
\layout Standard

In both problems the raw fitness was arranged to be zero for a 100% correct
 program, thereby reducing the amount of logic required to test for fitness.
\layout Standard

In both problems, the run was terminated if a 100% correct program was found,
 or if the maximum number of generations was reached.
\layout Subsection

Regression Problem 
\layout Subsubsection

Description
\layout Standard

In common with all GP work, each problem typically requires the selection
 of appropriate functions.
 In this work the functions are implemented as opcodes for a problem specific
 processor.
 For the regression problem using standard GP, the functions include Addition,
 Subtraction, Multiplication and Division.
 In this implementation eight instructions were chosen, requiring three
 bits.
 Each instruction can specify up to two registers, and there are four registers
 available, requiring 2 bits each.
 Therefore each instruction requires 7 bits of storage.
 
\layout Standard

The instructions for this problem are:
\layout Itemize

add(R
\begin_inset Formula \( _{n} \)
\end_inset 

,R
\begin_inset Formula \( _{m} \)
\end_inset 

) adds the contents of R
\begin_inset Formula \( _{m} \)
\end_inset 

 to the contents of R
\begin_inset Formula \( _{n} \)
\end_inset 

 and places the result back into R
\begin_inset Formula \( _{n} \)
\end_inset 

.
 
\layout Itemize

sub(R
\begin_inset Formula \( _{n} \)
\end_inset 

,R
\begin_inset Formula \( _{m} \)
\end_inset 

) subtracts the value in R
\begin_inset Formula \( _{m} \)
\end_inset 

 from the value in R
\begin_inset Formula \( _{n} \)
\end_inset 

 and places the result back into R
\begin_inset Formula \( _{n} \)
\end_inset 

.
 
\layout Itemize

shl(R
\begin_inset Formula \( _{n} \)
\end_inset 

) shifts the contents of R
\begin_inset Formula \( _{n} \)
\end_inset 

 left by one bit, leaving the result in R
\begin_inset Formula \( _{n} \)
\end_inset 

.
 
\layout Itemize

shr(R
\begin_inset Formula \( _{n} \)
\end_inset 

) shifts the contents of R
\begin_inset Formula \( _{n} \)
\end_inset 

 right by one bit, leaving the result in R
\begin_inset Formula \( _{n} \)
\end_inset 

.
\layout Itemize

nop is a no-operation function.
 This was included to make the number of instructions a power of 2.
\layout Itemize

halt(R
\begin_inset Formula \( _{n} \)
\end_inset 

) causes the evaluation to finish, returning the value in R
\begin_inset Formula \( _{n} \)
\end_inset 

.
 
\layout Itemize

ldim(R
\begin_inset Formula \( _{n} \)
\end_inset 

,K
\begin_inset Formula \( _{n} \)
\end_inset 

) causes the constant K
\begin_inset Formula \( _{n} \)
\end_inset 

 to be placed into R
\begin_inset Formula \( _{n} \)
\end_inset 

.
 
\layout Itemize

jmpifz(R
\begin_inset Formula \( _{n} \)
\end_inset 

, R
\begin_inset Formula \( _{m} \)
\end_inset 

) tests the value in R
\begin_inset Formula \( _{n} \)
\end_inset 

.
 If the value is zero, then jumps to the location in R
\begin_inset Formula \( _{m} \)
\end_inset 

 modulo program size.
 
\layout Standard

Program termination occurs on the following conditions: 
\layout Enumerate

a halt instruction is encountered
\layout Enumerate

the last instruction in the program is executed
\layout Enumerate

a jmpifz instruction has caused a loop to be created, and a predetermined
 number of loops have been executed.
\layout Standard

The machine that implements these instructions can execute one instruction
 every two clock cycles, including instruction fetch, decode, operand address
 evaluation and operand read/write.
 To speed this up even further it would be possible to build a pipeline,
 reducing the cycle count to one per instruction.
 
\layout Standard

Four random constants are made available to each individual.
 These are created once during the construction of individuals.
\layout Standard

Most examples of regression in the literature include the multiply and divide
 functions.
 Since these two functions generate very deep logic using the default Handel-C
 operators, these were replaced with single bit shift left and shift right
 operators, which generate much shallower and therefore faster logic, and
 have the effect of multiply by two and divide by two instructions respectively.
\layout Standard

The jump-if-zero opcode was included to allow loops or conditional expressions
 to appear.
\layout Standard

The full set of parameters for the regression problem are given in Table
 
\latex latex 

\backslash 
ref{table:regression problem parameters}
\latex default 
.
\layout Standard

The input values 
\begin_inset Formula \( a \)
\end_inset 

 and 
\begin_inset Formula \( b \)
\end_inset 

 were placed in registers R
\begin_inset Formula \( _{0} \)
\end_inset 

 and R
\begin_inset Formula \( _{1} \)
\end_inset 

 before the fitness evaluation, and the result 
\begin_inset Formula \( x \)
\end_inset 

 read from register R
\begin_inset Formula \( _{0} \)
\end_inset 

 if the program was terminated at the end, or the value in R
\begin_inset Formula \( _{n} \)
\end_inset 

 if terminated by a Halt instruction.
\layout Standard

The fitness data was pre-computed once at the start of the program and made
 available to all copies of the fitness evaluation.
\layout Standard

\begin_float tab 
\layout Caption


\begin_inset LatexCommand \label{table:regression problem parameters}

\end_inset 

Parameters for the regression problem
\layout Standard


\begin_inset  Tabular
<lyxtabular version="2" rows="9" columns="2">
<features rotate="false" islongtable="false" endhead="0" endfirsthead="0" endfoot="0" endlastfoot="0">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="1in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="3.5in" special="">
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Parameter
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Value
\end_inset 
</cell>
</row>
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Population Size
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

16
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Functions
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

add(R
\begin_inset Formula \( _{n} \)
\end_inset 

,R
\begin_inset Formula \( _{m} \)
\end_inset 

), sub(R
\begin_inset Formula \( _{n} \)
\end_inset 

,R
\begin_inset Formula \( m \)
\end_inset 

), shl(R
\begin_inset Formula \( _{n} \)
\end_inset 

), shr(R
\begin_inset Formula \( _{n} \)
\end_inset 

), nop, halt(R
\begin_inset Formula \( _{n} \)
\end_inset 

), ldim(R
\begin_inset Formula \( _{n} \)
\end_inset 

,K
\begin_inset Formula \( _{n} \)
\end_inset 

) jmpifz(R
\begin_inset Formula \( _{n} \)
\end_inset 

,R
\begin_inset Formula \( _{m} \)
\end_inset 


\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Terminals
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

4 registers
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Word size
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

8 bits
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Max Program Size
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

8
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Generations
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

511
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Fitness Cases
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

4 pairs of values of 
\begin_inset Formula \( a \)
\end_inset 

 and 
\begin_inset Formula \( b \)
\end_inset 


\end_inset 
</cell>
</row>
<row topline="false" bottomline="true" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Raw Fitness
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

The absolute value of the difference between the returned value 
\newline 
and the expected value
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_float 
\layout Subsubsection

Regression Problem Results
\layout Standard

The results from the simulator for this problem are given in Table
\latex latex 
 
\backslash 
ref{table:Results of running the regression problem}
\latex default 
.
 The figures for the Power-PC were calculated using method described in
 Section 
\begin_inset LatexCommand \ref{cycle calculation}

\end_inset 

.
 
\layout Standard

\begin_float tab 
\layout Caption


\begin_inset LatexCommand \label{table:Results of running the regression problem}

\end_inset 

Results of running the regression problem
\layout Standard


\begin_inset  Tabular
<lyxtabular version="2" rows="8" columns="4">
<features rotate="false" islongtable="false" endhead="0" endfirsthead="0" endfoot="0" endlastfoot="0">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="1.1in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="1.1in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="1.1in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="1.1in" special="">
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Measurement
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Power-PC Simulation
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Handel-C (Single fitness evaluation)
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Handel-C (4 parallel fitness evaluations)
\end_inset 
</cell>
</row>
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Cycles
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

16,612,624
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

351,178
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

188,857
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Clock Frequency
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

200MHz
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

25MHz
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

19MHz
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Estimated Gates
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

n/a
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

142,443
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

228,624
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Number of Slices
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

n/a
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

4,250
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

6,800
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Percentage of Slices Used
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

n/a
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

22%
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

35%
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard


\begin_inset Formula \( Speedup_{cycles} \)
\end_inset 


\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

1
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

47
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

88
\end_inset 
</cell>
</row>
<row topline="false" bottomline="true" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard


\begin_inset Formula \( Speedup_{time} \)
\end_inset 


\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

1
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

6
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

8
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_float 
\layout Standard

The estimate of NAND gates is generated by Handel-C as an indication in
 a vendor independent fashion of the size of the required FPGA, and while
 crude, does give a general picture.
 The number of slices used is generated by the place and route tools.
 The percentage of Slices used is based on the Xilinx XCV2000-BG560-6 chip,
 which has a total of 9,600 CLBs, arranged as an 80x120 grid.
 Each CLB contains two slices, giving a total of 19,200 Slices.
\layout Standard

The speed-up factors are given for two conditions, the raw cycle counts
 and the actual time taken to execute the programs.
 The first is a comparison made in terms of raw clock cycles.
 This treats the two implementations as though they were operating at the
 same clock frequency.
 The second is a comparison made using a typical clock rate for the Power-PC
 and the fastest frequency the FPGA could be clocked as reported by the
 place and route tools.
\layout Standard

The speed-up factor for cycles is given by: 
\begin_inset Formula \[
Speedup_{cycles}=\frac{Cycles_{ppc}}{Cycles_{fpga}}\]

\end_inset 

 
\layout Standard

and the speed-up factor for time is given by: 
\begin_inset Formula \[
Speedup_{time}=Speedup_{cycles}*\frac{Freq_{fpga}}{Freq_{ppc}}\]

\end_inset 


\layout Standard

An (annotated) example program from this problem found in generation 16
 of one run is:
\layout LyX-Code

shl(r1)          // r1 = b*2
\newline 
add(r1,r2)       // nop 
\family roman 
(all registers = 0 at the start)
\family default 

\newline 
add(r0,r1)       // r0 = a + (b*2)
\newline 
halt(r0)         // Return the result in r0
\layout Comment

As an exercise, the same problem was coded using the readily available lilgp
 package, and was also run using the Power-PC simulator.
 This lilgp implementation returned a result that was over 5 times slower
 than the linear GP system.
 This was probably due to the overhead of recursion, and the fact that lilgp
 has extensive logging and reporting functionality, which although turned
 off, still accounted for a large number of function calls.
\layout Standard

It was found that none of the solutions used the ldim instruction and therefore
 none of the random variables.
 
\layout Standard

The difference in the maximum attainable clock frequency between the single
 fitness evaluation case and the 4 parallel fitness evaluation case can
 be explained by the increased number of logic elements required.
 This in turn requires more routing resources and more delays.
\layout Subsection


\begin_inset LatexCommand \label{sect:XOR problem}

\end_inset 

XOR Problem
\layout Subsubsection

Description
\layout Standard

The XOR function uses the four basic two input logic primitives AND, OR,
 NOR and NAND.
 Each of these functions takes two registers, R
\begin_inset Formula \( _{n} \)
\end_inset 

 and R
\begin_inset Formula \( _{m} \)
\end_inset 

.
 The result is placed into R
\begin_inset Formula \( _{n}. \)
\end_inset 

 These have been shown to be sufficient to solve the boolean XOR problem
 
\begin_inset LatexCommand \cite{koza:book}

\end_inset 

.
 Execution is terminated when the last instruction in the program has been
 executed.
\layout Standard

The two inputs 
\begin_inset Formula \( a \)
\end_inset 

 and 
\begin_inset Formula \( b \)
\end_inset 

 were written to registers R
\begin_inset Formula \( _{0} \)
\end_inset 

 and R
\begin_inset Formula \( _{1} \)
\end_inset 

 before the fitness evaluation, and the result 
\begin_inset Formula \( x \)
\end_inset 

 read from register R
\begin_inset Formula \( _{0} \)
\end_inset 

 after the fitness evaluation.
\layout Standard

\begin_float tab 
\layout Caption


\begin_inset LatexCommand \label{table:xor problem parameters}

\end_inset 

Parameters for the XOR problem
\layout Standard


\begin_inset  Tabular
<lyxtabular version="2" rows="9" columns="2">
<features rotate="false" islongtable="false" endhead="0" endfirsthead="0" endfoot="0" endlastfoot="0">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="1in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="3.5in" special="">
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Parameter
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Value
\end_inset 
</cell>
</row>
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Population Size
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

16
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Functions
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

AND(R
\begin_inset Formula \( _{n} \)
\end_inset 

,R
\begin_inset Formula \( _{m} \)
\end_inset 

), OR(R
\begin_inset Formula \( _{n} \)
\end_inset 

,R
\begin_inset Formula \( _{m} \)
\end_inset 

), NOR(R
\begin_inset Formula \( _{n} \)
\end_inset 

,R
\begin_inset Formula \( _{m} \)
\end_inset 

), NAND(R
\begin_inset Formula \( _{n} \)
\end_inset 

,R
\begin_inset Formula \( _{m} \)
\end_inset 

) 
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Terminals
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

4 registers
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Word size
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

1 bit1
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Max Program Size
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

16
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Generations
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

511
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Fitness Cases
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

4 pairs of values of 
\begin_inset Formula \( a \)
\end_inset 

 and 
\begin_inset Formula \( b \)
\end_inset 


\end_inset 
</cell>
</row>
<row topline="false" bottomline="true" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Raw Fitness
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

The number of fitness cases that failed to yield the expected result.
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_float 
The full set of parameters is given in Table 
\latex latex 

\backslash 
ref{table:xor problem parameters}
\latex default 
 With only four functions for this problem, each instruction requires six
 bits.
\layout Subsubsection

XOR Problem Results
\layout Standard

The XOR problem was executed using the same environments as the regression
 problem.
 The results are presented in Table 
\latex latex 

\backslash 
ref{table:Results of running the XOR problem}
\latex default 
.
\layout Standard

\begin_float tab 
\layout Caption


\begin_inset LatexCommand \label{table:Results of running the XOR problem}

\end_inset 

Results of running the XOR problem
\layout Standard


\begin_inset  Tabular
<lyxtabular version="2" rows="8" columns="4">
<features rotate="false" islongtable="false" endhead="0" endfirsthead="0" endfoot="0" endlastfoot="0">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="1.1in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="1.1in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="1.1in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="1.1in" special="">
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Measurement
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Power-PC Simulation
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Handel-C (Single fitness evaluation)
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Handel-C (4 parallel fitness evaluations)
\end_inset 
</cell>
</row>
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Cycles
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

27,785,750
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

715,506
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

384,862
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Clock Frequency
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

200MHz
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

22MHz
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

18MHz
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Estimated Gates
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

n/a
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

89,205
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

142,550
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Number of Slices
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

n/a
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

4,630
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

7,434
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

Percentage of Slices Used
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

n/a
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

24%
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

38%
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard


\begin_inset Formula \( Speedup_{cycles} \)
\end_inset 


\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

1
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

38
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

72
\end_inset 
</cell>
</row>
<row topline="false" bottomline="true" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard


\begin_inset Formula \( Speedup_{time} \)
\end_inset 


\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

1
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

4
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

6
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_float 
\layout Standard

An (annotated) example program from this problem found in generation 86
 of one run is:
\layout LyX-Code

or(r3,r1)        // r3 = 
\begin_inset Formula \( b \)
\end_inset 


\newline 
or(r3,r0)        // r3 = 
\begin_inset Formula \( a+b \)
\end_inset 


\newline 
or(r2,r1)        // nop 
\family roman 
(since r2 is never used
\family default 
)
\newline 
nand(r0,r1)      // r0 = 
\begin_inset Formula \( \overline{ab} \)
\end_inset 


\newline 
and(r0,r3)       // r0 = 
\begin_inset Formula \( (a+b)\overline{ab} \)
\end_inset 


\layout Standard

The final result 
\begin_inset Formula \( (a+b)\overline{ab} \)
\end_inset 

 is equivalent to 
\begin_inset Formula \( (a\overline{b})+(\overline{a}b) \)
\end_inset 

 which is the more familiar logic equation for the exclusive OR function.
\layout Subsection


\begin_inset LatexCommand \label{section on parallelisation data}

\end_inset 

The effect of parallelising the fitness evaluation.
\layout Standard

To quantify the benefits of using geometric parallelism, the XOR problem
 was re-implemented using four different values for the number of parallel
 fitness evaluations, and run using the the Handel-C simulator.
 The purpose of this experiment was not to successfully evolve programs,
 but rather to explore how much the parallelism affected the performance.
 
\layout Standard

A total population size of 8 was chosen, together with a maximum of 4 nodes
 per individual.
 These values appear to be very low, but they were chosen to allow the programs
 to be compiled by Handel-C, since it was found that larger values caused
 the compilation of the simulation to fail due to memory exhaustion on the
 workstation.
 The number of individuals processed in parallel was modified each time,
 using the values 1, 2, 4 and 8.
 Data was collected for the number of cycles to perform the initial population
 creation, the number of cycles to evaluate the first generation and the
 number of cycles to perform the breeding operators on the first generation.
 These are shown in tabular form in Table 
\begin_inset LatexCommand \ref{table:cycle counts for different parallel evaluations}

\end_inset 

.
\layout Standard

\begin_float tab 
\layout Caption


\begin_inset LatexCommand \label{table:cycle counts for different parallel evaluations}

\end_inset 

Cycle counts and gate estimates for various stages of the GP and different
 numbers of parallel fitness evaluations.
 Where N = Number of parallel fitness evaluations.
 I = Initial population creation (cycles).
 E = Evaluation of the first generation (cycles).
 B = Breeding of first generation (cycles).
 T=Total cycles.
 G=Gate estimate (NAND gates).
\layout Standard


\begin_inset  Tabular
<lyxtabular version="2" rows="5" columns="6">
<features rotate="false" islongtable="false" endhead="0" endfirsthead="0" endfoot="0" endlastfoot="0">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="0.5in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="0.5in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="0.5in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="0.5in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="0.5in" special="">
<column alignment="left" valignment="top" leftline="false" rightline="false" width="0.5in" special="">
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

N
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

I
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

E
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

B
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

T
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

G
\end_inset 
</cell>
</row>
<row topline="true" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

1
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

214
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

324
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

123
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

6517
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

35,666
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

2
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

214
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

180
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

123
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

4669
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

43,314
\end_inset 
</cell>
</row>
<row topline="false" bottomline="false" newpage="false">
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

4
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

214
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

108
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

123
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

3549
\end_inset 
</cell>
<cell multicolumn="0" alignment="center" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

58,588
\end_inset 
</cell>
</row>
<row topline="false" bottomline="true" newpage="false">
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

8
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

214
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

60
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

123
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="false" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

2877
\end_inset 
</cell>
<cell multicolumn="0" alignment="left" valignment="top" topline="true" bottomline="false" leftline="true" rightline="true" rotate="false" usebox="none" width="" special="">
\begin_inset Text

\layout Standard

89,136
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_float 
\layout Standard

Figure 
\begin_inset LatexCommand \ref{fig:cycles per fitness}

\end_inset 

 shows the effect on the number of cycles for one fitness evaluation with
 different numbers of parallel fitness evaluations.
 It can be seen from this graph that as the number of parallel fitness evaluatio
ns increases, so the benefit tails off.
 This is due to the constant overhead associated with setting up the fitness
 evaluations.
\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 227 144
file Slide5.eps
height 2 2
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:cycles per fitness}

\end_inset 

Number of cycles to evaluate one fitness function evaluation for the population
 with different numbers of parallel fitness evaluations.
\end_float 
\layout Standard

The total number of cycles for the problem is shown in Figure 
\begin_inset LatexCommand \ref{fig:Total cycles graph}

\end_inset 

.
 The program was run for 16 generations.
 Here the effect of the breeding phase can be seen.
 The benefit gained from doubling the number of parallel fitness evaluations
 from four to eight only reduces the cycles required by 18%.
 The contribution of the initial population is about 7.5% of the total cycles
 when 8 parallel evaluations were performed.
 This shows clearly that performing fitness and breeding serially does not
 allow this implementation to exploit parallelism to its best advantage.
\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 225 144
file Slide6.eps
height 2 2
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:Total cycles graph}

\end_inset 

Total number of cycles for the problem with different numbers of parallel
 fitness evaluations.
\end_float 
\layout Section
\align left 
Discussion
\layout Subsection

Consequences of using a high level language
\layout Standard

The two problems presented here, though trivial when compared to many problems
 that have been solved using GP, have proved the general concept of using
 Handel-C to produce GP systems that can be run on FPGAs.
 The use of a C like language has some valuable properties.
 Probably the most significant is that the algorithm can be developed and
 tested using traditional software tools.
 This is an important consideration for software engineering, in that there
 is no need for a software engineer to become proficient in hardware design.
 This opens up a whole set of possibilities for implementing critical functions
 in hardware.
\layout Standard

However, the issue of productivity needs to be considered here.
 Compiling using gcc took around 3 seconds to complete, at which time testing
 could commence.
 When using Handel-C to compile a simulation, the initial compilation phase
 took several minutes, and compilation for a host simulation run using Microsoft
 Visual C++ V6.0 took around 10 minutes.
 Finally, targeting the FPGA required about 30 minutes for Handel-C to produce
 the netlist, and several hours for the place and route tools to create
 the FPGA configuration data.
 Clearly, using Handel-C for this particular problem needs careful preparation
 and the judicious use of traditional software tools during the early developmen
t phase.
 It must be stressed that the largest bottleneck is the place and route
 tools, a problem that any user of FPGA techniques will be familiar with.
 For reference, all Handel-C and place and route work was performed on a
 500MHz PentiumII workstation with 384 Mbytes of RAM running Windows NT4.0.
 The full capabilities of the FPGA cannot be exploited using such a workstation
 since the demands on memory are large, and anecdotal evidence suggests
 that at at least 1Gbyte of memory would be required to compile and place/route
 a design that would fill a Xilinx XCV2000e part (Virtex-E).
\layout Subsection

The effect of increasing parallelisation of the fitness function
\layout Standard

The results shown in section 
\begin_inset LatexCommand \ref{section on parallelisation data}

\end_inset 

 show clearly that using the current implementation and parameter values
 the benefits of increasing the number of parallel fitness evaluations falls
 off above 4.
 This is due to the breeding phase taking a significant portion of the cycles
 when compared to the fitness evaluation.
 This is a direct consequence of the linear representation of the individuals,
 and the unsophisticated crossover operator.
 Clearly more work needs to be done in the area of representation and crossover
 if the benefits of parallelisation are to be fully realised using this
 implementation.
\layout Subsection

Performance considerations and potential improvements
\layout Standard

The work reviewed in section 
\begin_inset LatexCommand \ref{Existing fpga implementations}

\end_inset 

 indicated that performance improvement over a software implementation of
 two or three orders of magnitude can be achieved by implementing part or
 all of a GA in hardware.
 The work described so far has not achieved that level of improvement.
 This is probably due to the straightforward translation of a serial algorithm
 into hardware without considering algorithmic parallelism from the outset,
 and the limited number of parallel fitness evaluations that could be accomodate
d.
\layout Standard

To achieve maximum performance algorithmic parallelism or pipelining should
 be used to perform the selection, breeding and fitness evaluation phases
 in parallel.
 In the steady state model of GP with a large population, the system could
 evaluate a number of individuals, while the breeding of previously evaluated
 individuals could be carried out in parallel, effectively forming a pipeline.
 
\layout Standard

An estimate of the worst case performance if the system were implemented
 using a pipeline can be made by assuming that:
\layout List
\labelwidthstring 00.00.0000

a) the fitness evaluation will require the most cycles and will therefore
 be the slowest stage in the pipeline.
 This means that we only need to consider how many cycles will be needed
 for the fitness evaluation.
 This is shown in table 
\begin_inset LatexCommand \ref{table:cycle counts for different parallel evaluations}

\end_inset 

 as being reasonable.
\layout List
\labelwidthstring 00.00.0000

b) that all stages are fully pipelined, that is to say that creation, selection,
 fitness evaluation, random number generation and breeding are all performed
 in parallel.
\layout List
\labelwidthstring 00.00.0000

c) that each function or instruction requires one clock cycle
\layout List
\labelwidthstring 00.00.0000

d) all programs are of maximum length
\layout Standard

and given that 
\begin_inset Formula \( G \)
\end_inset 

 is the number of generations, 
\begin_inset Formula \( l \)
\end_inset 

 is the maximum program length, 
\begin_inset Formula \( M \)
\end_inset 

 is the population size, 
\begin_inset Formula \( p \)
\end_inset 

 is the number of fitness evaluations performed in parallel, and 
\begin_inset Formula \( k \)
\end_inset 

 is the fixed overhead for startup, general control and generating the final
 result.
 The number of cycles 
\begin_inset Formula \( C \)
\end_inset 

 required is given by:
\layout Standard


\begin_inset Formula \[
C=k+(\frac{G\times l\times M}{p})\]

\end_inset 


\layout Standard

For the XOR problem described in section 
\begin_inset LatexCommand \ref{sect:XOR problem}

\end_inset 

 and assuming 
\begin_inset Formula \( k= \)
\end_inset 

500, 
\begin_inset Formula \( G= \)
\end_inset 

511, 
\begin_inset Formula \( M= \)
\end_inset 

16, 
\begin_inset Formula \( p= \)
\end_inset 

4 and 
\begin_inset Formula \( l= \)
\end_inset 

16, this gives a total cycle count of 
\begin_inset Formula \( 33204 \)
\end_inset 

, a potential improvement of over ten times.
\layout Standard

Clearly, the implementation of a fully pipelined GP system must be considered
 for future work.
\layout Standard

A further performance boost is possible by increasing the value of 
\begin_inset Formula \( p \)
\end_inset 

.
 When the population is moved from memory constructed from LUTs and Flip
 Flops to on-chip block select RAM and/or external RAM it should be possible
 to accomodate more logic to perform the fitness evaluations and therefore
 increase 
\begin_inset Formula \( p \)
\end_inset 

 from 4 to a significantly larger value.
 A value of 32 for 
\begin_inset Formula \( p \)
\end_inset 

 would yield a cycle count of 4588 which would mean that 
\begin_inset Formula \( Speedup_{time} \)
\end_inset 

 for the XOR problem would be over 2000 times.
\layout Subsection

The Potential of Problem Specific Op-codes
\layout Standard

A key difference between this work and that of Nordin and Banzhaf 
\begin_inset LatexCommand \cite{Nordin:1995:tcp}

\end_inset 

 where a standard microprocessor was used, is that we are not constrained
 to a function set that a microprocessor designer sees fit to implement.
 That is to say the functions can be designed to have a higher level of
 abstraction than machine instructions.
 While the experiments presented in section 
\begin_inset LatexCommand \ref{Experiment descriptions}

\end_inset 

 were restricted to fairly standard microprocessor like opcodes, other problems
 need not be so restricted.
\layout Standard

One example of a problem where the function set is expressed at a high level
 of abstraction is the Evolution of Emergent Behavior in 
\begin_inset LatexCommand \cite{koza:book}

\end_inset 

 page 329.
 Here the function and terminal set require several steps to be performed.
 If implemented using a Reduced Instruction Set Computer (RISC) or Complex
 Instruction Set Computer (CISC) architecture, each step would require several
 instructions to be executed and therefore require more than one clock cycle
 to execute.
 With Handel-C the functions could be encoded efficiently and compactly.
 An example from the Evolution of Emergent Behaviour work is the implementation
 of the PICK-UP operator, which picks up food (if any) at the current position
 if the ant is not already carrying food.
 Using Handel-C the operator can be written so that it requires one clock
 cycle: 
\layout LyX-Code

char grid[32][32];
\newline 
int  x,y,carrying_food;
\newline 

\newline 
if(!carrying_food && grid[x][y]) { 
\newline 
  par {
\newline 
    carrying_food = 1;
\newline 
    grid[x][y] = 0; 
\newline 
  }
\newline 
}
\layout Standard

As a comparison this requires 21 RISC (Power-PC) instructions to be executed
 when compiled using gcc.
\layout Subsection

Other applications
\layout Standard

An interesting use of using an FPGA is that input and output can be directly
 encoded into the function set, thereby opening up the possibility of embedding
 the GP system and having it directly control hardware while evaluating
 the fitness of the programs.
 An example of this would be a robotic control that read sensor inputs directly
 using some of the I/O pins on the FPGA, and generated control signals directly
 to the robot.
 Since FPGAs do not need a lot of support circuitry, it would be possible
 to embed such a controller directly into even the smallest robot.
\layout Standard

Since the FPGA system has the potential to evaluate individuals in a far
 shorter time than even the fastest Pentium class computers, there is an
 opportunity to use this system for real-time applications, where fitness
 data are available only as a real-time data stream, as required for example
 in signal processing applications.
\layout Section
\align left 
Future work
\layout Standard

So far this work has concentrated on the process of using Handel-C to create
 GP systems that can be realised in hardware.
 Some of the rather severe limitations already discussed need to be explored.
 The first priority is to extend the system to handle the larger populations
 commonly found in real world GP applications.
 To this end it is proposed to exploit the on-chip RAM.
 This will allow the size of programs and population sizes to be increased.
 However, a method of circumventing the restriction of not being able to
 access a RAM more than once per clock cycle is needed.
 An approach using very long word encodings of individuals is one possibility
 that will allow efficient single-cycle access to RAM.
\layout Standard

To extend the capabilities of this work further a method of storing the
 population in external RAM is needed.
 To accommodate off-chip RAM, which can only be read or written to once
 per clock cycle, and which has a limited word size, development of an efficient
 coding scheme will need to be devised.
 It is likely that a pipelined design would be needed to make the most of
 using external RAM.
\layout Standard

The potential for realising even better performance by using a fully pipelined
 design is clear and is currently under investigation, as is increasing
 the number of parallel fitness evaluations.
\layout Standard

The random number generator should be investigated with respect to its performan
ce using well known random number tests such as the Diehard suite maintained
 by Marsaglia
\begin_inset LatexCommand \cite{diehard:2001}

\end_inset 

, and alternative implementations evaluated.
\layout Standard

Further detailed analysis of the FPGA resources used needs to be done.
 This analysis will then help in arriving at better code in critical areas,
 and help to increase the clock speed of the design.
 The standard Xilinx Alliance tool set provides detailed timing analysis
 which can be used to identify critical areas.
 Once these critical areas have been identified, it is possible to tune
 the place and route process, and to tune the Handel-C code to reduce logic
 depth and therefore increase the clock rate at which the design can be
 run.
\layout Standard

Finally, the promise of being able to interface directly with real-world
 signals needs to be investigated in more detail.
\layout Section
\align left 
Conclusions
\layout Standard

This work has presented the initial implementation of a GP system written
 in Handel-C which can then be realised on an FPGA.
 The GP system includes initial population creation, fitness evaluation,
 selection and breeding operators.
 To demonstrate the viability of this approach two very simple problems
 have been solved.
 The performance of the FPGA implementation is better than the equivalent
 software implementation without using parallel fitness evaluations.
 When parallel fitness evaluations were used, the performance increased
 as well.
 However, simply translating a serial algorithm into hardware does not exploit
 the capabilities of the hardware fully, and to achieve even better performance
 the system should make use of pipelining.
\layout Standard

Lastly, a number of important areas for future work have been identified
 that should extend this work from solving trivial problems to solving more
 demanding problems.
\layout Section*

Acknowledgements
\layout Standard

I would like to thank Marconi Communications Limited for sponsoring this
 work.
 I would also like to thank my supervisor Dr Riccardo Poli of Birmingham
 University for his valuable support and help, and my colleagues Dr Stuart
 Wray and Icarus Sparry for comments on early drafts of this paper.
 Finally, I would like to thank the anonymous reviewers for their helpful
 comments and suggestions.
\layout Standard


\begin_inset LatexCommand \BibTeX[abbrv]{gp-bibliography,handelc}

\end_inset 


\layout LaTeX

\the_end
