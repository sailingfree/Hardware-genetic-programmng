<HTML>
<HEAD><TITLE>Highlighted source of C:\USER\PETES\PhD\hwgpperf\hwgp.c </TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<H1><FONT COLOR="#000000">FILE: C:\USER\PETES\PhD\hwgpperf\hwgp.c</H1><BR><FONT SIZE=3><PRE>
<HR><H1><FONT COLOR="#000000">Area Estimation</H1><BR><FONT SIZE=3><PRE>
<FONT COLOR="#000000"><H3>
Maximum area = 36016 nand gates
</H3>
<FONT COLOR="#000000"><H3>
C:\Program Files\Celoxica\RC1000\fpga\V2_1\XC4000\pp1000.h
</H3>
<FONT COLOR="#202020">/****************************************************************
*                                                               *
* Copyright 1991-2001 Celoxica Ltd.                             *
* All Rights Reserved                                           *
*                                                               *
* This is "Unpublished Proprietary Source Code" of Celoxica     *
* Ltd ("Celoxica").  The contents of this file may not          *
* be disclosed to third parties not covered by a Celoxica       *
* NDA (Non-Disclosure Agreement) or a Celoxica End User Licence *
* Agreement or other agreement.                                 *
*                                                               *
* In addition, the source code of this file may not be          *
* copied or duplicated in any form without the prior written    *
* authorization of Celoxica.                                    *
*                                                               *
* This code is protected by English and International           *
* copyright laws.  All use of this code is subject to the       *
* End User License Agreement, Non-Disclosure Agreement,         *
* or other agreement in effect with Celoxica.  If a             *
* licence document or agreement is not included with this       *
* source code please contact Celoxica immediately for a copy of *
* the applicable licence agreement.                             *
*                                                               *
* Any other use of this code other than as expressly agreed     *
* to by Celoxica including decompilation,                       *
* disassembly, or reverse engineering is unauthorised.          *
*                                                               *
* Rights of confidence, trademark rights, and other             *
* intellectual property rights reserved under the laws of       *
* England, the United States, and the International             *
* Community.                                                    *
*                                                               *
* World Wide Headquarters:                                      *
* Celoxica Limited                                              *
* 20 Park Gate                                                  *
* Abingdon                                                      *
* Oxfordshire                                                   *
* United Kingdom                                                *
* OX14 4SH                                                      *
* Tel:   +44 1235 863656                                        *
* Fax:   +44 1235 863648                                        *
*                                                               *
* US Headquarters:                                              *
* Celoxica Inc                                                  *
* 900 East Hamilton Ave.                                        *
* Suite 150                                                     *
* Campbell, CA 95008                                            *
* Tel: 1-408-626-9070                                           *
* Fax: 1-408-626-9079                                           *
*                                                               *
* Email     :   support@celoxica.com                            *
*                                                               *
*****************************************************************
* Project   :   RC1000-PP                                       *
* Date      :   09/06/98                                        *
* File      :   pp1000.h                                        *
* Author    :   Matthew Bowen                                   *
*                                                               *
* Date      Version     Author      Reason for change           *
* 09/06/98  0.98        MB          Created                     *
* 02/03/99  1.00        MB          Updated for rev 2.0 PCB     *
* 11/06/99  1.00        MB          First full release          *
*                                                               *
* Description                                                   *
*   Header file for RC1000-PP FPGA version 2.00 PCB.            *
*                                                               *
****************************************************************/

/*
 * Pins for RAM bank 0
 */
macro expr PP1000_Data0_3 = {
    "U29", "U33", "V32", "V31", "V29", "V30", "W31", "W33"};
macro expr PP1000_Data0_2 = {
    "W30", "W29", "Y32", "AF32", "Y30", "AA33", "Y29", "AA32"};
macro expr PP1000_Data0_1 = {
    "AA31", "AA30", "AK28", "AA29", "AB31", "AB30", "AC33", "AC31"};
macro expr PP1000_Data0_0 = {
    "AB29", "AC30", "AD31", "AE33", "AC29", "AE32", "AD30", "AE31"};
macro expr PP1000_Data0 = {
    "U29", "U33", "V32", "V31", "V29", "V30", "W31", "W33",
    "W30", "W29", "Y32", "AF32", "Y30", "AA33", "Y29", "AA32",
    "AA31", "AA30", "AK28", "AA29", "AB31", "AB30", "AC33", "AC31",
    "AB29", "AC30", "AD31", "AE33", "AC29", "AE32", "AD30", "AE31"};

macro expr PP1000_Addr0 = {
    "AN29", "AM31", "AD29", "AF31", "AE30", "AG33", "AH33", "AE29",
    "AJ26", "AF30", "AH32", "AJ32", "AF29", "AH31", "AG30", "AK32",
    "AJ31", "AG29", "AL33", "AH30", "AJ30" };

macro expr PP1000_CS0 = { "AL28", "AK27", "AL29", "AN31" };
macro expr PP1000_WE0 = { "AJ25" };
macro expr PP1000_OE0 = { "AK26" };
macro expr PP1000_CS0_0 = { "AN31" };
macro expr PP1000_CS0_1 = { "AL29" };
macro expr PP1000_CS0_2 = { "AK27" };
macro expr PP1000_CS0_3 = { "AL28" };



/*
 * Pins for RAM bank 1
 */
macro expr PP1000_Data1_3 = {
    "AB3", "AC1", "AB4", "AC3", "AA5", "AJ6", "AD3", "AE1"};
macro expr PP1000_Data1_2 = {
    "AC5", "AE3", "AD4", "AF1", "AF2", "AD5", "AG2", "AE4"};
macro expr PP1000_Data1_1 = {
    "AF3", "AH1", "AE5", "AJ1", "AF4", "AJ2", "AF5", "AH3"};
macro expr PP1000_Data1_0 = {
    "AG4", "AK2", "AJ3", "AG5", "AL1", "AH4", "AK3", "AN3"};
macro expr PP1000_Data1 = {
    "AB3", "AC1", "AB4", "AC3", "AA5", "AJ6", "AD3", "AE1", 
    "AC5", "AE3", "AD4", "AF1", "AF2", "AD5", "AG2", "AE4", 
    "AF3", "AH1", "AE5", "AJ1", "AF4", "AJ2", "AF5", "AH3", 
    "AG4", "AK2", "AJ3", "AG5", "AL1", "AH4", "AK3", "AN3"};

macro expr PP1000_Addr1 = {
    "AK10", "AM9", "U4", "U1", "U2", "V2", "V4", "V5", "V3", "W1", 
    "W3", "AK9", "W5", "AL8", "Y3", "Y4", "AA1", "Y5",
    "AA3", "AA4", "AN7"};

macro expr PP1000_CS1 = { "AK7", "AL6", "AJ8", "AM6" };
macro expr PP1000_WE1 = { "AK6" };
macro expr PP1000_OE1 = { "AL5" };
macro expr PP1000_CS1_0 = { "AM6" };
macro expr PP1000_CS1_1 = { "AJ8" };
macro expr PP1000_CS1_2 = { "AL6" };
macro expr PP1000_CS1_3 = { "AK7" };


/*
 * Pins for RAM bank 2
 */
macro expr PP1000_Data2_3 = {
    "D31", "F30", "C33", "G29", "E31", "D32", "G30", "F31" };
macro expr PP1000_Data2_2 = {
    "H29", "E32", "E33", "E28", "G31", "J29", "F33", "G32" };
macro expr PP1000_Data2_1 = {
    "J30", "H31", "K29", "H32", "J31", "K30", "H33", "L29" };
macro expr PP1000_Data2_0 = {
    "K31", "L30", "J33", "M29", "L31", "M30", "L32", "M31" };
macro expr PP1000_Data2 = {
    "D31", "F30", "C33", "G29", "E31", "D32", "G30", "F31",
    "H29", "E32", "E33", "E28", "G31", "J29", "F33", "G32",
    "J30", "H31", "K29", "H32", "J31", "K30", "H33", "L29",
    "K31", "L30", "J33", "M29", "L31", "M30", "L32", "M31" };
 
macro expr PP1000_Addr2 = {
    "B29", "E26", "F29", "L33", "N30", "N31", "M32", "P29",
    "P30", "D30", "P31", "P32", "R29", "R30", "R31", "R33",
    "T31", "T29", "T30", "T32", "U31"};

macro expr PP1000_CS2 = { "A31", "D28", "C30", "D29" };
macro expr PP1000_WE2 = { "C28" };
macro expr PP1000_OE2 = { "D27" };
macro expr PP1000_CS2_0 = { "D29" };
macro expr PP1000_CS2_1 = { "C30" };
macro expr PP1000_CS2_2 = { "D28" };
macro expr PP1000_CS2_3 = { "A31" };

/*
 * Pins for RAM bank 3
 */
macro expr PP1000_Data3_3 = {
    "J4", "H3", "K5", "H2", "J3", "K4", "J2", "L5"};
macro expr PP1000_Data3_2 = {
    "E8", "C6", "K2", "M5", "L3", "L1", "M4", "N5"};
macro expr PP1000_Data3_1 = {
    "M2", "N4", "N3", "N2", "P5", "U3", "P4", "D7"};
macro expr PP1000_Data3_0 = {
    "P2", "R5", "R4", "R3", "R1", "T4", "T5", "T2"};
macro expr PP1000_Data3 = {
    "J4", "H3", "K5", "H2", "J3", "K4", "J2", "L5", 
    "E8", "C6", "K2", "M5", "L3", "L1", "M4", "N5", 
    "M2", "N4", "N3", "N2", "P5", "U3", "P4", "D7", 
    "P2", "R5", "R4", "R3", "R1", "T4", "T5", "T2"};

macro expr PP1000_Addr3 = {
    "A5", "B5", "C5", "E7", "F5", "B3", "D3", "F4",
    "C1", "G5", "E3", "D2", "G4", "H5", "E2", "F3",
    "H4", "G3", "J5", "F1", "G1"};

macro expr PP1000_CS3 = { "B8", "A8", "D10", "C9" };
macro expr PP1000_WE3 = { "A6" };
macro expr PP1000_OE3 = { "B7" };
macro expr PP1000_CS3_0 = { "C9" };
macro expr PP1000_CS3_1 = { "D10" };
macro expr PP1000_CS3_2 = { "A8" };
macro expr PP1000_CS3_3 = { "B8" };

/*
 * Clock pin
 */
#if (defined(PP1000_DIVIDE1) && defined(PP1000_DIVIDE3)) || (defined(PP1000_DIVIDE1) && defined(PP1000_DIVIDE4)) || (defined(PP1000_DIVIDE3) && defined(PP1000_DIVIDE4))
#error Please define only one of PP1000_DIVIDE1, PP1000_DIVIDE3 or PP1000_DIVIDE4 before including pp1000.h
#endif

#if !defined(PP1000_DIVIDE1) && !defined(PP1000_DIVIDE3) && !defined(PP1000_DIVIDE4)
#error Please define one of PP1000_DIVIDE1, PP1000_DIVIDE3 or PP1000_DIVIDE4 before including pp1000.h
#endif

#ifndef PP1000_CLOCK
#define PP1000_CLOCK PP1000_MCLK
#endif

#define PP1000_MCLK "AH29"
#define PP1000_VCLK "AJ28"

#ifdef PP1000_DIVIDE1
set clock = external PP1000_CLOCK;
#elif defined(PP1000_DIVIDE3)
set clock = external_divide PP1000_CLOCK 3;
#elif defined(PP1000_DIVIDE4)
set clock = external_divide PP1000_CLOCK 4;
#endif

/*
 * PLX User I/O Pins
 */
macro expr PP1000_PLXUserIn = {"AJ10"};
macro expr PP1000_PLXUserOut = {"AL9"};

/*
 * Status byte pins
 */
macro expr PP1000_FPGAStatus = {
    "AJ15", "AK15", "AL15", "AM16", "AL16", "AJ16", "AK16", "AN17" };
macro expr PP1000_FPGAStatusValid = { "AN15" };
macro expr PP1000_FPGAStatusAck = { "AM14" };

/*
 * Control byte pins
 */
macro expr PP1000_FPGAControl = {
    "AL18", "AK18", "AJ18", "AN19", "AL19", "AK19", "AM20", "AJ19" };
macro expr PP1000_FPGAControlValid = { "AM18" };
macro expr PP1000_FPGAControlAck = { "AL20" };

/*
 * LED Pins
 */
macro expr PP1000_LEDPin0 = { "AN28" };
macro expr PP1000_LEDPin1 = { "AK25" };
macro expr PP1000_LEDPin2 = { "AL26" };
macro expr PP1000_LEDPin3 = { "AJ24" };
macro expr PP1000_LEDPin4 = { "AM27" };
macro expr PP1000_LEDPin5 = { "AM26" };
macro expr PP1000_LEDPin6 = { "AK24" };
macro expr PP1000_LEDPin7 = { "AL25" };

/*
 * Memory bank request
 */
macro expr PP1000_Bank0Req = { "AM30" };
macro expr PP1000_Bank1Req = { "AM4" };
macro expr PP1000_Bank2Req = { "C29" };
macro expr PP1000_Bank3Req = { "C8" };
macro expr PP1000_Bank0Grant = { "AM29" };
macro expr PP1000_Bank1Grant = { "AJ7" };
macro expr PP1000_Bank2Grant = { "B30" };
macro expr PP1000_Bank3Grant = { "D9" };

/*
 * Auxilliary I/O
 */
macro expr PP1000_Aux = {
    "E11", "A9", "C10", "D11", "B10", "B11", "D12", "A11",
    "E13", "C12", "D15", "D13", "C13", "E14", "A13", "D14",
    "C14", "E15", "C15", "A15", "D16", "B16", "B17", "C20",
    "E20", "B21", "C21", "D21", "B22", "E21", "D20", "D22",
    "A23", "C23", "E22", "B24", "D23", "A25", "E23", "B25",
    "D24", "C25", "B26", "E24", "C26", "D25", "A27", "A28",
    "E25", "C27"};

/*
 * Reset line
 */
macro expr PP1000_Reset = { "AL4" };

/*
 * Spare pins
 */
macro expr PP1000_Spare = {
    "U3", "M4", "F3", "F29", "AH5", "AJ1", "AA5", "U29",
    "AE31", "AF32", "A17", "B18", "C18", "B33", "E18", "D18",
    "A19", "C19", "D19", "E19", "B20", "C20", "D20", "D26",
    "B28", "B29", "E26", "E27", "E28", "D30",
    "E29", "AK30", "AJ29", "AN32", "AJ28", "AK29", "AL30", "AK28",
    "AM31", "AJ27", "AJ26", "AJ25", "AN29", "AJ23",
    "AN26", "AL24", "AK23", "AJ22", "AL23", "AM24", "AK22", "AM23",
    "AJ21", "AL22", "AN23", "AK21", "AM22", "AJ20", "AL21", "AN21",
    "AK20", "AL20", "AJ17", "AL17", "AL14", "AK14", "AJ14", "AN13",
    "AM13", "AL13", "AK13", "AJ13", "AM12", "AL12", "AK12", "AN11",
    "AJ12", "AL11", "AM10", "AL10", "AJ11", "AN9", "AK10", "AM9",
    "AJ10", "AM8", "AK9", "AL8", "AN7", "AJ9", "AL7",
    "AK8", "AN6", "AM5", "AN3", "AJ6",
    "AJ5", "AM1", "U5", "E4", "D4", "C4", "D17", "D5",
    "A2", "A3", "B4", "D7", "E8", "B5", "A5",
    "D8", "C7", "E9", "A6", "B7", "E10",
    "C11", "E15", "D15", "C16", "E16", "E17"};

macro expr PP1000_TDO = {"E6"};

/****************************************
* EXTERNAL RAM ACCESS MACRO DEFINITIONS *
****************************************/

/*
 * General RAM defintion - assume external clock divided by 4
 */
macro expr PP1000_RAMSpec(a, d, c, w, o) = 
{
    offchip = 1,
    addr = a,
    data = d,
    cs = c,
    we = w,
    oe = o,
#ifdef PP1000_DIVIDE1
    wegate = 1,
#elif defined(PP1000_DIVIDE3)
    westart = 1,    /* For external clock divided by 3, set write strobe to start */
    welength = 1,   /* 1/3 way through cycle and last for 1/3 of a cycle. */
#elif defined(PP1000_DIVIDE4)
    westart = 2,    /* For external clock divided by 4, set write strobe to start */
    welength = 1,   /* 1/2 way through cycle and last for 1/4 of a cycle. */
#endif
    warn = 0
};

#if defined(PP1000_32BIT_RAMS) && defined(PP1000_8BIT_RAMS)
#error Please define only one of PP1000_32BIT_RAMS or PP1000_8BIT_RAMS before including pp1000.h
#endif

#if !defined(PP1000_32BIT_RAMS) && !defined(PP1000_8BIT_RAMS)
#error Please define either PP1000_32BIT_RAMS or PP1000_8BIT_RAMS before including pp1000.h
#endif

#ifdef PP1000_32BIT_RAMS
/*
 * Declare 32 bit wide RAMs and access routines
 * Macros are:
 *  PP1000ReadBank#(DestReg, Address)
 *    where # is 0, 1, 2, 3
 *          DestReg is unsigned 32 bit word
 *          Address is 21 bit unsigned integer
 *  PP1000WriteBank#(Address, Value)
 *    where # is 0, 1, 2, 3
 *          Address is 21 bit unsigned integer
 *          Value is unsigned 32 bit expression
 */
ram unsigned 32 <FONT COLOR="#0040d0">PP1000Bank0[2097152]<FONT COLOR="#202020"> with PP1000_RAMSpec(PP1000_Addr0, PP1000_Data0, PP1000_CS0,
                                                         PP1000_WE0, PP1000_OE0);
macro proc PP1000ReadBank0(Reg, Addr) { <FONT COLOR="#0040d0">Reg = PP1000Bank0[Addr]<FONT COLOR="#202020">; }
macro proc PP1000WriteBank0(Addr, Expr) { <FONT COLOR="#0040d0">PP1000Bank0[Addr] = Expr<FONT COLOR="#202020">; }

ram unsigned 32 <FONT COLOR="#0040d0">PP1000Bank1[2097152]<FONT COLOR="#202020"> with PP1000_RAMSpec(PP1000_Addr1, PP1000_Data1, PP1000_CS1,
                                                         PP1000_WE1, PP1000_OE1);
macro proc PP1000ReadBank1(Reg, Addr) { <FONT COLOR="#0040d0">Reg = PP1000Bank1[Addr]<FONT COLOR="#202020">; }
macro proc PP1000WriteBank1(Addr, Expr) { <FONT COLOR="#0040d0">PP1000Bank1[Addr] = Expr<FONT COLOR="#202020">; }

ram unsigned 32 PP1000Bank2[2097152] with PP1000_RAMSpec(PP1000_Addr2, PP1000_Data2, PP1000_CS2,
                                                         PP1000_WE2, PP1000_OE2);
macro proc PP1000ReadBank2(Reg, Addr) { Reg = PP1000Bank2[Addr]; }
macro proc PP1000WriteBank2(Addr, Expr) { PP1000Bank2[Addr] = Expr; }

ram unsigned 32 PP1000Bank3[2097152] with PP1000_RAMSpec(PP1000_Addr3, PP1000_Data3, PP1000_CS3,
                                                         PP1000_WE3, PP1000_OE3);
macro proc PP1000ReadBank3(Reg, Addr) { Reg = PP1000Bank3[Addr]; }
macro proc PP1000WriteBank3(Addr, Expr) { PP1000Bank3[Addr] = Expr; }
#endif /* PP1000_32BIT_RAMS */


#ifdef PP1000_8BIT_RAMS
/*
 * Declare 8 bit wide RAMs and access routines
 * Macros are:
 *  PP1000ReadBank#(DestReg, Address)
 *    where # is 0, 1, 2, 3
 *          DestReg is unsigned 8 bit word
 *          Address is 23 bit unsigned integer (bottom 2 bit are byte select)
 *  PP1000WriteBank#(Address, Value)
 *    where # is 0, 1, 2, 3
 *          Address is 23 bit unsigned integer (bottom 2 bit are byte select)
 *          Value is unsigned 8 bit expression
 */
#define BUILD_RAM(n) \
ram unsigned 0 PP1000_Bank##n##WEOE[1] with PP1000_RAMSpec({}, {}, {}, PP1000_WE##n, PP1000_OE##n); \
ram unsigned 0 PP1000_Bank##n##Addr[2097152] with PP1000_RAMSpec(PP1000_Addr##n, {}, {}, {}, {}); \
ram unsigned 8 PP1000_Bank##n##Data0[1] with PP1000_RAMSpec({}, PP1000_Data##n##_0, {}, {}, {}); \
ram unsigned 0 PP1000_Bank##n##Ctrl0[1] with PP1000_RAMSpec({}, {}, PP1000_CS##n##_0, {}, {}); \
ram unsigned 8 PP1000_Bank##n##Data1[1] with PP1000_RAMSpec({}, PP1000_Data##n##_1, {}, {}, {}); \
ram unsigned 0 PP1000_Bank##n##Ctrl1[1] with PP1000_RAMSpec({}, {}, PP1000_CS##n##_1, {}, {}); \
ram unsigned 8 PP1000_Bank##n##Data2[1] with PP1000_RAMSpec({}, PP1000_Data##n##_2, {}, {}, {}); \
ram unsigned 0 PP1000_Bank##n##Ctrl2[1] with PP1000_RAMSpec({}, {}, PP1000_CS##n##_2, {}, {}); \
ram unsigned 8 PP1000_Bank##n##Data3[1] with PP1000_RAMSpec({}, PP1000_Data##n##_3, {}, {}, {}); \
ram unsigned 0 PP1000_Bank##n##Ctrl3[1] with PP1000_RAMSpec({}, {}, PP1000_CS##n##_3, {}, {}); \
macro proc PP1000ReadBank##n(Reg, Addr) \
{ \
    unsigned 0 Dummy[2] with {warn=0}; \
\
    par \
    { \
        Dummy[0] = PP1000_Bank##n##WEOE[0]; \
        PP1000_Bank##n##Addr[((unsigned 23)Addr)\\2] = 0; \
        switch(((unsigned 23)Addr)[1:0]) \
        { \
        case 0:\
            par \
            {\
                Reg = PP1000_Bank##n##Data0[0]; \
                Dummy[1] = PP1000_Bank##n##Ctrl0[0]; \
            } \
            break; \
        case 1:\
            par \
            {\
                Reg = PP1000_Bank##n##Data1[0]; \
                Dummy[1] = PP1000_Bank##n##Ctrl1[0]; \
            } \
            break; \
        case 2:\
            par \
            {\
                Reg = PP1000_Bank##n##Data2[0]; \
                Dummy[1] = PP1000_Bank##n##Ctrl2[0]; \
            } \
            break; \
        case 3:\
            par \
            {\
                Reg = PP1000_Bank##n##Data3[0]; \
                Dummy[1] = PP1000_Bank##n##Ctrl3[0]; \
            } \
            break; \
        default: delay; break; \
        } \
    } \
} \
\
macro proc PP1000WriteBank##n(Addr, Expr) \
{ \
    par \
    { \
        PP1000_Bank##n##WEOE[0] = 0; \
        PP1000_Bank##n##Addr[((unsigned 23)Addr)\\2] = 0; \
        switch(((unsigned 23)Addr)[1:0]) \
        { \
        case 0: \
            par \
            { \
                PP1000_Bank##n##Data0[0] = Expr; \
                PP1000_Bank##n##Ctrl0[0] = 0; \
            } \
            break; \
        case 1: \
            par \
            { \
                PP1000_Bank##n##Data1[0] = Expr; \
                PP1000_Bank##n##Ctrl1[0] = 0; \
            } \
            break; \
        case 2: \
            par \
            { \
                PP1000_Bank##n##Data2[0] = Expr; \
                PP1000_Bank##n##Ctrl2[0] = 0; \
            } \
            break; \
        case 3: \
            par \
            { \
                PP1000_Bank##n##Data3[0] = Expr; \
                PP1000_Bank##n##Ctrl3[0] = 0; \
            } \
            break; \
        default: delay; break; \
        } \
    } \
}

BUILD_RAM(0)
BUILD_RAM(1)
BUILD_RAM(2)
BUILD_RAM(3)

#endif /* PP1000_8BIT_RAMS */


#ifndef SIMULATE
/*
 * Macro to write word to FPGA->host status word
 */
unsigned 1 <FONT COLOR="#0040d0">PP1000_StatusValid<FONT COLOR="#202020"> = 1 with {warn = 0};
interface bus_out() PP1000_StatusValidBus(PP1000_StatusValid) with {data = PP1000_FPGAStatusValid};
interface <FONT COLOR="#0040d0">bus_clock_in(unsigned 1) PP1000_StatusAck()<FONT COLOR="#202020"> with {data = PP1000_FPGAStatusAck};
unsigned 8 <FONT COLOR="#0040d0">PP1000_StatusByte<FONT COLOR="#202020"> with {warn = 0};
interface bus_out() PP1000_StatusBus(PP1000_StatusByte) with {data = PP1000_FPGAStatus};

macro proc PP1000WriteStatus(Value)
{
    /*
     * Set value and assert valid pin
     */
    <FONT COLOR="#0040d0">PP1000_StatusByte = Value<FONT COLOR="#202020">;
    PP1000_StatusValid = 0;

    /*
     * Wait for acknowledge
     */
    <FONT COLOR="#0040d0">while (PP1000_StatusAck.in==1)
    {
        delay;
    }<FONT COLOR="#202020">

    /*
     * Clear valid pin
     */
    PP1000_StatusValid = 1;

    /*
     * Wait for acknowledge to clear
     */
    <FONT COLOR="#0040d0">while (PP1000_StatusAck.in==0)
    {
        delay;
    }<FONT COLOR="#202020">
}

/*
 * Macro to read word from host->FPGA control word
 */
unsigned 1 <FONT COLOR="#0040d0">PP1000_ControlAck<FONT COLOR="#202020"> = 1 with {warn = 0};
interface bus_out() PP1000_ControlAckBus(PP1000_ControlAck) with {data = PP1000_FPGAControlAck};
interface <FONT COLOR="#0040d0">bus_clock_in(unsigned 1) PP1000_ControlValid()<FONT COLOR="#202020"> with {data = PP1000_FPGAControlValid};
interface bus_in(unsigned 8) PP1000_ControlByte() with {data = PP1000_FPGAControl};

macro proc PP1000ReadControl(Reg)
{
    /*
     * Wait for flag to be asserted
     */
    <FONT COLOR="#0040d0">while (PP1000_ControlValid.in==1)
    {
        delay;
    }<FONT COLOR="#202020">

    /*
     * Read data and assert acknowledge
     */
    par
    {
        Reg = PP1000_ControlByte.in;
        PP1000_ControlAck = 0;
    }

    /*
     * Wait for flag to be deasserted
     */
    <FONT COLOR="#0040d0">while (PP1000_ControlValid.in==0)
    {
        delay;
    }<FONT COLOR="#202020">

    /*
     * Deassert acknowledge
     */
    <FONT COLOR="#0040d0">PP1000_ControlAck = 1<FONT COLOR="#202020">;
}


/*
 * Macros to turn LEDs on and off
 */
unsigned 1 PP1000_LEDState[8] with { warn = 0 };
interface bus_out() PP1000_LED0Bus(~PP1000_LEDState[0]) with { data = PP1000_LEDPin0, warn = 0 };
interface bus_out() PP1000_LED1Bus(~PP1000_LEDState[1]) with { data = PP1000_LEDPin1, warn = 0 };
interface bus_out() PP1000_LED2Bus(~PP1000_LEDState[2]) with { data = PP1000_LEDPin2, warn = 0 };
interface bus_out() PP1000_LED3Bus(~PP1000_LEDState[3]) with { data = PP1000_LEDPin3, warn = 0 };
interface bus_out() PP1000_LED4Bus(~PP1000_LEDState[4]) with { data = PP1000_LEDPin4, warn = 0 };
interface bus_out() PP1000_LED5Bus(~PP1000_LEDState[5]) with { data = PP1000_LEDPin5, warn = 0 };
interface bus_out() PP1000_LED6Bus(~PP1000_LEDState[6]) with { data = PP1000_LEDPin6, warn = 0 };
interface bus_out() PP1000_LED7Bus(~PP1000_LEDState[7]) with { data = PP1000_LEDPin7, warn = 0 };
macro proc PP1000SetLEDs(Mask)
{
    par
    {
        PP1000_LEDState[0] = Mask[0];
        PP1000_LEDState[1] = Mask[1];
        PP1000_LEDState[2] = Mask[2];
        PP1000_LEDState[3] = Mask[3];
        PP1000_LEDState[4] = Mask[4];
        PP1000_LEDState[5] = Mask[5];
        PP1000_LEDState[6] = Mask[6];
        PP1000_LEDState[7] = Mask[7];
    }
}

macro proc PP1000LEDOn(Number)
{
    /*
     * Use a switch to allow Number to be a variable/expression
     */
    switch(Number<-3)
    {
    case 0:
        PP1000_LEDState[0] = 1;
        break;
    case 1:
        PP1000_LEDState[1] = 1;
        break;
    case 2:
        PP1000_LEDState[2] = 1;
        break;
    case 3:
        PP1000_LEDState[3] = 1;
        break;
    case 4:
        PP1000_LEDState[4] = 1;
        break;
    case 5:
        PP1000_LEDState[5] = 1;
        break;
    case 6:
        PP1000_LEDState[6] = 1;
        break;
    case 7:
        PP1000_LEDState[7] = 1;
        break;
    }
}

macro proc PP1000LEDOff(Number)
{
    /*
     * Use a switch to allow Number to be a variable/expression
     */
    switch(Number<-3)
    {
    case 0:
        PP1000_LEDState[0] = 0;
        break;
    case 1:
        PP1000_LEDState[1] = 0;
        break;
    case 2:
        PP1000_LEDState[2] = 0;
        break;
    case 3:
        PP1000_LEDState[3] = 0;
        break;
    case 4:
        PP1000_LEDState[4] = 0;
        break;
    case 5:
        PP1000_LEDState[5] = 0;
        break;
    case 6:
        PP1000_LEDState[6] = 0;
        break;
    case 7:
        PP1000_LEDState[7] = 0;
        break;
    }
}


/*
 * Macros to request/release RAM banks
 */
#define PP1000_BANK0    0x1
#define PP1000_BANK1    0x2
#define PP1000_BANK2    0x4
#define PP1000_BANK3    0x8

unsigned 1 <FONT COLOR="#0040d0">PP1000_RAMRequest[4]<FONT COLOR="#202020"> with { warn = 0 };
interface bus_out() PP1000_RAMRequest0Bus(~PP1000_RAMRequest[0]) with { data = PP1000_Bank0Req, warn = 0 };
interface bus_out() PP1000_RAMRequest1Bus(~PP1000_RAMRequest[1]) with { data = PP1000_Bank1Req, warn = 0 };
interface bus_out() PP1000_RAMRequest2Bus(~PP1000_RAMRequest[2]) with { data = PP1000_Bank2Req, warn = 0 };
interface bus_out() PP1000_RAMRequest3Bus(~PP1000_RAMRequest[3]) with { data = PP1000_Bank3Req, warn = 0 };
interface <FONT COLOR="#0040d0">bus_clock_in(unsigned 1) PP1000_RAMGrant0Bus()<FONT COLOR="#202020"> with { data = PP1000_Bank0Grant, warn = 0 };
interface <FONT COLOR="#0040d0">bus_clock_in(unsigned 1) PP1000_RAMGrant1Bus()<FONT COLOR="#202020"> with { data = PP1000_Bank1Grant, warn = 0 };
interface <FONT COLOR="#0040d0">bus_clock_in(unsigned 1) PP1000_RAMGrant2Bus()<FONT COLOR="#202020"> with { data = PP1000_Bank2Grant, warn = 0 };
interface <FONT COLOR="#0040d0">bus_clock_in(unsigned 1) PP1000_RAMGrant3Bus()<FONT COLOR="#202020"> with { data = PP1000_Bank3Grant, warn = 0 };

macro proc PP1000RequestMemoryBank(BankMask)
{
    macro expr GrantMask = ~(PP1000_RAMGrant3Bus.in @
                             PP1000_RAMGrant2Bus.in @
                             PP1000_RAMGrant1Bus.in @
                             PP1000_RAMGrant0Bus.in);

    /*
     * Request banks
     * Use if statements to allow multiple requests in parallel
     * while avoiding parallel writes to registers
     */
    par
    {
        <FONT COLOR="#0040d0">if (BankMask[0])
        {
            PP1000_RAMRequest[0] = 1;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
        <FONT COLOR="#0040d0">if (BankMask[1])
        {
            PP1000_RAMRequest[1] = 1;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
        <FONT COLOR="#0040d0">if (BankMask[2])
        {
            PP1000_RAMRequest[2] = 1;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
        <FONT COLOR="#0040d0">if (BankMask[3])
        {
            PP1000_RAMRequest[3] = 1;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
    }

    /*
     * Wait for requested banks to be granted
     */
    <FONT COLOR="#0040d0">while ((GrantMask&BankMask)!=BankMask)
    {
        delay;
    }<FONT COLOR="#202020">
}

macro proc PP1000ReleaseMemoryBank(BankMask)
{
    /*
     * Release requests
     * Use if statements to allow multiple requests in parallel
     * while avoiding parallel writes to registers
     */
    par
    {
        <FONT COLOR="#0040d0">if (BankMask[0])
        {
            PP1000_RAMRequest[0] = 0;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
        <FONT COLOR="#0040d0">if (BankMask[1])
        {
            PP1000_RAMRequest[1] = 0;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
        <FONT COLOR="#0040d0">if (BankMask[2])
        {
            PP1000_RAMRequest[2] = 0;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
        <FONT COLOR="#0040d0">if (BankMask[3])
        {
            PP1000_RAMRequest[3] = 0;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
    }
}


/*
 * PLX General Purpose Input/Output
 */
unsigned 1 PP1000_PLXUser=0 with { warn = 0 };
interface bus_out() PP1000_PLXUserInBus(PP1000_PLXUser) with { data = PP1000_PLXUserIn, warn = 0 };
interface bus_clock_in(unsigned 1) PP1000_PLXUserOutBus() with { data = PP1000_PLXUserOut, warn = 0 };

macro proc PP1000SetGPI(Value)
{
    PP1000_PLXUser = Value!=0 ? 1 : 0;
}
macro expr PP1000ReadGPO() = PP1000_PLXUserOutBus.in;


/*
 * Reset bus
 */
interface bus_clock_in(unsigned 1) PP1000_ResetBus() with { data = PP1000_Reset, warn =  0 };
macro expr PP1000Reset() = ~PP1000_ResetBus.in;

#endif

ÿ<FONT COLOR="#000000"><H3>
C:\USER\PETES\PhD\hwgpperf\hwgp.c
</H3>
<FONT COLOR="#202020">/**************************************************************************
 * hwgp: Hardware implementation of Genetic Programming. Written in
 * Handel-C for compilation to a Xilinx FPGA
 *
 * Pete Martin 2001
 *
 ***************************************************************************
 * This file implements the following versions:
 *
 * -DHANDELC     for compling under handelc, both simulator and edif
 * -DDEBUG       for compliling for the handelc simulator
 *               if this is not defined but HANDELC is then it will compile
 *               for EDIF
 * 
 * -DPOPSIZE     Overrides the default population size
 * -DMAXPROGLEN  Overrides the default maximum progam length
 * -DPROBLEM=xxx Set the problem to compile for
 *               XOR
 *               ANT
 ***************************************************************************/

#define VERSION "1.0"

/*#define PRESET*/

#ifndef HANDELC
#include <stdio.h> 
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#else
#ifdef DEBUG

set clock = external "P35";

#else
/*
 * Include RC1000-PP support header file
 */
#if defined XC4000
#define BOARD_TYPE PP1000_V2_4000
#define PP1000_CLOCKRATE  10
#define PP1000_CLOCK    PP1000_MCLK with {rate=PP1000_CLOCKRATE}
#define PP1000_32BIT_RAMS
#define PP1000_DIVIDE1
#else
#define BOARD_TYPE PP1000_V2_VIRTEX
#define PP1000_CLOCKRATE  40
#define PP1000_CLOCK    PP1000_MCLK
#define PP1000_32BIT_RAMS
#define PP1000_DIVIDE4
#endif
#include <pp1000.h>

#endif  /* DEBUG */
#endif  /* !HANDELC */

#include <stdlib.h>

#include <hwgph.h>

/* Define the internal population storage
* this is a subset of the full population that is held in external
* static RAM. These are used for internal operations.
* There are 2 separate sets of individuals in ram here.
* Each one is used for a different phase of the pipeline 
* The working ram is arranged as WORDLEN bit words. The evaluation
* function will decode this into instruction sized chunks as needed.
* MPRAMs are used here, not because we want to access the rams twice in once
* clock cycle, but because this allows better routing performance.
*/

RAM Word  <FONT COLOR="#008080">workingPop  [MAXPHASE*MAXPAR][MAXNODES]<FONT COLOR="#202020"> WITHBLOCK;
RAM Bool <FONT COLOR="#0040d0">populationControl [POPSIZE]<FONT COLOR="#202020"> WITHBLOCK;
RAM Word <A NAME="area0"><U><FONT COLOR="#f80000">populationFitness [POPSIZE]</U><SUB>36016</SUB></A><FONT COLOR="#202020"> WITHBLOCK;
RAM Word <A NAME="area1"><U><FONT COLOR="#f88000">populationLen [POPSIZE]</U><SUB>35954</SUB></A><FONT COLOR="#202020"> WITHBLOCK;
/* Storage for the population control information
* This can be processed in parallel with the main population */
RAM Word <FONT COLOR="#0040d0">workingLen [MAXPHASE] [MAXPAR]<FONT COLOR="#202020"> WITHBLOCK;
RAM    PopIndex <FONT COLOR="#0040d0">workingprogNum[MAXPHASE][MAXPAR]<FONT COLOR="#202020"> WITHBLOCK;
RAM Word <FONT COLOR="#0040d0">workingFitness      [MAXPHASE] [MAXPAR]<FONT COLOR="#202020"> WITHBLOCK;



RAM Word      <FONT COLOR="#0040d0">workingParentFitness[MAXPHASE] [MAXPAR]<FONT COLOR="#202020"> WITHBLOCK;

UINT32        <FONT COLOR="#0040d0">cycles<FONT COLOR="#202020">; /* Count of cycles executed in main program */
Bool          <FONT COLOR="#0040d0">running<FONT COLOR="#202020">; /* Control the measurement of cycles */

#if 1
#if DEBUG
/* Provide some storage for sram if we are using the simulator */
ram UINT32  sram[4][POPSIZE*MAXNODES] WITHBLOCK;
#define RAMW (log2ceil(POPSIZE*MAXNODES))

macro proc PP1000WriteBank0(C_UINT addr, C_UINT val)
{
    sram[0][adju(addr,RAMW)]=val;
}

macro proc PP1000WriteBank1(C_UINT addr, C_UINT val)
{
    sram[1][adju(addr,RAMW)]=val;
}


macro proc PP1000ReadBank0(C_UINT val, C_UINT addr)
{
    val = sram[0][adju(addr,RAMW)];
}

macro proc PP1000ReadControl(x)
{
    x=1;
}

macro proc PP1000WriteStatus(x)
{

}

#endif


#if defined ANT
static UINT32 <A NAME="area3"><U><FONT COLOR="#008080">initialMap[32]</U><SUB>6784</SUB></A><FONT COLOR="#202020"> = {
  0x0000000e,
  0x00000008,
  0x0e000008,
  0x21000008,
  0x21000008,
  0x00601f78,
  0x20001000,
  0x00101000,
  0x00101000,
  0x20101000,
  0x00100000,
  0x00001000,
  0x20001000,
  0x00101000,
  0x1c101000,
  0x00820000,
  0x00000000,
  0x00001000,
  0x01011000,
  0x08011000,
  0x00011000,
  0x00011000,
  0x04001000,
  0x00801000,
  0x00010f98,
  0x00010002,
  0x00010002,
  0x00007f02,
  0x00000082,
  0x00000080,
  0x0000003c,
  0x00000000,
};

/* The active maps for the evalProgs to use */
RAM UINT32    <FONT COLOR="#008080">map[MAXPAR][GRIDX]<FONT COLOR="#202020">;

/* Init the maps from the initialMap */
macro proc initMap(C_UINT i)
{
    unsigned int <FONT COLOR="#0040d0">p<FONT COLOR="#202020">;
    Bool     <FONT COLOR="#0040d0">done<FONT COLOR="#202020">;

    <FONT COLOR="#0040d0">p = 0<FONT COLOR="#202020">;
    <FONT COLOR="#0040d0">do {
        map[i][p]=<A NAME="area2"><U><FONT COLOR="#008080">initialMap[p]</U><SUB>7047</SUB></A><FONT COLOR="#0040d0">;
        PAR {
	        p++;
            done = (p == 31);
        }
    } while(!done)<FONT COLOR="#202020">;
}
#endif

/*
* Define some control variables
*/
#if !defined HANDELC
Bool tree   = 0;   /* If true then print program tree */
Bool newseed= 0;   /* If true then ANSI_C version will generate seed */
#endif
Bool stopon = 0;   /* If true then stop if 100% correct prog */

UINT8 nbreed, nxover, ncopy, nmutate, nrand;

Phase <FONT COLOR="#0040d0">phBreed<FONT COLOR="#202020">;
Phase <FONT COLOR="#0040d0">phEval<FONT COLOR="#202020">;
Phase <FONT COLOR="#0040d0">phWriteback<FONT COLOR="#202020">;
unsigned char good = 0;
int   dumpProg     = 0;
int   dumpFittest  = 0;
int   dumpLengths  = 0;
int   verbose      = 0;
int   dumpFitlen   = 0;

/* 
 * Generic GP  function prototypes 
 */
macro proc initPop();
macro proc writeBack();
//macro proc writeBackInd(C_UINT phase, C_UINT ind);
//macro proc readIn(C_UINT i, C_UINT ind);
void readIn(PopIndex, WorkIndex);
macro proc findBest(C_UPTR best);
macro proc RandomGen();
macro proc evalProg(C_UINT indx);
macro proc CycleCount();

/*
 * output channel
 */
#ifdef HANDELC
/*chanout stdout;*/
chanout Short logout;
macro proc dooutdata(C_UINT c, C_UINT v)
{
#if DEBUG
	logout ! (Short)c;
	logout ! (Short)v;
#else	
	PP1000WriteStatus(c);
    PP1000WriteStatus(v);
#endif
}
#endif

/********************************************************************
 * Random number generator for Handelc
 *
 * Uses a shift register with taps and feedback
 ********************************************************************/
#ifdef HANDELC
#define RANDWIDTH  32  /* Number of bits in the generator 
                 			This is greater than the biggest number
                 			wanted from the generator*/ 
#endif

#define TAP1       0
#define TAP2       5
#define TAP3       9
#define TAP4       20
#define TAP5       30
#define TAP6       31

 


/* Channel for getting the seed */
#ifdef HANDELC
#ifdef SIMULATE
chanin  RandReg seedIn with {infile = "c:/tmp/seed.dat"};
chanout RandReg randout with {outfile = "c:/tmp/random.dat"};
#endif
#endif
#if defined HANDELC
/***************************************************************************
 * Name:     random
 *
 * Purpose:  Generate a pseudo-random number
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 *
 * Notes:    The number is stored in the static variable randReg
 * 
 ***************************************************************************/
RandReg <FONT COLOR="#0040d0">randReg<FONT COLOR="#202020">;    /* The register used for generating the number */
macro proc random()
{
  static unsigned int BITW  <FONT COLOR="#0040d0">oldbit0<FONT COLOR="#202020">;
  unsigned int BITW <FONT COLOR="#0040d0">bit0<FONT COLOR="#202020">;
  par {
    bit0 = <FONT COLOR="#0040d0">randReg[TAP1] ^ 
      randReg[TAP2] ^ 
      randReg[TAP3] ^ 
      randReg[TAP4] ^ 
      randReg[TAP5] ^ 
      randReg[TAP6]<FONT COLOR="#202020">;
    /* Shift by using all bits except top bit and adding bit 0 */
    randReg = randReg[RANDWIDTH-2:0]@oldbit0; 
    <FONT COLOR="#0040d0">oldbit0=bit0<FONT COLOR="#202020">;
  }
}

macro proc RandomGen()
{
  <FONT COLOR="#0040d0">while(1) {
    random();
  }<FONT COLOR="#202020">
}

macro proc CycleCount()
{
  <FONT COLOR="#0040d0">while(1) {
    if(running) {
        cycles++;
    } else {
        delay;
    }
  }<FONT COLOR="#202020">
}

/***************************************************************************
 * Name:     randseed
 *
 * Purpose:  Seed the random number generator
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 * 
 ***************************************************************************/
macro proc randseed()
{
#ifdef SIMULATE
  RandReg  seed;
  seedIn ? seed;
  randReg = seed;
#else
  PP1000RequestMemoryBank(1);
  PP1000ReadBank0(randReg,0);
  PP1000ReleaseMemoryBank(1);
#endif
}

/***************************************************************************
 * Name:     randXXXXX functions
 *
 * Purpose:  Generate random numbers of given widths and limits
 * 
 * Inputs:   None
 *
 * Returns:  A random number of the correct width
 *
 * Notes:    Each function requires 1 clock cycle for the random() call
 * 
 ***************************************************************************/

/* Return a value that is between 0 and MAXPROGLEN */
macro expr randPC() = 0@randReg[PROGW-1:0];

macro expr randLen() = <FONT COLOR="#0040d0">0@randReg[PROGW-1:0]|1<FONT COLOR="#202020">;

macro proc randMethod(method)
{
#define mask1 0x1f
#define mask2 0xfc
#define mask3 (~mask1)
#define mask4 (~mask2)

  UINT8 <FONT COLOR="#0040d0">v<FONT COLOR="#202020">, <FONT COLOR="#0040d0">v1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">v2<FONT COLOR="#202020">, <FONT COLOR="#0040d0">v3<FONT COLOR="#202020">, <FONT COLOR="#0040d0">v4<FONT COLOR="#202020">;

  <FONT COLOR="#0040d0">v = adju(randReg,8)<FONT COLOR="#202020">;
  PAR {
    v1 = <FONT COLOR="#0040d0">v&mask1<FONT COLOR="#202020">;
    v2 = <FONT COLOR="#0040d0">v&mask2<FONT COLOR="#202020">;
    v3 = <FONT COLOR="#0040d0">v&mask3<FONT COLOR="#202020">;
    v4 = <FONT COLOR="#0040d0">v&mask4<FONT COLOR="#202020">;
    <FONT COLOR="#0040d0">method = XOVER<FONT COLOR="#202020">;   /* Default method */
  }

  /* This long winded code generates shallow logic as 
     compared to a long if-then-else chain */

  /* Only override if we have the less probable cases */
  <FONT COLOR="#0040d0">if(!v3&&v1)
    method = MUTATE;
  else 
    delay;<FONT COLOR="#202020">
  <FONT COLOR="#0040d0">if(!v4&&v2)
    method =  COPY;
  else 
    delay;<FONT COLOR="#202020">
}

macro expr randPopIndex() = randReg[POPW-1:0];
#endif


macro proc PP1000WriteBank0func(C_UINT addr, C_UINT val)
{
	UINT32 <FONT COLOR="#0040d0">v<FONT COLOR="#202020">;
	
	<FONT COLOR="#0040d0">do {
    	PP1000WriteBank0(addr, val);
	PP1000ReadBank0(v,addr);
	} while(v != val)<FONT COLOR="#202020">;

}

macro proc PP1000WriteBank1func(C_UINT addr, C_UINT val)
{
	UINT32 <FONT COLOR="#0040d0">v<FONT COLOR="#202020">;
	
	<FONT COLOR="#0040d0">do {
    	PP1000WriteBank1(addr, val);
	PP1000ReadBank1(v,addr);
	} while(v != val)<FONT COLOR="#202020">;

}


macro proc mutate(C_UINT ind)
{
    Index           address;
    Phase           ph;

    ph = phBreed;
    /* Select an instruction to mutate */
    address = randPC() & adju(WorkingLenRead(ph,ind), IDXW);
    WorkingPopWrite(ph, ind, address, genNode());
#if 0
    printf("MASK = 0x%x\n", (FUNCMASK << (REGBITS+REGBITS)) | (REGMASK << REGBITS) | REGMASK);
    printf("GETOPCODEMASK = 0x%x\n", FUNCMASK << (REGBITS+REGBITS));
    printf("GETEA1MASK = 0x%x\n", (((REGMASK << REGBITS))));
    printf("GETEA2MASK = 0x%x\n", (REGMASK));
#endif
}


/* Copy individual at work index w to work index w+1 
* w is used directly and is always even (bit 0 == 0) and
w+1 is always odd (bit 0 == 1) */
macro proc copyInd(C_UINT w)
{
  Word    val;
  Index_1     count;
  Index       i;
  Phase       ph;
  Bool        done;

  PAR {
    i  = 0;
    count = 0;
    ph = phBreed;
  }

  do {
    WorkingPopRead(ph,w, i, C_ADDR val);
    WorkingPopWrite(ph,w | 1, i, val);
    PAR {
        count++;
        i++;
        done = (count == MAXNODES-1);
    }
  }while(!done);
}

/* Original saturating crossover */
#if defined TRUNCATE
#warning Truncate method selected
macro proc xover(C_UINT w)
{
  Word  val, val2;
  Word  len1;
  Word  len2;
  Word  newlen1, newlen2;
  PC      x1, x2;
  PC      i1, i2;
  Index  idx1, idx2;
  Index  count1, count2;
  Phase    ph;

  ph = phBreed;
  /*
   * Choose two crossover points at random and get the program lengths
   */


  PAR {
    x1 = randPC();
    len1 = WorkingLenRead(ph,w);
  }
  PAR {
    x2 = randPC();
    len2 = WorkingLenRead(ph,w | 1);
  }

	/*
	* Crudely adjust the crossover points so that they lie within the 
	* individual
	*/
  PAR {
#if defined BOOLOP
    x1 &= adju(len1, PROGW);
    x2 &= adju(len2, PROGW);
#else
    x1 %= adju(len1, PROGW);
    x2 %= adju(len2, PROGW);
#endif
}
  /*
  * calculate the starting points for crossover 
  */
  	PAR {
    	i1 = x1;
    	i2 = x2;
	}

  /*
  * Calculate the count of instructions for copying
  * count1 correspnds to individual 1
  */
  PAR {
	count1 = adju(len1, IDXW) - i1;
	count2 = adju(len2, IDXW) - i2;
  }
  /*
   * Copy until both counts have been exhausted
   */
  do {
    PAR {
        idx1 = i1;
        idx2 = i2;
    }
    PAR {
        WorkingPopRead(ph, w, idx1, C_ADDR val);
        WorkingPopRead(ph,w | 1, idx2, C_ADDR val2);
    }
    PAR {
        WorkingPopWrite(ph,w,idx1, val2);
        WorkingPopWrite(ph, w | 1, idx2, val);
    }
	/* 
	* Calculate the counts, but don't let them go below zero 
	* and calculate the next indexes, but don't let them go beyond MAXNODES
	*/
    PAR {
		if(count1) 
			count1--;
        else
            delay;
		if(count2)
			count2--;
        else
            delay;
		if(i1 != MAXPROGLEN-1)
			i1++;
        else
            delay;
		if(i2 != MAXPROGLEN-1)
			i2++;
        else
            delay;
    }
  }while( count1|| count2);
  /*
   * Adjust the lengths - broken into 2 bits to speedup the logic
   */
   PAR {
        newlen1 = adju(x1 + (adju(len2,PROGW)), WORDW);
        newlen2 = adju(x2 + (adju(len1,PROGW)), WORDW);
   }
   PAR {
        newlen1 = newlen1 - adju(x2, WORDW);
        newlen2 = newlen2 - adju(x1, WORDW);
   }
   //   printf("x1=%d x2=%d len1=%d, len2=%d, newlen1=%d, newlen2=%d\n", 
   //	  x1,x2,len1,len2,newlen1,newlen2);
#if defined BOOLOP
    /* Guard against zero length programs whcih are no good at all */
    while(!len1) {
      len1 = randLen();
    }

    while(!len2) {
      len2 = randLen();
    }
#endif

    /* Saturate the sizes to the maximum */
    if(newlen1>MAXNODES-1) newlen1=MAXNODES-1;
    if(newlen2>MAXNODES-1) newlen2=MAXNODES-1;

    PAR {
        WorkingLenWrite(ph, w)     =  newlen1;
        WorkingLenWrite(ph, w | 1) =  newlen2;
    }
}


#elif defined LIMITED
#warning Limiting crossover selected
/* New improved crossover */
macro proc xover(C_UINT w)
{
  Word  <FONT COLOR="#0040d0">val<FONT COLOR="#202020">, <FONT COLOR="#0040d0">val2<FONT COLOR="#202020">;
  Word  <FONT COLOR="#0040d0">len1<FONT COLOR="#202020">;
  Word  <FONT COLOR="#0040d0">len2<FONT COLOR="#202020">;
  Word  <FONT COLOR="#0040d0">olap1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">olap2<FONT COLOR="#202020">;   
  PC      <FONT COLOR="#0040d0">x1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">x2<FONT COLOR="#202020">;
  PC      i1, i2;
  Index  <FONT COLOR="#0040d0">idx1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">idx2<FONT COLOR="#202020">;
  Index  <FONT COLOR="#0040d0">count1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">count2<FONT COLOR="#202020">;
  Phase    <FONT COLOR="#0040d0">ph<FONT COLOR="#202020">;
  Word   <FONT COLOR="#0040d0">newlen1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">newlen2<FONT COLOR="#202020">;
  Bool   <FONT COLOR="#0040d0">done1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">done2<FONT COLOR="#202020">;
  Bool   <FONT COLOR="#0040d0">olapDone1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">olapDone2<FONT COLOR="#202020">;



  <FONT COLOR="#0040d0">ph = phBreed<FONT COLOR="#202020">;
  
  <FONT COLOR="#0040d0">do {
    /*
     * Choose two crossover points at random and get the program lengths
     */
    PAR {
      x1 = randPC();
      len1 = WorkingLenRead(ph,w);
    }
    PAR {
      x2 = randPC();
      len2 = WorkingLenRead(ph,w | 1);
    }

    /*
     * Adjust the crossover points so that they lie within the 
     * individual. This is modulus by remainder.
     */
    PAR {
      while(x1>=adju(len1,PROGW)) {
         x1 -= adju(len1,PROGW);   
      }
      while(x2>=adju(len2,PROGW)) {
          x2 -= adju(len2,PROGW);
      }
    }
    
    /* Get size of new individuals */
    newlen1 = adju(x1, WORDW) + (len2 - adju(x2, WORDW));
    newlen2 = adju(x2, WORDW) + (len1 - adju(x1, WORDW));

    /* See if the newlens are bigger than MAXNODES-1 */
    olap1 = newlen1 & ~(MAXNODES-1);
    olap2 = newlen2 & ~(MAXNODES-1);
    olapDone1 = !(olap1 == 0);
    olapDone2 = !(olap2 == 0);
#if defined DUALXOVER
#warning DUAL Xover
  } while(olapDone1 || olapDone2);
#else
#warning SINGLE xover
  } while(olapDone1 && olapDone2)<FONT COLOR="#202020">;
#endif
  
  /*
   * calculate the starting points for crossover 
   */
  PAR {
    i1 = x1;
    <FONT COLOR="#0040d0">i2 = x2<FONT COLOR="#202020">;
  }
  
  /*
   * Calculate the count of instructions for copying
   * count1 corresponds to individual 1
   */
  PAR {
    <FONT COLOR="#0040d0">if(!olap1)
      count1 = adju(len2, IDXW) - x2;
    else
      count1 = 0;<FONT COLOR="#202020">
    <FONT COLOR="#0040d0">if(!olap2) 
      count2 = adju(len1, IDXW) - x1;
    else
      count2 = 0;<FONT COLOR="#202020">
    idx1 = x1;
    <FONT COLOR="#0040d0">idx2 = x2<FONT COLOR="#202020">;
  }
  /*
   * Copy until both counts have been exhausted
   */
  <FONT COLOR="#0040d0">do {
  	PAR {
		done1 = (count1 == 0);
		done2 = (count2 == 0);
	}
    PAR {
      WorkingPopRead(ph, w, idx1, C_ADDR val);
      WorkingPopRead(ph,w | 1, idx2, C_ADDR val2);
    }
    PAR {
      if(!done1) {
	WorkingPopWrite(ph,w,idx1, val2);
	count1--;
	idx1++;
      }
      if(!done2) {
	WorkingPopWrite(ph, w | 1, idx2, val);
	count2--;
	idx2++;
      }
      }
  }while( count1 || count2)<FONT COLOR="#202020">;
  
  PAR <FONT COLOR="#0040d0">{
    if(!olap1)
      WorkingLenWrite(ph, w) =  newlen1;
    if(!olap2)
      WorkingLenWrite(ph, w | 1) =  newlen2;
    }<FONT COLOR="#202020">
}

#else
#error Please specify TRUNCATE or LIMITED crossover
#endif
/***************************************************************************
 * Name:     selection
 *
 * Purpose:  Selects MAXPAR individuals for breeding and copies them from
 *           external SDRAM into working ram
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 *
 * Notes:    Uses the phSelect to index into the required working memory
 *           No attempt is made to see if we overselect an individual.
 *           We only allow individuals that are not in workingPop
 * 
 * 	     The selection is tournament and uses a tournament size of 2.
 * 
 ***************************************************************************/
macro proc selection()
{
  WorkIndex    <FONT COLOR="#0040d0">w<FONT COLOR="#202020">;
  PopIndex     <FONT COLOR="#0040d0">i<FONT COLOR="#202020">, <FONT COLOR="#0040d0">i1<FONT COLOR="#202020">,<FONT COLOR="#0040d0">i2<FONT COLOR="#202020">;
  Word         <FONT COLOR="#0040d0">fit1<FONT COLOR="#202020">,<FONT COLOR="#0040d0">fit2<FONT COLOR="#202020">;
  Phase        <FONT COLOR="#0040d0">ph<FONT COLOR="#202020">;
  Word         <FONT COLOR="#0040d0">fit<FONT COLOR="#202020">;

#if defined HANDELCXX && !defined DEBUG
    interface fastle(unsigned 1 A_LT_B)
        FastLt(Word A=fit1, Word B=fit2) with {busformat="B<I>"};
#endif

  PAR {
    w = 0;
    <FONT COLOR="#0040d0">ph = phBreed<FONT COLOR="#202020">;
  }

  <FONT COLOR="#0040d0">do {
    /* 
     * Find 2 individuals that are not the same and that are not in 
     * workingPop
     */
    do {
      i1 = randPopIndex();
      fit1 = populationFitness[i1];
    } while(populationControl[i1]);

    do {
      i2 = randPopIndex();
      fit2 = populationFitness[i2];
    } while(populationControl[i2] || i1 == i2);
    /*
     * Choose the one with best fitness. 0 is best!
     */
    i = UnsignedLt(fit1, fit2, MAXFITW) ? i1 : i2;
    /*
     * Read it into workingPop and remember the fitness in the parent array
     */
    readIn(i,w);
    fit = adju(workingFitness[ph][w], WORDW);
    workingParentFitness[ph][w] = fit;
    w++;
  }while(LIMIT(w,MAXPAR))<FONT COLOR="#202020">;
}



/***************************************************************************
 * Name:     breed
 *
 * Purpose:  Performs the breeding operations on the working ram pointed to
 *           by phBreed
 *           Once this has finished, there will be MAXPAR new individuals
 *           to evaluate
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 * 
 * Notes:    Since crossover and copy use 2 individuals, we arrange for
 *           all breed operations to operate on 2 individuals.
 *           This means that there are MAXWORK/2 breed operations.
 *           The individuals for breeding have already been placed in pairs
 *           in working memory, at addresses i, i+1
 ***************************************************************************/
macro proc breed()
{
  WorkIndex <FONT COLOR="#0040d0">count1<FONT COLOR="#202020">, count2;
  WorkIndex_1 <FONT COLOR="#0040d0">loop<FONT COLOR="#202020">;
  Method    method;

#if !defined PRESET
    /* Count1 and count2 get incremented twice in the do loop */
  PAR {
    count1 = 0;
    count2 = 0;
    <FONT COLOR="#0040d0">loop   = 0<FONT COLOR="#202020">;
  }

  <FONT COLOR="#0040d0">do {
    /* 
     * Select breed method
     */
    PAR {
        randMethod(C_ADDR method);
        count2++;   /* Now count 2 = count1+1 */
    }
	xover(count1);
	nxover++;
#if 0
    switch(method) {
        case MUTATE:
            mutate(count1);
            PAR {
                mutate(count2);
                nmutate++;
            }
            break;
        case XOVER:
            PAR {
                xover(count1);
                nxover++;
            }
            break;
        default:
            PAR {
                copyInd(count1);
                ncopy++;
            }
            break;
    }
#endif
    loop+=2;
  }while(!BITSET(loop, MAXPAR))<FONT COLOR="#202020">;
#endif
}

/***************************************************************************
 * Name:     replacement
 *
 * Purpose:  Replaces an individual with the newly evaluated individual.
 *
 * Inputs:   The PAR number
 *
 * Returns:  Nothing
 * 
 ***************************************************************************/
macro proc replacement()
{
    /* Decide whether the evaluated individual will replace 
     * the corresponding w'th parent */
    WorkIndex <FONT COLOR="#0040d0">w<FONT COLOR="#202020">;
    Phase     <FONT COLOR="#0040d0">ph<FONT COLOR="#202020">;
    Word      <FONT COLOR="#0040d0">myFit<FONT COLOR="#202020">;
    Word      <FONT COLOR="#0040d0">parentFit<FONT COLOR="#202020">;
    Bool      <FONT COLOR="#0040d0">better<FONT COLOR="#202020">;

#if defined HANDELCxx && !defined DEBUG
    interface fastle(unsigned 1 A_LE_B)
        FastLe(Word A=myFit, Word B=parentFit) with {busformat="B<I>"};
#endif

    PAR {
      w = 0;
      <FONT COLOR="#0040d0">ph = phEval<FONT COLOR="#202020">;
    }

    <FONT COLOR="#0040d0">do {
        /* See if new individual is better than or the same as it's parent */
        PAR {
            myFit = workingFitness[ph][w];
            parentFit = workingParentFitness[ph][w];
        }
        better = UnsignedLe(myFit,parentFit, MAXFITW);
        if(better) {
            delay;   /* 
                      * Yes it is so leave the indicator set 
                      * so it gets written back 
                      */
        } else {
                    /* 
                     * The new program is worse than the worst parent so discard it
                     * by clearing the control bit so it doesn't get written back 
                    */
            populationControl[WorkingprogNumWrite(ph,w)] = 0;
        }
        w++;
    } while(LIMIT(w,MAXPAR))<FONT COLOR="#202020">;
}

/***************************************************************************
 * Name:     evaluate
 *
 * Purpose:  Evaluates the fitness of all individuals in working ram pointed 
 *           to by phEval;
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 * 
 ***************************************************************************/
macro proc evaluate()
{
  int w;

  <FONT COLOR="#0040d0">FORPAR(w=0; w<MAXPAR;w++) {
    evalProg(w);
  }<FONT COLOR="#202020">
}


/***************************************************************************
 * Name:     findBest
 *
 * Purpose:  Locates the best individual in the population
 * 
 * Inputs:   Nothing
 *
 * Returns:  The individual number
 * 
 ***************************************************************************/
macro proc findBest(C_UPTR best)
{
    PopIndex_1      count;
    Word            fit, bestf;

    PAR {
        bestf = -1;
        count = 0;
    }

    do {
        fit = populationFitness[adju(count, POPW)];
        if(UnsignedLt(fit, bestf, MAXFITW)){
            bestf = fit;
            C_PTR best  = adju(count, POPW);
        } else {
	        delay;
        }
        count++;     
    } while(!BITSET(count,POPSIZE));
}


macro proc donl()
{
#if !defined HANDELC
  printf("\n");
#endif
}

/***************************************************************************
 * Name:     printInstruction
 *
 * Purpose:  Prints the given program to the output channel
 * 
 * Inputs:   Nothing
 *
 * Returns:  The individual number
 * 
 ***************************************************************************/
macro proc printInstruction(C_UINT word)
{
  printf("0x%x ", word);
  dooutdata(FUNC,adju(GetOpcode(word),8));
  dooutdata(EA1,adju(GetEa1(word),8));
  dooutdata(EA2,adju(GetEa2(word),8));
  donl();
}

macro proc printProg(C_UINT idx)
{
  WorkIndex w;
  Index i;
  Word word;
  PopIndex prog;
  Index_1  len;
  Index_1 count;  /* We rely on the use of a carry into bit 
		     IDXW+1 to detect the end of the loop */

  PAR {
    w = 0;
    i = 0;
  }
  readIn(idx,w);

  prog = WorkingprogNumRead(phBreed,w);
  dooutdata(IND, adju(prog,8));
  donl();
  word = adju(WorkingFitnessRead(phBreed,w), WORDW);
  dooutdata(FIT, adju(word,8));
  donl();
  len = adju(WorkingLenRead(phBreed,w), IDXW+1);
  dooutdata(LEN, adju(len,8));
  donl();
  count = MAXNODES - len;

  while(!BITSET(count, MAXNODES)) {  /* Guard against zero length programs */
    WorkingPopRead(phBreed,w,i, C_ADDR word);
	i = i + 1;
    printInstruction(word);
    count++;
  }
#if defined ANT && !defined HANDELC
  {
    FILE    *df;
   
    if((df=fopen("trail.dat", "w")) == NULL ) {
      perror("Creating ant trail file");
      df = stdout;
    }
    for(i=0;i<len;i++) {
      WorkingPopRead(phBreed,w,i,C_ADDR word);
      printf("%d %d %d\n", GetOpcode(word), GetEa1(word), GetEa2(word));
      fprintf(df, "%d %d %d\n", GetOpcode(word), GetEa1(word), GetEa2(word));
    }
    if(df) fclose(df);
  }
#endif
}

macro proc printStats()
{
  dooutdata(NMUTATE, nmutate);
  dooutdata(NXOVER, nxover);
  dooutdata(NCOPY, ncopy);
}

macro proc printGen(C_UINT gen)
{
  dooutdata(GEN, gen);
}


<FONT COLOR="#0040d0">void dumpResults()
{
    MainPopIndex   page0;
    MainPopIndex   page1;
    MainPopIndex   page2;
	MainPopIndex   addr;
	UINT32         val;
    PopIndex_1     idx;
    Word           fit, len;
	Bool           done;

    PP1000RequestMemoryBank(2);
    PAR {
        idx      = 0;
        page0    = 0;
        page1    = POPSIZE;
        page2    = POPSIZE*2;
    }
	addr = page0 | 1;
    PP1000WriteBank1func(addr, GENSIZE);
	addr = page0 | 2;
    PP1000WriteBank1func(addr, GENERATIONS);
	addr = page0 | 3;
    PP1000WriteBank1func(addr, MAXPAR);
	addr = page0 | 4;
    PP1000WriteBank1func(addr, MAXPROGLEN);
	addr = page0 | 5;
    PP1000WriteBank1func(addr, PROBLEMTYPE);
	addr = page0 | 6;
    PP1000WriteBank1func(addr, cycles);
	addr = page0 | 7;
    PP1000WriteBank1func(addr, POPSIZE);
    do { 
        PAR {
            fit = populationFitness[adju(idx,POPW)];
            len = populationLen[adju(idx,POPW)];
        }
		PAR {
			addr = page1 | adju(idx, SRAMW);
			val  = adju(fit,32);
		}
        PP1000WriteBank1func(addr, val);
		PAR {
			addr = page2 | adju(idx, SRAMW);
			val  = adju(len,32);
		}
        PP1000WriteBank1func(addr, val);
		done = (idx == POPSIZE-1);
        idx++;        
    }while(!done);
    PP1000ReleaseMemoryBank(2);
}<FONT COLOR="#202020">

<FONT COLOR="#0040d0">void printLengths(Generation generation)
{
#if !defined HANDELC
  if(dumpLengths && generation % (POPSIZE/(MAXPAR)) == 0) {
    int i;
    
    for(i=0;i<POPSIZE;i++) {
      printf("%d ", populationLen[i]);
    }
    printf("\n");
  }
#endif
}<FONT COLOR="#202020">

/***************************************************************************
 * Name:     main
 *
 * Purpose:  The main function
 * 
 * Inputs:   nothing
 *
 * Returns:  nothing
 * 
 * Note:     
 *
 ***************************************************************************/
MAINTYPE main MAINARGS
<FONT COLOR="#0040d0">{
  /* Control variables to drive pipeline */
  Bool          doEval;
  Bool          selectionDone;
  Generation_w  generation;
  PopIndex      best;
#if defined HANDELC
  UINT8         ctrl;
#endif
  Bool evalDone;
  
  evalDone = 0;

#if !defined HANDELC && !defined PSIM
  if(argc >1) {
    int a = 1;
    do {
      if(strcmp(argv[a], "-s") == 0) {
    	newseed = 1;
      }
      else if(strcmp(argv[a], "-p") == 0) {
	dumpProg = 1;
      }
      else if(strcmp(argv[a], "-f") == 0) {
	dumpFittest = 1;
      }
      else if(strcmp(argv[a], "-l") == 0) {
	dumpLengths = 1;
      }
      else if(strcmp(argv[a], "-v") == 0) {
	verbose = 1;
      } 
      else if(strcmp(argv[a], "-t") == 0) { 
	dumpFitlen = 1;
      } else {
	printf("Usage: %s [-s] [-p] [-f]\n", argv[0]);
	printf("\t-s set the random number seed from the clock\n");
	printf("\t-p dump the best program at the end\n");
	printf("\t-f dump the value of the fittest program once per generation\n");
	printf("\t-l dump the program lengths for each generation\n");
	printf("\t-v print verbose debug information\n");
	printf("\t-t print the lengths of programs that are 100%% fit\n");
	exit(1);
      }
      a++;
    } while(a < argc);
  }
  stopon=1;
#endif

  /* Wait for the host to tell us to start */
  PP1000ReadControl(ctrl);

  /* Initialise variables etc */
  PAR {
    phBreed     = 0;
    phEval      = 1;   /* Delayed by one pass so starts at 1 */
    doEval      = 0;
    generation  = 0;
    cycles      = 0;
    randseed();
  }

  PP1000RequestMemoryBank(1);
  PP1000WriteStatus(1);
  running = 1;
  PAR {

    /* Count cycles */
    CycleCount();

    /* Run the random number generator */
    RandomGen();


    SEQ {
      /* Build the initial population */
      initPop();   /* Uses phase 0 */
      printLengths(0);
    
      /* 
       * Run the main pipeline. This will process MAXPAR individuals per pass
       * A generation is done when POPSIZE/MAXPAR individuals have been done
       * so the total number of passes is GENSIZE = GENERATONS * (POPSIZE/MAXPAR) 
       */
        do {
             selectionDone = 0;
	         PAR {
 		        	/* The selection block */
		   SEQ {
		     phWriteback = phBreed;   /* Write back this phase before we overwrite it */
		     writeBack();   
		     selection();  
		     selectionDone = 1;      
		     breed();
		     doEval=1;
		   }


            	  /* The eval block (only starts when we have done the 1st breed) */
	            SEQ {
	                if(doEval) {
#if defined NOFITNESS
#warning No fitness selected
#else
			  evaluate();
			  evalDone=1;

#endif
			  /*
			   * Now wait until selection() has finished with the 
			   * global fitness and population and perform the replacement
			   */
                        WAIT(selectionDone);
                        replacement();
	                } else delay;
	            } /* SEQ for eval block */
	        } /* PAR for main loop */
#if !defined HANDELC
		 if(dumpFittest && generation % (POPSIZE/MAXPAR) == 0) {
		   findBest(C_ADDR best);
		   printf("%d\n", populationFitness[best]);
		 }
		 printLengths(generation);
#endif
            PAR {
	        generation++;
                TOGGLE(phBreed);
                TOGGLE(phEval);
            }
	    //			printGen(adju(generation,8));
      } while(!BITSET(generation, GENSIZE));
      phWriteback = phBreed;
      writeBack();    /* Write the last evaluated individuals */

      /* Tell the cycle counter to stop */
      running = 0;
#if !defined HANDELC
      if(dumpProg) {
	findBest(C_ADDR best);
	printProg(best);
      }
      if(dumpFitlen) {
	int f;
	int l;

	findBest(C_ADDR best);
	readIn(best,0);
	if((f=WorkingFitnessRead(phBreed,0)) == 0) {
	  l = WorkingLenRead(phBreed,0);
	  printf("%d\n", l);
	}
      }
#endif
      PP1000ReleaseMemoryBank(1);

      /* Write the lengths and fitnesses to the sram */
      dumpResults();

      /* Release all banks and signal that we have finished */
      PP1000WriteStatus(good);
      
      /*
       * This marks the end of the GP algorithm.
       * The machine will still be running the random number
       * generator and the cycle counter(s) however until 
	   * the machine is reset
       */        
    } /* SEQ */
  } /* par */
  MAINRET;
}<FONT COLOR="#202020">


/***************************************************************************
 * Name:     makeProg
 *
 * Purpose:  Make an individual program.
 * 
 * Inputs:   The phase to write to (1st index into block select ram )
 *           The individual number within the phase (2nd index into ram )
 *
 * Returns:  Nothing
 *
 * Notes:    We generate the maximal number of instructions regardless
 *           of the actual length to simplify the logic. It is not an expensive
 *           operation in the general scheme of things.
 * 
 ***************************************************************************/
macro proc makeProg() 
{ 
    PC        <FONT COLOR="#0040d0">proglen<FONT COLOR="#202020">;
    Proglen_1 <FONT COLOR="#0040d0">icount<FONT COLOR="#202020">;
    Index     <FONT COLOR="#0040d0">i<FONT COLOR="#202020">;
    Phase     <FONT COLOR="#0040d0">zero<FONT COLOR="#202020">;
    static PopIndex <FONT COLOR="#0040d0">progNum<FONT COLOR="#202020"> = 0;

#if defined PRESET
#if defined ANT
    zero = 0;
    WorkingLen(zero,0) = 12;
    WorkingFitness(zero,0) = DEFAULT_FITNESS;
    WorkingprogNum(zero,0) = progNum;
    populationControl[progNum]= 1;
    progNum++;
    WorkingPopWrite(zero,0,0,0x07);
    WorkingPopWrite(zero,0,1,0x1c);
    WorkingPopWrite(zero,0,2,0x11);
    WorkingPopWrite(zero,0,3,0x07);
    WorkingPopWrite(zero,0,4,0x14);
    WorkingPopWrite(zero,0,5,0x12);
    WorkingPopWrite(zero,0,6,0x0b);
    WorkingPopWrite(zero,0,7,0xc);
    WorkingPopWrite(zero,0,8,0xc);
    WorkingPopWrite(zero,0,9,0xe);
    WorkingPopWrite(zero,0,10,0x19);
    WorkingPopWrite(zero,0,11,0xe);
#elif defined BOOLPARITY
    zero = 0;
    WorkingLenWrite(zero,0) = 8;
    WorkingFitnessWrite(zero,0) = DEFAULT_FITNESS;
    WorkingprogNumWrite(zero,0) = progNum;
    populationControl[progNum]= 1;
    progNum++;
    WorkingPopWrite(zero,0,0,0x33);
    WorkingPopWrite(zero,0,1,0x2f);
    WorkingPopWrite(zero,0,2,0x2f);
    WorkingPopWrite(zero,0,3,0x2f);
    WorkingPopWrite(zero,0,4,0x0);
    WorkingPopWrite(zero,0,5,0x2f);
    WorkingPopWrite(zero,0,6,0x18);
    WorkingPopWrite(zero,0,7,0x18);
#else
#error No preset data for this problem type
#endif
#else

    /* 
    * Determine initial program length. We ensure that this is greater than 0 
    */
    PAR {
      proglen = randLen();
      <FONT COLOR="#0040d0">zero = 0<FONT COLOR="#202020">;
    }
    /*
     * Initialise the program in block select memory 
     * Dont try to optimise the number of nodes to be the length
     * as this will add extra logic.
     */
    PAR {
        WorkingLenWrite(zero,0)       = adju(proglen, WORDW);
        WorkingFitnessWrite(zero,0)   = DEFAULT_FITNESS;
	WorkingprogNumWrite(zero,0)   = progNum;
    	i = 0;
	icount = 0;
        populationControl[progNum]= 1;  /* Signal that this should 
		                    			   get written */
	<FONT COLOR="#0040d0">progNum++<FONT COLOR="#202020">;
	}

    <FONT COLOR="#0040d0">do  {
        WorkingPopWrite(zero, 0, i, genNode());
	    PAR {
	        i++;
	        icount++;
	    }
    } while(!BITSET(icount, MAXPROGLEN))<FONT COLOR="#202020">;
#endif
}



/***************************************************************************
 * Name:     writeBackInd
 *
 * Purpose:  Writes an individual back to external SRAM from on-chip
 *           block select ram.
 * 
 * Inputs:   The phase to use (1st index into ram arrays)
 *           The individual number (2nd index into ram arrays )
 *
 * Returns:  Nothing
 * 
 * Note:     The address to write to is calculated by taking the 
 *           individual number and multiplying by the program size.
 *           The instructions are packed into WORDLEN bit words to make memory
 *           access more efficient.
 *           The individual is not written back if it does not have it's
 *           control bit set.
 ***************************************************************************/
<FONT COLOR="#0040d0">void writeBackInd(Phase phase, WorkIndex ind)
{
    MainPopIndex address, addr;
    Index     j,k;
    PopIndex  num;
    Word f,n, word;
    UINT32  val;
    Bool   done, done2;

    num = adju(WorkingprogNumRead(phase,ind), POPW);

    if(!populationControl[num]) {
        delay;
    } else {          
        PAR {
            indexToAddr(num, address);
            j = 0;
            k = 0;
            done = 0;
        }
            SEQ {
                populationControl[num] =0;
		f = WorkingFitnessRead(phase, ind);
		n = WorkingLenRead(phase, ind);
                populationFitness[num] = f;
                populationLen[num] = n;
            }


            do  {
				SEQ {
                	word = WorkingPopGet(phase,ind,j);
                	val  = adju(word,BIT32);
                	addr = address | adju(j, SRAMW);
//					delay;
#if defined HANDELC
                	PP1000WriteBank0func(addr , 0@word);
#else
                	PP1000WriteBank0func(addr , word);
#endif
                	PAR {
                    	done2 = (k == MAXNODES-1);
                    	j++;
                    	k++;
                	}
				}
            } while(!done2);
    }
}<FONT COLOR="#202020">

/***************************************************************************
 * Name:     readIn
 *
 * Purpose:  Reads an individual from external SRAM
 * 
 * Inputs:   i   = The individual number in the main population
 *           ind = The individual in working ram
 *
 * Returns:  Nothing
 * 
 * Note:     The address to write to is calculated by taking the 
 *           individual number and multiplying by the program size
 *           The individual is marked as being in workingPop
 ***************************************************************************/
<FONT COLOR="#0040d0">void readIn(PopIndex i, WorkIndex ind)
{
    MainPopIndex  address;
	MainPopIndex  addr2;
    UINT32        val;
    Index_1       j;
    Word          f,n;
    Phase         ph;
    Bool          done;

    PAR {
        indexToAddr(i, address);
        j = 0;
	    ph = phBreed;
        done = 0;
    }
        SEQ {
            populationControl[i]=1;
            f = populationFitness[i];
            n = populationLen[i];
	        WorkingFitnessWrite(ph, ind) = f;
	        WorkingLenWrite(ph, ind) = n;
	        WorkingprogNumWrite(ph, ind) = adju(i, POPW);
        }

        do {
		    addr2 = address|adju(j,SRAMW);
                PP1000ReadBank0(val, addr2);
                WorkingPopWrite(ph,ind,adju(j, IDXW), adju(val, WORDW));
                PAR {
                    j++;
                    done = (j == MAXNODES-1);
            }
        } while(!done);
}<FONT COLOR="#202020">

/***************************************************************************
 * Name:     initPop
 *
 * Purpose:  Initialise the population
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 * 
 * Note:     Side effect is to construct the programs in external SRAM
 *           The programs are built in the block ram first then copied to the
 *           external SRAM.
 *           The fitness of the built programs is evaluated as part of this
 *           before they are written back so that we start with a full set
 *           of fitness cases
 *           Two of the block select rams are used for the different phases
 *           which ensures that we don't break the rule about reading/writing
 *           to a block select ram more than once per clock cycle.
 ***************************************************************************/
macro proc initPop()
{
  PopIndex_1 <FONT COLOR="#0040d0">idx<FONT COLOR="#202020">;
    
  <FONT COLOR="#0040d0">idx      = 0<FONT COLOR="#202020">;
  
  <FONT COLOR="#0040d0">do {
      makeProg();
      PAR {
	    writeBackInd(0, 0);
        idx++;
      }
  } while(!BITSET(idx, POPSIZE))<FONT COLOR="#202020">;
}

/***************************************************************************
 * Name:     writeBack
 *
 * Purpose:  Writes all individuals in working ram pointed to by phWriteback
 *           out to external RAM, and clears the inwork bit for all
 *           individuals still in workingPop.
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 * 
 ***************************************************************************/
macro proc writeBack()
{
    WorkIndex <FONT COLOR="#0040d0">w<FONT COLOR="#202020">;
    
    <FONT COLOR="#0040d0">w = 0<FONT COLOR="#202020">;
    <FONT COLOR="#0040d0">do {
        writeBackInd(phWriteback, w);
        w++;
    } while(LIMIT(w,MAXPAR))<FONT COLOR="#202020">;
}


#if !defined HANDELC
/*************************************************************************** 
 * iso-c stubs for PP1000 and macro expression/procs
 **************************************************************************/
char * stoi(int v)
{
  static char b[10];
  sprintf(b, "%d", v);
  return b;
}

Word sram[4][POPSIZE*MAXNODES]; /* 4 banks */
Word READRAM(unsigned bank, unsigned long addr)
{
  return sram[bank][addr];
}

void WRITERAM(unsigned bank, unsigned addr, unsigned val)
{
  sram[bank][addr] = val;
}

/*
 * Random number routines for a regular ANSI-C system
 */
FILE *randlog;

RandReg randReg;    /* The register used for generating the number */
RandReg   s_random_lfsr(void)
{
 unsigned int BITW bit0;
 RandReg  t1, t2, t3, t4, t5, t6;
 t1 = !!(randReg & (1LL<<TAP1));
 t2 = !!(randReg & (1LL<<TAP2));
 t3 = !!(randReg & (1LL<<TAP3));
 t4 = !!(randReg & (1LL<<TAP4));
 t5 = !!(randReg & (1LL<<TAP5));
 t6 = !!(randReg & (1LL<<TAP6));
 bit0 = t1^t2^t3^t4^t5^t6;
 randReg <<= 1;
 randReg |= bit0;
 nrand++;
 return randReg;
}

#ifdef LFSR_16
RandReg s_random(void)
{
  int i;

  for(i=0;i<15;i++) {
    s_random_lfsr();
  }
  return s_random_lfsr();
}
#elif defined CA_16
typedef  unsigned long Rbits;

#define  BMAX ((sizeof(Rbits)*8)-1)
#define  BIT_P1(b) (b==BMAX?0:(b+1))
#define  BIT_M1(b) (b==0?BMAX:(b-1))
#define  BIT(v,n)  (!!(v&(1<<n)))
#define  SBIT(v,n,b) (b ? (v|=(1<<n)):(v&=(~(1<<n))))
#define CABIT(ca,bit) ((BIT(ca,BIT_P1(bit))|BIT(ca,bit))^BIT(ca,BIT_M1(bit)))

RandReg s_random(void)
{
  static Rbits v1 = 0x8000;
  Rbits  v2;
  Rbits  r;
  int i;


  v2 = 0;

  for(i=0;i<=BMAX;i++) {
    int m;
    int e,w,x;
    e=BIT(v1,BIT_M1(i));
    w=BIT(v1,BIT_P1(i));
    x=BIT(v1,i);
    m = CABIT(v1,i);
    SBIT(v2,i,CABIT(v1,i));
  }
  r=v1;
  v1=v2;
  return r;
}
#elif defined CONGRNG
RandReg s_random()
{
  return rand();
}
#elif defined SEQRNG
RandReg s_random()
{
  return randReg++;
}
#elif defined SPARSE
RandReg s_random()
{
  static r = 2;
  r+=2;
  return r & 0xfffffff0;
}
#elif defined TRUERAND
RandReg s_random()
{
  static int fd = -1;
  unsigned long v;

  if(fd==-1) {
    fd = open("10megs-random.1", O_RDONLY);
    if(fd == -1) {
      perror("Opening random number file");
      exit(1);
    }
    lseek(fd, randReg%1000000, SEEK_SET);
  }
  read(fd, &v, sizeof v);
  return v;
}
#else
RandReg s_random()
{
  return s_random_lfsr();
}
#endif
void RandomGen(void)
{
}

void CycleCount(void)
{
}

void randseed(void)
{
#if !defined PSIM
	FILE *fp;
	time_t t;
	struct timeval tv;
	struct timezone tz;

	gettimeofday(&tv, &tz);
	t = time(NULL);
	t = tv.tv_usec + tv.tv_sec;
	if(newseed) {
		fp=fopen(RANDFILE, "w");
		if(fp) {
		  fprintf(fp, "%lu", t);
		  randReg = t;
		} else {
		  randReg=t;
		}
	} else {
		fp=fopen(RANDFILE, "r");
		if(fp) {
		  fscanf(fp, "%d", &randReg); 
		} else {
		  randReg = time(NULL);
		}
	}
	if(fp) fclose(fp);
	if(verbose && !tree) {
	  printf("SEED=%d\n", randReg);	
	}
	randlog=fopen(RANDLOG, "w");
	srand(randReg);
#else
	randReg = 260158;
#endif
}

PC randPC()
{
  return s_random() % MAXPROGLEN;
}

/* Return a non-zero program length */
PC randLen()
{
  PC r = 0;
  do {
    r = randPC();
  }while(r==0);
  return r;
}

void randMethod(Method *method)
{
  static const UINT8 mask1 = 0x1f;
  static const UINT8 mask2 = 0xfc;
  UINT8 mask3;
  UINT8 mask4;
  UINT8 v, v1, v2, v3, v4;

  PAR {
    v = s_random() & 0xff;
    mask3 = ~mask1;
    mask4 = ~mask2;
  }

  PAR {
    v1 = v&mask1;
    v2 = v&mask2;
    v3 = v&mask3;
    v4 = v&mask4;
  }
  if(!v3&&v1)
    *method = MUTATE;
  else if(!v4&&v2)
    *method = COPY;
  else
    *method = XOVER;
}

PopIndex randPopIndex()
{
  return s_random() % POPSIZE;
}

/***************************************************************************
 * Name:     decodeTerm
 *
 * Purpose:  Print a term for the ant problem
 * 
 * Inputs:   The term number
 *
 * Returns:  a pointer to static data describing the term 
 *
 ***************************************************************************/
#if !defined HANDELC
char * decodeTerm(int t)
{
  static char * termTab[] = {
    "Left", 
    "Right",
    "Move", 
    "Nop",
  };

  if(t<0 || t>3)
    return "Unknown";
  else
    return termTab[t];
}
#endif

void dooutdata(int v1, int v2)
{
  char * vs1 = "";
  char * vs2 = "";
  static  char buf[100];

  switch(v1) {
  case LEN:
    vs1 = "Length";
    vs2 = stoi(v2);
    break;
  case GEN:
    vs1 = "Generation";
    vs2 = stoi(v2);
    break;
  case IND:
    vs1 = "Individual";
    vs2 = stoi(v2);
    break;
#if XOR
  case FUNC:
    vs2 = "";
    switch(v2) {
    case AND:
      vs2="AND";
      break;
    case OR:
      vs2="OR";
      break;
    case NAND:
      vs2="NAND";
      break;
    case NOR:
      vs2="NOR";
      break;
    default:
      sprintf(buf, "Unkown Opcode");
      break;
    }
    vs1 = "FUNC";
    break;
 case EA1:
   vs1 = "Ea1";
   vs2 = stoi(v2);
   break;
 case EA2:
   vs1 = "Ea2";
   vs2 = stoi(v2);
   break;
 case K:
   vs1 = "K";
   vs2 = stoi(v2);
   break;
#endif
#if BOOLPARITY
  case FUNC:
    vs2 = "";
    switch(v2) {
    case AND:
      vs2="AND";
      break;
    case OR:
      vs2="OR";
      break;
    case NOR:
      vs2="NOR";
      break;
    case NAND:
      vs2="NAND";
      break;
    default:
      sprintf(buf, "Unkown Opcode");
      break;
    }
    vs1 = "FUNC";
    break;
 case EA1:
   vs1 = "R";
   vs2 = stoi(v2);
   break;
 case EA2:
   vs1 = "R";
   vs2 = stoi(v2);
   break;
#endif
#if ANT
  case FUNC:
    vs2 = "";
    switch(v2) {
    case IF_FOOD:
      vs2 = "IF_FOOD";
      break;
    case PROGN2:
      vs2 = "PROGN";
      break;
    default:
      sprintf(buf, "Unknown opcode %d\n", v2);
      vs2=buf;
      vs1="Func";
    }
    break;
 case EA1:
   vs1 = "";
   vs2 = decodeTerm(v2);
   break;
 case EA2:
   vs1 = "";
   vs2 = decodeTerm(v2);
   break;
#endif
 case FIT:
   vs1 = "Fitness";
   vs2 = stoi(v2);
   break;
  case INIT:
    vs1 = "InitPop";
    vs2 = stoi(v2);
    break;
  case NMUTATE:
    vs1="Mutate";
    vs2=stoi(v2);
    break;
  case NXOVER:
    vs1="Crossover";
    vs2=stoi(v2);
    break;
  case NCOPY:
    vs1="Copy";
    vs2=stoi(v2);
    break;
 default:
   sprintf(buf,"Unknown op (%d)", v1);
   vs1 = buf;
   vs2 = stoi(v2);
   break;
  }
  printf("%s %s ",vs1, vs2);
}

void     WorkingPopWrite(unsigned int a, unsigned int b, unsigned int c, unsigned int v)
{
  workingPop[a*b][c]=v;
}

void     WorkingPopRead(unsigned int a, unsigned int b, unsigned int c, unsigned int *  v)
{
  *v = workingPop[a*b][c];
}

Word     WorkingPopGet(unsigned int a, unsigned int b, unsigned int c)
{
  return workingPop[a*b][c];
}
 
#endif

/*************************************************************************
 * fitness functions
 ************************************************************************/
#if defined XOR
/***************************************************************************
 * Name:     evalProg
 *
 * Purpose:  Runs a program for an individual
 * 
 * Inputs:   The phase index
 *           the population index (individual)
 *
 ***************************************************************************/
macro proc evalProg(C_UINT indx_in)
{
  Index       pc;   /* Index into words of instructions */
  Index_1     counter;
  Register    ea1, ea2,r;
  Bool        regs[MAXREGS]; 
  Register    i;
  Opcode      opcode;
  Bool        res;
  Word        fit;
  Bool        done;
  Word        word;
  WorkIndex   indx;
  Fcase       curFit;
  Bool        done;
  Phase       ph;



/*
* Per-run initialisation
*/

  WorkingFitnessWrite(phEval,indx) = DEFAULT_FITNESS;
  curFit = 0;

    do {
  /*
   * Per-fitness case initialisation.
   * All done in 1 cycle for Handelc
   * a) Zero the register set
   * b) copy the input parameters
   * c) Set up control variables
   */
  PAR {
    i=0;
    FORPAR (r=2; r < MAXREGS; r++ ) {
      regs[r] = 0;
    }
    regs[0] = BIT0(curFit);
    regs[1] = BIT1(curFit);
    res     = BIT0(curFit) ^ BIT1(curFit);
    pc      = 1;
    counter = MAXNODES - adju(WorkingLenRead(phEval,indx),IDXW_1);
    fit     = WorkingFitnessRead(phEval,indx);
    done    = 0;
    word    = WorkingPopGet(phEval, indx, 0);
    indx    = indx_in;
  }

    do {
      /* Decode the instruction and maintain the counters */
      PAR {
        counter++;
	    ea1 = GetEa1(word);
	    ea2 = GetEa2(word);
	    opcode = GetOpcode(word);
        word = WorkingPopGet(phEval, indx, pc);
        pc++;
        done = (counter == MAXNODES-1);
      }
  
      switch(opcode) {
      case AND:
	    regs[ea1] &= (regs[ea2]);
	    break;
      case OR:
	    regs[ea1] |= regs[ea2];
	    break;
      case NAND:
	    regs[ea1]  = !(regs[ea1] & regs[ea2]);
	    break;
      case NOR:
	    regs[ea1] = !(regs[ea1] | regs[ea2]);
	    break;
      }  /* switch */
    } while(!done);
    /*
     * Calculate the new raw fitness
     */
    if(regs[r0] == res ) {
      fit--;
      WorkingFitnessWrite(phEval,indx) = fit;
    } else {
      delay;
    }

    PAR {
        done = (curFit == MAXFITNESS-1);
        curFit++;
    }
    } while(!done);
}
#endif


#if defined ANT
/***************************************************************************
 * Name:     evalProg
 *
 * Purpose:  Runs a program for an individual
 * 
 * Inputs:   The population index (individual)
 *
 * Returns:  Nothing
 * 
 ***************************************************************************/
macro proc evalProg(C_UINT indx)
{
  Index       <FONT COLOR="#0040d0">pc<FONT COLOR="#202020">;
  Index       <FONT COLOR="#0040d0">len<FONT COLOR="#202020">;
  Index_1     <FONT COLOR="#0040d0">counter<FONT COLOR="#202020">;
  Opcode      <FONT COLOR="#0040d0">opcode<FONT COLOR="#202020">;
  Direction   <FONT COLOR="#0040d0">dir<FONT COLOR="#202020">;
  Pos         <FONT COLOR="#0040d0">x<FONT COLOR="#202020">;
  Pos         <FONT COLOR="#0040d0">y<FONT COLOR="#202020">;
  Pos         <FONT COLOR="#0040d0">ax<FONT COLOR="#202020">, <FONT COLOR="#0040d0">ay<FONT COLOR="#202020">;
  Food        <FONT COLOR="#0040d0">food<FONT COLOR="#202020">;
  Food        <FONT COLOR="#0040d0">uneaten<FONT COLOR="#202020">;
  Time        <FONT COLOR="#0040d0">timeval<FONT COLOR="#202020">;
  Register    <FONT COLOR="#0040d0">ea1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">ea2<FONT COLOR="#202020">;
  Register    <FONT COLOR="#0040d0">eas[2]<FONT COLOR="#202020">;
  Bool        <FONT COLOR="#0040d0">flags[2]<FONT COLOR="#202020">;
  Bool        <FONT COLOR="#0040d0">e<FONT COLOR="#202020">;
  Bool        <FONT COLOR="#0040d0">foodHere<FONT COLOR="#202020">;
  Bool        <FONT COLOR="#0040d0">timeleft<FONT COLOR="#202020">;
  Bool        <FONT COLOR="#0040d0">foodleft<FONT COLOR="#202020">;
  Word        <FONT COLOR="#0040d0">word<FONT COLOR="#202020">;
  Phase       <FONT COLOR="#0040d0">ph<FONT COLOR="#202020">;


  /*
   * Per run initialisation
   */
  initMap(indx);

  /*
   * Initialisation.
   * All done in 1 cycle for Handelc
   * a) Zero the register set
   * b) copy the input parameters
   * c) Set up control variables
   */
  PAR {
    ph        = phEval;
    food      = MAXFOOD - FOOD;     /* Start all food to collect */
    uneaten   = FOOD;
    dir       = EAST;        /* Pointing to the right */
    x         = 0;           /* At the first cell */
    y         = 0;
    timeval   = 0;
    pc        = 0;
    <FONT COLOR="#0040d0">len       = adju(WorkingLenRead(phEval,indx),IDXW)<FONT COLOR="#202020">;
  }
  <FONT COLOR="#0040d0">do {
      /* Get the 1st word and set up counter. pc is set to 1 for the next get */
      PAR {
        counter = MAXNODES - adju(len, IDXW+1);
	pc = 1;
        word = WorkingPopGet(ph,indx,0);
      }
    do {
      /* Decode the instruction */
      PAR {
	ea1 = GetEa1(word);
	ea2 = GetEa2(word);
	opcode = GetOpcode(word);
	ax=x;
	ay=y;
	word = WorkingPopGet(ph,indx,pc);
	pc++;
	counter++;
      }
	
      switch(opcode) {
      case IF_FOOD:
	switch(dir) {
	case EAST:  ax++; break;
	case WEST:  ax--; break;
	case NORTH: ay--; break;
	case SOUTH: ay++; break;
	default: delay;   break;
	} /* Switch  dir */
	/* Now check the cell 'ahead' */
	if(MAP(map, indx, adju((ax&31), 6), ay&31)) {
	  PAR {
	    eas[0] = ea1;
	    flags[0]=1;
	    flags[1]=0;
	  }
	} else {
	  PAR {
	    eas[0] = ea2;
	    flags[0]=1;
	    flags[1]=0;
	  }
	}
	break;  /*if_food */
      case PROGN2:
	PAR {
	  eas[0]=ea1;
	  eas[1]=ea2;
	  flags[0]=1;
	  flags[1]=1;
	}
	break;
      }  /* switch */
      /* Now execute the DOTERM proc as many times as needed */
      e = 0;
      do {
	if(flags[e]) {
	  PAR {
	    timeval = (timeval==MAXTIME) ? timeval : timeval+1;  
	    switch(eas[e]) {
	    case LEFT:
	      dir = (dir-1) & 3; break;
	    case RIGHT:                      
	      dir = (dir+1) & 3; break;
	    case MOVE:                              
	      switch(dir) {                   
	      case EAST:  x++; break;
	      case WEST:  x--; break;
	      case SOUTH: y++; break;
	      case NORTH: y--; break;
	      default: delay;  break;
	      }   
#if !defined HANDELC                                      
	      PAR {                           
		y &= GRIDMASK;            
		x &= GRIDMASK;            
	      }  
#endif
	      foodHere = MAP(map, indx, adju(x,6),y);
	      if(foodHere && !BITSET(food, MAXFOOD)) {  
		PAR {
		  food++; 
		  uneaten--;
		  CLRBIT(map, indx, adju(x,6), y);               
		}
	      } 
	      break;
	    default: delay; break;
	    } /* switch eas */  
	  } /* PAR */                                
	} else {
	  delay;
	}
	TOGGLE(e);
      }while(e);
    } while(!BITSET(counter, MAXNODES));
    PAR {
      foodleft  = !(food==MAXFOOD);
      timeleft  = !(timeval==MAXTIME);
    }
  } while(timeleft && foodleft)<FONT COLOR="#202020">;
  /*
   * Calculate the new raw fitness
   */

  <FONT COLOR="#0040d0">WorkingFitnessWrite(ph, indx) = uneaten<FONT COLOR="#202020">;
#if !defined HANDELC
  if(dumpProg && uneaten == 0) {
      int i;
      printf("100%% prognum %d\n", workingprogNum[phEval][indx]);
      printf("--------------------------\n");
      printf("len=%d\n", len);
      for(i=0;i<len;i++) {
       WorkingPopRead(phEval, indx, i, C_ADDR word);
       printf("%d %d %d\n", GetOpcode(word), GetEa1(word), GetEa2(word));
      }
      printf("--------------------------\n");
  }
#endif
}
#endif  /* ANT */


#if defined BOOL11MUX
/***************************************************************************
 * Name:     evalProg
 *
 * Purpose:  Runs a program for an individual
 * 
 * Inputs:   The phase index
 *           the population index (individual)
 *
 * Returns:  1 if we found 100% fit program
 *           0 otherwise
 * 
 ***************************************************************************/
macro proc evalProg(C_UINT indx)
{
  Index       pc;   /* Index into words of instructions */
  Index       len;
  Index_1     counter;
  Register    ea1, ea2,r;
  Bool        regs[MAXREGS]; 
  Register    i;
  Opcode      opcode;
  Word        word;
  Bool        res;
  Word        fit;
  unsigned int curFit;
  unsigned r2;

  fit = DEFAULT_FITNESS;
  curFit = 0;
  do {
    /*
     * Initialisation.
     * All done in 1 cycle for Handel-C
     * a) Zero the register set
     * b) copy the input parameters
     * c) Set up control variables
     */
    PAR {
      i=0;
      FORPAR (r=13; r < MAXREGS; r++ ) {
	regs[r] = 0;
      }
      FORPAR(r2=1; r2 < 13; r2++ ) {
	regs[r2] = !!(curFit & (1<<r2));
      }
      regs[0]=0;
      res = !!((curFit>>3) & (1<<(curFit & 7)));
	       //      res     = !!(curFit[10:3]&(1<<curFit[2:0]));
      /*      printf("Cur = 0x%x data = 0x%x Address = 0x%x result = 0x%x\n", curFit, 
	      curFit>>3, curFit & 7, res);*/
      pc      = 0;
      counter = MAXNODES - adju(WorkingLenRead(phEval,indx),IDXW_1);

    }

    do {
      /* Decode the instruction and maintain the counters */
      PAR {
        counter++;
	ea1 = GetEa1(WorkingPopGet(phEval,indx,pc));
	ea2 = GetEa2(WorkingPopGet(phEval,indx,pc));
	opcode = GetOpcode(WorkingPopGet(phEval,indx,pc));
        pc++;
      }
  
      switch(opcode) {
      case AND:
	regs[ea1] &= (regs[ea2]);
	break;
      case OR:
	regs[ea1] |= regs[ea2];
	break;
      case NOT:
       	regs[ea1]   = !(regs[ea1]);
	break;
      case IF:
	if(regs[ea1]) {
	  PAR {
	    pc++;
	    counter++;
	  }
	}else{ 
	  delay;
	}
	break;
      }  /* switch */
    } while(!BITSET(counter, MAXNODES));
    /*
     * Calculate the new raw fitness
     */
    if(regs[r0] == res ) {
      fit--;
    } else {
      delay;
    }
    curFit++;
  } while(curFit != MAXFITNESS);
  WorkingFitnessWrite(phEval,indx) = fit;
}
#endif

#if defined BOOLPARITY
/***************************************************************************
 * Name:     evalProg
 *
 * Purpose:  Runs a program for an individual
 * 
 * Inputs:   The phase index
 *           the population index (individual)
 *
 * Returns:  1 if we found 100% fit program
 *           0 otherwise
 * 
 ***************************************************************************/
macro proc evalProg(C_UINT indx)
{
  Index       pc;   /* Index into words of instructions */
  Index_1     counter;
  Register    ea1, ea2,r;
  Bool        regs[MAXREGS]; 
  Register    i;
  Opcode      opcode;
  Bool        res;
  Bool        done;
  Bool		  doneFit;
  Word        fit;
  Word curFit;
  Word tmpFit;
  unsigned r2;
  Word bits;
  Word  b;
  Phase       ph;

  PAR {
  	fit = DEFAULT_FITNESS;
  	ph  = phEval;
  	curFit = 0;
  }
  do {
    /*
     * Initialisation.
     * All done in 1 cycle for Handel-C
     * a) Zero the register set
     * b) copy the input parameters
     * c) Set up control variables
     */
    PAR {
      i=0;
      FORPAR (r=PARITYBITS; r < MAXREGS; r++ ) {
	regs[r] = 0;
      }
      FORPAR(r2=0; r2 < PARITYBITS; r2++ ) {
	regs[r2] = !!(curFit & (1<<r2));
      }
#if 0
      for(i=0;i<MAXREGS;i++) {
	printf("curFit = 0x%x, reg %d = %d\n", curFit, i, regs[i]);
      }
#endif
      bits = 0;
      tmpFit = curFit;
      b=0;
      pc      = 0;
      counter = MAXNODES - adju(WorkingLenRead(ph,indx),IDXW_1);
    }  /* PAR */
 

/* Do the calculation of the parity in parallel with the fitness eval */
   PAR {

    do {
        if(tmpFit & 0x1) {
            bits++;
        } else {
            delay;
        } 
        PAR {
            tmpFit >>= 1;
            done = (b==PARITYBITS-1);
            b++;
#if defined HANDELC
            res = bits[0];
#else
			res = bits & 1;
#endif
      }
    }while(!done);
 


    do {
      /* Decode the instruction and maintain the counters */
      /*PAR*/ {
        counter++;
	ea1 = GetEa1(WorkingPopGet(ph,indx,pc));
	ea2 = GetEa2(WorkingPopGet(ph,indx,pc));
	opcode = GetOpcode(WorkingPopGet(ph,indx,pc));
	//		printf("PC %d: I=0x%x, op = 0x%x, ea1 = 0x%x, ea2 = 0x%x\n", pc, WorkingPopGet(ph,indx,pc), opcode, ea1, ea2);
        pc++;
      }
  
      switch(opcode) {
      case AND:
	regs[ea1] &= (regs[ea2]);
	break;
      case OR:
	regs[ea1] |= regs[ea2];
	break;
      case NAND:
	regs[ea1]  = !regs[ea2];
	break;
      case NOR:
	regs[ea1] = (regs[ea1] ^ regs[ea2]);
	break;
      }  /* switch */
    } while(!BITSET(counter, MAXNODES));
    /*
     * Calculate the new raw fitness
     */
   } /* PAR */
  if(regs[r0] == res ) {
    fit--;
  } else {
    delay;
  }
  curFit++;
  doneFit = (curFit == MAXFITNESS);
 } while(!doneFit);

  WorkingFitnessWrite(ph,indx) = fit;
}
#endif

#if defined PSIM
int _start()
{
  static char *argv[] = {"lgpc",NULL};
  return main(1, argv);
}
 
int printf(const char * fmt, ...)
{
  return 0;
}
 
int fprintf(FILE *f, const char * fmt, ...)
{
  return 0;
}
 
int sprintf(char *s, const char * fmt, ...)
{
  return 0;
}
 
int rand(void)
{
  int v;
  return v++;
}                        
#endif
#else

ram unsigned int 32 array[32];
void main(void)
{
    unsigned int 5 count;
    unsigned int 16 loop;
    count = 0;
    loop  = 0;
    PP1000RequestMemoryBank(1);
  
  /* Initialise */
    do {
        array[count]=adju(count,32);
        PP1000WriteBank0func(adju(count,21), array[count]);
        count++;
    } while(count);

    do {
    /* Modify */
    count = 0;
    do{ 
        unsigned int 32 val;
        PP1000ReadBank0(val, adju(count,21));
        array[count] = val;
        val <<= 1;
        array[count] = val;
        PP1000WriteBank0func(adju(count,21),array[count]);
        count++;
    } while(count);
    loop++;
    } while(loop);
    PP1000ReleaseMemoryBank(1);
    PP1000WriteStatus(1);
}
#endif


ÿ<FONT COLOR="#000000"><H3>
C:\USER\PETES\PhD\hwgpperf\hwgph.h
</H3>
<FONT COLOR="#202020">#ifndef LGPC_H
#define LGPC_H

#define VERSION "1.0"

typedef enum {PXOR, PANT, PBOOLEANPARITY} problemType ;
/*
 * Problem specific values
 */
#if defined XOR
#warning doing the XOR problem
#define PROBLEMTYPE PXOR
#define GENERATIONS    (64)                
#define POPSIZE    (64)
#define MAXPROGLEN (16)
#define MAXFITNESS (4) 
#define MAXFUNCS   (4)
#define MAXREGS    (4)
#define MAXFITW    4
/**************************************************************************
 * Function set members
 * This must match MAXFUNCS
 ***************************************************************************/
typedef enum {
  AND, OR, NAND, NOR
} FuncTypeE;

/***************************************************************************
 * Registers (terminal set) for the processor
 * Must match MAXREGS
 ***************************************************************************/
typedef enum {
  r0,r1,r2,r3
} RegisterE;

#define DEFAULT_FITNESS 4

/*
 * The layout of an 'instruction'
 */
#define EA2BITS 1:0
#define EA1BITS 3:2
#define OPCODEBITS 5:4
#define GetOpcode(val) (((val&0x30)>>4)&(MAXFUNCS-1))
#define GetEa1(val)    ((val&0x0c)>>2)
#define GetEa2(val)    ((val&3))
#define genNode() rand() & 0xff


#elif defined BOOLPARITY
/*************************************************************************
 * B O O L E A N   P A R I T Y 
 *************************************************************************/
#warning Doing boolean parity

#define PROBLEMTYPE PBOOLEANPARITY
#if !defined GENERATIONS
#define GENERATIONS    (64)                
#endif
#if !defined POPSIZE
#define POPSIZE    (1024)
#endif
#if !defined MAXPROGLEN
#define MAXPROGLEN (64)
#endif
#if !defined PARITYBITS
#define PARITYBITS 6
#endif
#define MAXFITNESS (1<<PARITYBITS)
#define FUNCBITS   2                 /* Number of bits for a function */
#define MAXFUNCS   (1<<FUNCBITS)
#define FUNCMASK   (MAXFUNCS-1)
#if !defined REGBITS
#define REGBITS    4               /* Number of bits for the registers */
#endif
#define MAXREGS    (1<<REGBITS)
#define REGMASK    (MAXREGS-1)
#define MAXFITW    12
#define DEFAULT_FITNESS MAXFITNESS
/**************************************************************************
 * Function set members
 * This must match MAXFUNCS
 ***************************************************************************/
typedef enum {
  AND, OR, NAND, NOR
} FuncTypeE;

/***************************************************************************
 * Registers (terminal set) for the processor
 * Must match MAXREGS
 ***************************************************************************/
typedef enum {
  r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15
} RegisterE;

#if !defined HANDELC
#define GetOpcode(val) (((val&(FUNCMASK << (REGBITS+REGBITS)))>>(REGBITS+REGBITS))&(MAXFUNCS-1))
#define GetEa1(val)    ((val&(REGMASK << REGBITS))>>REGBITS)
#define GetEa2(val)    (val&REGMASK)
#define genNode() (rand() &  ((FUNCMASK << (REGBITS+REGBITS)) | (REGMASK << REGBITS) | REGMASK))
#else
#define EA1BITS        REGBITS-1:0   
#define EA2BITS        REGBITS+REGBITS-1:REGBITS
#define OPCODEBITS     REGBITS+REGBITS+FUNCBITS-1:REGBITS+REGBITS
#define NODEBITS       REGBITS+REGBITS+FUNCBITS-1:0
#endif

#elif defined BOOL11MUX
/*************************************************************************
 * B O O L E A N   11 M U L T I P L E X E R
 *************************************************************************/
#warning Doing boolean multiplexer

#define PROBLEMTYPE PBOOLEANPARITY
#define GENERATIONS    (1024)                
#define POPSIZE    (128)
#define MAXPROGLEN (32)
#define MAXFITNESS (2048)
#define MAXFUNCS   (4)
#define MAXREGS    (16)
#define MAXFITW    12
#define DEFAULT_FITNESS MAXFITNESS
/**************************************************************************
 * Function set members
 * This must match MAXFUNCS
 ***************************************************************************/
typedef enum {
  AND, OR, NOT, IF
} FuncTypeE;

/***************************************************************************
 * Registers (terminal set) for the processor
 * Must match MAXREGS
 ***************************************************************************/
typedef enum {
  r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15
} RegisterE;

#define GetOpcode(val) (((val&0x300)>>8)&(MAXFUNCS-1))
#define GetEa1(val)    ((val&0xf0)>>4)
#define GetEa2(val)    ((val&0xf))
#define genNode() rand() & 0x3ff

#elif defined ANT
/**************************************************************************
 * ANT 
 ***************************************************************************/
#warning doing the ANT problem
#define PROBLEMTYPE PANT
#define GENERATIONS  (32)     /* Number of generation equivalents */
#define POPSIZE      (1024)
#if !defined MAXPROGLEN
#define MAXPROGLEN   (32)
#endif
#define MAXFITNESS   (1)
#define GRIDX        (32)
#define GRIDY        (32)   
#define MAXFUNCS     (2)
#define MAXREGS      (4)
#define FOOD         (89)
#define MAXFOOD      (128)
#define MAXTIME      (750)
#define MAXDIRECTION (4)
#define MAXFITW    7

typedef enum {
  IF_FOOD, PROGN2
} FuncTypeE;
typedef enum {
    t1,t2
} RegisterE;

#define DEFAULT_FITNESS FOOD

#if defined HANDELC
#define FOODW      (log2ceil(MAXFOOD)+1)
#define TIMEW      (log2ceil(MAXTIME)+1)
#define DIRW       (log2ceil(MAXDIRECTION))
#define POSW       (log2ceil(GRIDX))
#else
#define FOODW
#define TIMEW
#define DIRW
#define POSW
#endif

#define GRIDMASK   (GRIDX-1)

typedef unsigned int FOODW    Food;
typedef unsigned int TIMEW    Time;
typedef unsigned int DIRW     Direction;
typedef unsigned int POSW     Pos;
/*
 * Direction values. Arranged so that incrementing turns right,
 * and decrementing turns left
 */
#define EAST  0
#define SOUTH 1
#define WEST  2
#define NORTH 3	

/*
 * Terminals 
 */
#define LEFT  0
#define RIGHT 1
#define MOVE  2
#define NOP   3

/*
 * The layout of an 'instruction'
 */
#define EA2BITS 1:0
#define EA1BITS 3:2
#define OPCODEBITS 4

#if !defined HANDELC
#define GetOpcode(val) (((val&0x30)>>4)&(MAXFUNCS-1))
#define GetEa1(val)    ((val&0x0c)>>2)
#define GetEa2(val)    ((val&3))
#define genNode() rand() & 0xff
#endif

#else
#error Must specify problem type of XOR, ANT
#endif /* ANT */

/**************************************************************************
 * The rest of the general definitions
 **************************************************************************/

#define GENSIZE      (GENERATIONS * (POPSIZE/(MAXPAR)))

#define MAXNODES   (MAXPROGLEN)       /* Maximum words per individual
											including the control words at the start
                                           In the Virtex device being used
                                           the Block Select Rams are 4096 bits
                                           deep. To ensure that each individual
                                           is in it's own ram so that we can
                                           use parallel evaluations, the depth
                                           of each individual should be maximal
                                           ie:128 words, even if this is not the
                                           maximum program length! */

#define MAXPHASE   (2)           /* Two phases in the pipeline  */
#ifndef MAXPAR
#define MAXPAR     (2)           /* Number of individuals being evaluated
				  * in parallel. Must be at least 2 because
				  * this is also used to dimension workingPop
				  * which needs at least 2 individuals to do
				  * breeding with */
#endif
#define MAXINITLEN (MAXPROGLEN)       /* Max length for creation      */
#define MAXMETHODS (4)
#define WORDLEN    (16)               /* Size of RAM storage */

/*****************************************************************
 * Handle-c specific defines
 *****************************************************************/
#ifdef HANDELC
/* Define the widths of the various values */
#define FTW       		(log2ceil(MAXFUNCS))        		/* Bits needed for function     */
#define NTW       		(log2ceil(MAXNODETYPES))  	/* Bits to represent node types */
#define IDXW      		(log2ceil(MAXNODES))        	/* Width of index into nodes (words)   */
#define IDXW_1          (IDXW+1)
#define PROGW           (log2ceil(MAXPROGLEN))          /* Width of program counter */
#define PROGW_1         (PROGW+1)
#define GENW      		(log2ceil(GENSIZE))         		/* Width if generation index    */
#define GENW_1          (GENW+1)
#define POPW      		(log2ceil(POPSIZE))         		/* Width of population index    */
#define POPW_1          (POPW+1)
#define REGW      		(log2ceil(MAXREGS))
#define FUNCW     		(log2ceil(MAXFUNCS))
#define MTHW      		(log2ceil(MAXMETHODS))
#define FCASEW    	    (log2ceil(MAXFITNESS))
#define FCASEW_1        (FCASEW+1)
#define SHORTW    	    8
#define BITW      		1
#define PHASEW    	    1
#define WORKW     	    (log2ceil(MAXPAR))
#define WORKW_1         (WORKW+1)
#define VW        		1
#define SRAMW           21
#define BIT8             8
#define BIT16           16
#define BIT32           32
#define PCNW             2
#define RAM             ram
#define STARTW      (log2ceil(START))
#define WORDW       (WORDLEN)
#define CTRLW            2

#define BOOLW     		1
#define RANDWIDTH 32
#define MAINTYPE  	void
#define MAINARGS  	(void)
#define MAINRET
#define RETVAL
#define FORPAR     	par
#define PAR         par
#define PARX        
#define SEQ         seq
#define INLINE	  	inline
#define take      	<-
#define outstr(x)
#define outdata(x,y) 	dooutdata(x,(Short)adju(y,SHORTW))

/* Define some control bits */
#define INWORK (0)   /* Indicates individual is in workingPop */
#define MOD4(v) 
#if defined XC4000
#define WITHBLOCK
#else
#define WITHBLOCK with {block=1}
#define WITHBLOCK4  with {block=1,rclkpos = {1.0},wclkpos = {3.5},clkpulselen = 0.5,westart = 3.0,welength = 1.0}  
#endif
#define TOGGLE(x)  x=!x
#define WAIT(x)    while(!x) delay

/* Define the types for iso-c that allow macros to be compiled */
#define C_UINT
#define C_UPTR
#define C_PTR
#define C_ADDR
#define C_U8PTR

/* Define some bit macros */
#define BIT0(x) x[0]
#define BIT1(x) x[1]

#else /* HANDELC */

/* Non-Handlec definitions to make this compile as normal ANSI-C */
#define FTW
#define NTW
#define AW
#define VW   
#define IDXW
#define IDXW_1
#define PROGW
#define PROGW_1
#define LENW
#define GENW
#define GENW_1
#define POPW
#define POPW_1
#define INDW 
#define REGW
#define MDW
#define LOOPW
#define MTHW
#define PCNW
#define BITW
#define FCASEW
#define FCASEW_1
#define SPOPW
#define WORKW
#define WORKW_1
#define PHASEW
#define SRAMW
#define BIT8
#define BIT16
#define BIT32
#define WORDW
#define FUNCW
#define CTRLW
#define RANDWIDTH

#define MAINTYPE  int
#define MAINARGS  (int argc, char ** argv)
#define MAINRET   return 0
#define FORPAR    for
#define PAR     
#define PARX     
#define SEQ
#define mpram union
#define signal
#define BOOLW
#define SHORTW
#define delay     ;  
#define INLINE
#define adju(a,b) a
#define adjs(a,b) a
#define width(v)
#define take
#define RAM
#define WITHBLOCK
#define TOGGLE(x) (x = (x+1) & 0x1)
#define WAIT(x)
#define outstr(x) dooutstr(x)
#define outdata(x,y) dooutdata(x,y)
#define macro  
#define proc void

/* defines to allow macros to be compiled as thoughthey were C */
#define C_UINT unsigned int
#define C_UPTR unsigned int *
#define C_U8PTR UINT8 *
#define C_ADDR &
#define C_PTR  *
#define IncrIdx1(x) (x++)

/* Working pop prototypes */

#endif  /* HANDELC */

/* Layout of the individual */
#define PROGN  (0)
#define FITN   (1)
#define PLEN   (2)
#define CONTRL (3)

/* Define the layout of the control parameters in SRAM
 * These are set up by the host before the run starts */
#define R_SEED  0  /* Random number seed */
#define R_GEN   1  /* Maximum number of generations to run for */

/* *************************************************************
 * Breeding ratios 
 ***************************************************************/
typedef enum {
  COPY, XOVER, MUTATE 
} ReproMethod;

/*
 * typedef the commonly used types
 */
typedef unsigned int PROGW    PC;
typedef unsigned int PROGW_1  Proglen_1;
typedef unsigned int IDXW     Index;
typedef unsigned int IDXW_1   Index_1;
typedef unsigned int VW       Value;
typedef unsigned int VW       UValue;
typedef unsigned int GENW     Generation;
typedef unsigned int GENW_1   Generation_w;
typedef unsigned int POPW     PopIndex;
typedef unsigned int POPW_1   PopIndex_1;
typedef unsigned int POPW     Depth;
typedef unsigned int REGW     Register;
typedef unsigned int FTW      FuncType;
typedef unsigned int MTHW     Method;
typedef unsigned int FCASEW   Fcase;
typedef unsigned int FCASEW_1 Fcase_1;
typedef unsigned int BOOLW    Bool;
typedef unsigned int SHORTW   Ushort;
typedef signed   int SHORTW   Short;
typedef unsigned int WORKW    WorkIndex;
typedef unsigned int WORKW_1  WorkIndex_1;
typedef unsigned int PHASEW   Phase;
typedef unsigned int SRAMW    MainPopIndex;
typedef unsigned int SRAMW    ControlIndex;
typedef unsigned int BIT8     UINT8;
typedef   signed int BIT8     INT8;
typedef unsigned int BIT16    ProgNum;
typedef unsigned int BIT32    UINT32;
typedef unsigned int FUNCW    Opcode;
typedef unsigned int CTRLW    Ctrl;
typedef unsigned int WORDW    Word;
typedef unsigned int RANDWIDTH RandReg;  



/*
 * Tags for outputting the data from handlec
 */
typedef enum {
	LEN, GEN, IND, FUNC, EA1, EA2, K, FIT, BADOP, INIT, NMUTATE, NCOPY, NXOVER
} Tag;
#define EOL "\n"

#if defined HANDELC
/*
* Some macros
*/
extern RAM Word     workingPop  [MAXPHASE*MAXPAR][MAXNODES];
extern RAM Word     workingFitness   [MAXPHASE] [MAXPAR];
extern RAM Word     workingLen       [MAXPHASE] [MAXPAR];
extern RAM PopIndex workingprogNum   [MAXPHASE] [MAXPAR];


macro expr LIMIT(v,l)   = (v);
macro expr BITSET(v,l)  = (v[log2ceil(l)]);
macro expr InWork(ctrl) = ctrl[INWORK];
macro expr GetOpcode(v) = v[OPCODEBITS];
macro expr GetEa1(v)    = v[EA1BITS];
macro expr GetEa2(v)    = v[EA2BITS];
macro expr MakeInstruction(f,e1,e2) =  0@f@e1@e2;
macro expr MakeCombined(n4,n3,n2,n1) = n4@n3@n2@n1;
macro  expr UnsignedGt(a,b,w)  =  (adju(a,w) > adju(b,w));

#if defined DEBUG || defined XC4000
macro expr UnsignedLt(a,b,w) = (<FONT COLOR="#0040d0">adju(a,w) < adju(b,w)<FONT COLOR="#202020">);
macro expr UnsignedLe(a,b,w) = (<FONT COLOR="#0040d0">adju(a,w) <= adju(b,w)<FONT COLOR="#202020">);
#else
#define UnsignedLt(a,b,w)  FastLt.A_LT_B
#define UnsignedLe(a,b,w)  FastLe.A_LE_B
#define UnsignedGt(a,b,w)  FastGt.A_LE_B
#endif
#define IDXW1_2 ((IDXW_1+1)/2)

/* Fast(er) increment. Requires less gate delays since there is less
* carry bits, but requires two clock cycles as compared to one for the
* iso-c x++ operator */
macro proc IncrIdx1(x)
{
    static const unsigned IDXW_1 y = 1;
    unsigned (IDXW1_2+1) temp1;
    unsigned (IDXW1_2)   temp2;

    par  {
        temp1 = (0@(x<-IDXW1_2)) + (0@(y<-IDXW1_2));
        temp2 = (x \\ IDXW1_2) + (y \\ IDXW1_2);
    }
    x = (temp2+(0@temp1[IDXW1_2])) @ temp1[(IDXW1_2-1):0];
}

/* Convert an index into a SRAM address. */
macro proc indexToAddr(idx, addr)
{
  addr =(<FONT COLOR="#0040d0">adju(idx, SRAMW) << PROGW<FONT COLOR="#202020">);
}

/* Convert an index into a control ram address */
macro proc indexToCtrl(idx, addr)
{
  addr =(adju(idx, SRAMW) << 2);
}

macro proc WorkingPopRead(a,b,c,v)
{
    <FONT COLOR="#0040d0">v = workingPop[a@b][c]<FONT COLOR="#202020">;
}

macro expr WorkingPopGet(a,b,c) = <FONT COLOR="#0040d0">workingPop[a@b]<FONT COLOR="#202020">[c];

macro proc WorkingPopWrite(a,b,c,v)
{
    <FONT COLOR="#0040d0">workingPop[a@b][c]=v<FONT COLOR="#202020">;
}

macro expr WorkingControl(a,b) = workingControl[a][b];
macro expr WorkingFitnessRead(a,b) = <FONT COLOR="#0040d0">workingFitness[a]<FONT COLOR="#202020">[b];
macro expr WorkingFitnessWrite(a,b) = workingFitness[a][b];
macro expr WorkingprogNum(a,b) = workingprogNum[a][b];

macro expr WorkingprogNumRead(a,b) = <FONT COLOR="#0040d0">workingprogNum[a]<FONT COLOR="#202020">[b];
macro expr WorkingprogNumWrite(a,b) = <FONT COLOR="#0040d0">workingprogNum[a]<FONT COLOR="#202020">[b];

macro expr WorkingLenRead(a,b)     = <FONT COLOR="#0040d0">workingLen[a]<FONT COLOR="#202020">[b];
macro expr WorkingLenWrite(a,b)     = workingLen[a][b];

extern UINT32 randReg;
macro expr genNode() = 0@randReg[7:0];

#if DEBUG
macro proc PP1000RequestMemoryBank(b)
{
    unsigned int 2 bank;
    bank=b;
}
macro proc PP1000ReleaseMemoryBank(b)
{
    unsigned int 2 bank;
    bank=b;
}
#endif

#else
/* ISO-C definitions and macro replacements */
#warning using iso-c
typedef enum {FALSE=0, TRUE=1} TrueFalse;
UINT32 READRAM(unsigned bank, unsigned long addr);
void WRITERAM(unsigned bank, unsigned addr, unsigned val);
UINT8 MakeInstruction(unsigned long,unsigned long, unsigned long);
RandReg   s_random(void);
void randseed(void);
PC       randPC();
void     randMethod(Method *);
PopIndex randPopIndex();
Register randEa();
FuncType randInstruction();
void     WorkingPopWrite(unsigned int a, unsigned int b, unsigned int c, unsigned int v);
void     WorkingPopRead(unsigned int a, unsigned int b, unsigned int c, unsigned int *  v);
Word     WorkingPopGet(unsigned int a, unsigned int b, unsigned int c);
void dooutdata(int,int);
#define WorkingPop(p,i,o) workingPop[p][i][o]

#define WorkingLenWrite(p,i)   workingLen[p][i]
#define WorkingLenRead(p,i)   workingLen[p][i]
#define WorkingFitnessWrite(p,i)   workingFitness[p].Write[i]
#define WorkingFitnessRead(p,i)   workingFitness[p][i]
#define WorkingprogNumWrite(p,i)   workingprogNum[p][i]
#define WorkingprogNumRead(p,i)   workingprogNum[p][i]
#define WorkingControl(p,i)   workingControl[p][i]
#define PP1000ReadBank0(val,addr)  val=READRAM(0, addr)
#define PP1000WriteBank0(addr,val) WRITERAM(0, addr,val)
#define PP1000ReadBank1(val,addr)  val=READRAM(1, addr)
#define PP1000WriteBank1(addr,val) WRITERAM(1, addr,val)
#define PP1000ReleaseMemoryBank(b)
#define PP1000RequestMemoryBank(b)
#define PP1000SetGPI(val)
#define PP1000ReadGPO() 1
#define PP1000WriteStatus(v)
#define PP1000ReadControl(v)
#define InWork(ctrl)   (ctrl&1)
#define indexToAddr(i,a) (a=i*MAXNODES)
#define LIMIT(v,l)     (v < l)
#define BITSET(v,l)    (v & l)
#define MOD4(v)        (v=v&0x3)
#define BIT0(x)        (x&1)
#define BIT1(x)        (!!(x&2))

#define UnsignedGt(a,b,w) (a > b)
#define UnsignedLt(a,b,w) (a < b)
#define UnsignedLe(a,b,w) (a <= b)
#define RANDFILE   "randseed"
#define RANDLOG    "randlog"
PC randLen();
#endif

#if defined ANT
#if defined HANDELC
#define ANDGRIDMASK 
#define ANDDIRMASK
macro expr MAP(map,t,x,y) = (<FONT COLOR="#0040d0">!!((map[t][y])&(<FONT COLOR="#008080">1<<x<FONT COLOR="#0040d0">)<A NAME="area4"><U>)</U><SUB>189</SUB></A><FONT COLOR="#202020">);
#define CLRBIT(map,t,x,y)  map[t][y] &= ~(1<<x)
#else
#define ANDGRIDMASK &(GRIDX-1)
#define ANDDIRMASK  &3
#define MAP(map,t,x,y) !!(map[t][y]&(1<<x))
#define CLRBIT(map,t,x,y) map[t][y] &= ~(1<<x)
#endif

#endif

#endif
ÿendif
<FONT COLOR="#000000"><H3>
Highlight Colours Table: </H3><FONT COLOR="#ffffff">
<SPAN STYLE="background-color: #202020"> =         0.00 </SPAN>
<SPAN STYLE="background-color: #0040d0"> <      3601.60 </SPAN>
<SPAN STYLE="background-color: #008080"> <      7203.20 </SPAN>
<SPAN STYLE="background-color: #00a000"> <     10804.80 </SPAN>
<SPAN STYLE="background-color: #00c000"> <     14406.40 </SPAN>
<SPAN STYLE="background-color: #40f000"> <     18008.00 </SPAN>
<SPAN STYLE="background-color: #d0f000"> <     21609.60 </SPAN>
<SPAN STYLE="background-color: #f8f000"> <     25211.20 </SPAN>
<SPAN STYLE="background-color: #f8d000"> <     28812.80 </SPAN>
<SPAN STYLE="background-color: #f8b000"> <     32414.40 </SPAN>
<SPAN STYLE="background-color: #f88000"> <     36016.00 </SPAN>
<SPAN STYLE="background-color: #f80000"> =     36016.00 </SPAN>

</PRE>
<HR><H1><FONT COLOR="#000000">Delay Estimation</H1><BR><FONT SIZE=3><PRE>
<FONT COLOR="#000000"><H3>
Maximum delay = 66 gates
</H3>
<FONT COLOR="#000000"><H3>
C:\Program Files\Celoxica\RC1000\fpga\V2_1\XC4000\pp1000.h
</H3>
<FONT COLOR="#202020">/****************************************************************
*                                                               *
* Copyright 1991-2001 Celoxica Ltd.                             *
* All Rights Reserved                                           *
*                                                               *
* This is "Unpublished Proprietary Source Code" of Celoxica     *
* Ltd ("Celoxica").  The contents of this file may not          *
* be disclosed to third parties not covered by a Celoxica       *
* NDA (Non-Disclosure Agreement) or a Celoxica End User Licence *
* Agreement or other agreement.                                 *
*                                                               *
* In addition, the source code of this file may not be          *
* copied or duplicated in any form without the prior written    *
* authorization of Celoxica.                                    *
*                                                               *
* This code is protected by English and International           *
* copyright laws.  All use of this code is subject to the       *
* End User License Agreement, Non-Disclosure Agreement,         *
* or other agreement in effect with Celoxica.  If a             *
* licence document or agreement is not included with this       *
* source code please contact Celoxica immediately for a copy of *
* the applicable licence agreement.                             *
*                                                               *
* Any other use of this code other than as expressly agreed     *
* to by Celoxica including decompilation,                       *
* disassembly, or reverse engineering is unauthorised.          *
*                                                               *
* Rights of confidence, trademark rights, and other             *
* intellectual property rights reserved under the laws of       *
* England, the United States, and the International             *
* Community.                                                    *
*                                                               *
* World Wide Headquarters:                                      *
* Celoxica Limited                                              *
* 20 Park Gate                                                  *
* Abingdon                                                      *
* Oxfordshire                                                   *
* United Kingdom                                                *
* OX14 4SH                                                      *
* Tel:   +44 1235 863656                                        *
* Fax:   +44 1235 863648                                        *
*                                                               *
* US Headquarters:                                              *
* Celoxica Inc                                                  *
* 900 East Hamilton Ave.                                        *
* Suite 150                                                     *
* Campbell, CA 95008                                            *
* Tel: 1-408-626-9070                                           *
* Fax: 1-408-626-9079                                           *
*                                                               *
* Email     :   support@celoxica.com                            *
*                                                               *
*****************************************************************
* Project   :   RC1000-PP                                       *
* Date      :   09/06/98                                        *
* File      :   pp1000.h                                        *
* Author    :   Matthew Bowen                                   *
*                                                               *
* Date      Version     Author      Reason for change           *
* 09/06/98  0.98        MB          Created                     *
* 02/03/99  1.00        MB          Updated for rev 2.0 PCB     *
* 11/06/99  1.00        MB          First full release          *
*                                                               *
* Description                                                   *
*   Header file for RC1000-PP FPGA version 2.00 PCB.            *
*                                                               *
****************************************************************/

/*
 * Pins for RAM bank 0
 */
macro expr PP1000_Data0_3 = {
    "U29", "U33", "V32", "V31", "V29", "V30", "W31", "W33"};
macro expr PP1000_Data0_2 = {
    "W30", "W29", "Y32", "AF32", "Y30", "AA33", "Y29", "AA32"};
macro expr PP1000_Data0_1 = {
    "AA31", "AA30", "AK28", "AA29", "AB31", "AB30", "AC33", "AC31"};
macro expr PP1000_Data0_0 = {
    "AB29", "AC30", "AD31", "AE33", "AC29", "AE32", "AD30", "AE31"};
macro expr PP1000_Data0 = {
    "U29", "U33", "V32", "V31", "V29", "V30", "W31", "W33",
    "W30", "W29", "Y32", "AF32", "Y30", "AA33", "Y29", "AA32",
    "AA31", "AA30", "AK28", "AA29", "AB31", "AB30", "AC33", "AC31",
    "AB29", "AC30", "AD31", "AE33", "AC29", "AE32", "AD30", "AE31"};

macro expr PP1000_Addr0 = {
    "AN29", "AM31", "AD29", "AF31", "AE30", "AG33", "AH33", "AE29",
    "AJ26", "AF30", "AH32", "AJ32", "AF29", "AH31", "AG30", "AK32",
    "AJ31", "AG29", "AL33", "AH30", "AJ30" };

macro expr PP1000_CS0 = { "AL28", "AK27", "AL29", "AN31" };
macro expr PP1000_WE0 = { "AJ25" };
macro expr PP1000_OE0 = { "AK26" };
macro expr PP1000_CS0_0 = { "AN31" };
macro expr PP1000_CS0_1 = { "AL29" };
macro expr PP1000_CS0_2 = { "AK27" };
macro expr PP1000_CS0_3 = { "AL28" };



/*
 * Pins for RAM bank 1
 */
macro expr PP1000_Data1_3 = {
    "AB3", "AC1", "AB4", "AC3", "AA5", "AJ6", "AD3", "AE1"};
macro expr PP1000_Data1_2 = {
    "AC5", "AE3", "AD4", "AF1", "AF2", "AD5", "AG2", "AE4"};
macro expr PP1000_Data1_1 = {
    "AF3", "AH1", "AE5", "AJ1", "AF4", "AJ2", "AF5", "AH3"};
macro expr PP1000_Data1_0 = {
    "AG4", "AK2", "AJ3", "AG5", "AL1", "AH4", "AK3", "AN3"};
macro expr PP1000_Data1 = {
    "AB3", "AC1", "AB4", "AC3", "AA5", "AJ6", "AD3", "AE1", 
    "AC5", "AE3", "AD4", "AF1", "AF2", "AD5", "AG2", "AE4", 
    "AF3", "AH1", "AE5", "AJ1", "AF4", "AJ2", "AF5", "AH3", 
    "AG4", "AK2", "AJ3", "AG5", "AL1", "AH4", "AK3", "AN3"};

macro expr PP1000_Addr1 = {
    "AK10", "AM9", "U4", "U1", "U2", "V2", "V4", "V5", "V3", "W1", 
    "W3", "AK9", "W5", "AL8", "Y3", "Y4", "AA1", "Y5",
    "AA3", "AA4", "AN7"};

macro expr PP1000_CS1 = { "AK7", "AL6", "AJ8", "AM6" };
macro expr PP1000_WE1 = { "AK6" };
macro expr PP1000_OE1 = { "AL5" };
macro expr PP1000_CS1_0 = { "AM6" };
macro expr PP1000_CS1_1 = { "AJ8" };
macro expr PP1000_CS1_2 = { "AL6" };
macro expr PP1000_CS1_3 = { "AK7" };


/*
 * Pins for RAM bank 2
 */
macro expr PP1000_Data2_3 = {
    "D31", "F30", "C33", "G29", "E31", "D32", "G30", "F31" };
macro expr PP1000_Data2_2 = {
    "H29", "E32", "E33", "E28", "G31", "J29", "F33", "G32" };
macro expr PP1000_Data2_1 = {
    "J30", "H31", "K29", "H32", "J31", "K30", "H33", "L29" };
macro expr PP1000_Data2_0 = {
    "K31", "L30", "J33", "M29", "L31", "M30", "L32", "M31" };
macro expr PP1000_Data2 = {
    "D31", "F30", "C33", "G29", "E31", "D32", "G30", "F31",
    "H29", "E32", "E33", "E28", "G31", "J29", "F33", "G32",
    "J30", "H31", "K29", "H32", "J31", "K30", "H33", "L29",
    "K31", "L30", "J33", "M29", "L31", "M30", "L32", "M31" };
 
macro expr PP1000_Addr2 = {
    "B29", "E26", "F29", "L33", "N30", "N31", "M32", "P29",
    "P30", "D30", "P31", "P32", "R29", "R30", "R31", "R33",
    "T31", "T29", "T30", "T32", "U31"};

macro expr PP1000_CS2 = { "A31", "D28", "C30", "D29" };
macro expr PP1000_WE2 = { "C28" };
macro expr PP1000_OE2 = { "D27" };
macro expr PP1000_CS2_0 = { "D29" };
macro expr PP1000_CS2_1 = { "C30" };
macro expr PP1000_CS2_2 = { "D28" };
macro expr PP1000_CS2_3 = { "A31" };

/*
 * Pins for RAM bank 3
 */
macro expr PP1000_Data3_3 = {
    "J4", "H3", "K5", "H2", "J3", "K4", "J2", "L5"};
macro expr PP1000_Data3_2 = {
    "E8", "C6", "K2", "M5", "L3", "L1", "M4", "N5"};
macro expr PP1000_Data3_1 = {
    "M2", "N4", "N3", "N2", "P5", "U3", "P4", "D7"};
macro expr PP1000_Data3_0 = {
    "P2", "R5", "R4", "R3", "R1", "T4", "T5", "T2"};
macro expr PP1000_Data3 = {
    "J4", "H3", "K5", "H2", "J3", "K4", "J2", "L5", 
    "E8", "C6", "K2", "M5", "L3", "L1", "M4", "N5", 
    "M2", "N4", "N3", "N2", "P5", "U3", "P4", "D7", 
    "P2", "R5", "R4", "R3", "R1", "T4", "T5", "T2"};

macro expr PP1000_Addr3 = {
    "A5", "B5", "C5", "E7", "F5", "B3", "D3", "F4",
    "C1", "G5", "E3", "D2", "G4", "H5", "E2", "F3",
    "H4", "G3", "J5", "F1", "G1"};

macro expr PP1000_CS3 = { "B8", "A8", "D10", "C9" };
macro expr PP1000_WE3 = { "A6" };
macro expr PP1000_OE3 = { "B7" };
macro expr PP1000_CS3_0 = { "C9" };
macro expr PP1000_CS3_1 = { "D10" };
macro expr PP1000_CS3_2 = { "A8" };
macro expr PP1000_CS3_3 = { "B8" };

/*
 * Clock pin
 */
#if (defined(PP1000_DIVIDE1) && defined(PP1000_DIVIDE3)) || (defined(PP1000_DIVIDE1) && defined(PP1000_DIVIDE4)) || (defined(PP1000_DIVIDE3) && defined(PP1000_DIVIDE4))
#error Please define only one of PP1000_DIVIDE1, PP1000_DIVIDE3 or PP1000_DIVIDE4 before including pp1000.h
#endif

#if !defined(PP1000_DIVIDE1) && !defined(PP1000_DIVIDE3) && !defined(PP1000_DIVIDE4)
#error Please define one of PP1000_DIVIDE1, PP1000_DIVIDE3 or PP1000_DIVIDE4 before including pp1000.h
#endif

#ifndef PP1000_CLOCK
#define PP1000_CLOCK PP1000_MCLK
#endif

#define PP1000_MCLK "AH29"
#define PP1000_VCLK "AJ28"

#ifdef PP1000_DIVIDE1
set clock = external PP1000_CLOCK;
#elif defined(PP1000_DIVIDE3)
set clock = external_divide PP1000_CLOCK 3;
#elif defined(PP1000_DIVIDE4)
set clock = external_divide PP1000_CLOCK 4;
#endif

/*
 * PLX User I/O Pins
 */
macro expr PP1000_PLXUserIn = {"AJ10"};
macro expr PP1000_PLXUserOut = {"AL9"};

/*
 * Status byte pins
 */
macro expr PP1000_FPGAStatus = {
    "AJ15", "AK15", "AL15", "AM16", "AL16", "AJ16", "AK16", "AN17" };
macro expr PP1000_FPGAStatusValid = { "AN15" };
macro expr PP1000_FPGAStatusAck = { "AM14" };

/*
 * Control byte pins
 */
macro expr PP1000_FPGAControl = {
    "AL18", "AK18", "AJ18", "AN19", "AL19", "AK19", "AM20", "AJ19" };
macro expr PP1000_FPGAControlValid = { "AM18" };
macro expr PP1000_FPGAControlAck = { "AL20" };

/*
 * LED Pins
 */
macro expr PP1000_LEDPin0 = { "AN28" };
macro expr PP1000_LEDPin1 = { "AK25" };
macro expr PP1000_LEDPin2 = { "AL26" };
macro expr PP1000_LEDPin3 = { "AJ24" };
macro expr PP1000_LEDPin4 = { "AM27" };
macro expr PP1000_LEDPin5 = { "AM26" };
macro expr PP1000_LEDPin6 = { "AK24" };
macro expr PP1000_LEDPin7 = { "AL25" };

/*
 * Memory bank request
 */
macro expr PP1000_Bank0Req = { "AM30" };
macro expr PP1000_Bank1Req = { "AM4" };
macro expr PP1000_Bank2Req = { "C29" };
macro expr PP1000_Bank3Req = { "C8" };
macro expr PP1000_Bank0Grant = { "AM29" };
macro expr PP1000_Bank1Grant = { "AJ7" };
macro expr PP1000_Bank2Grant = { "B30" };
macro expr PP1000_Bank3Grant = { "D9" };

/*
 * Auxilliary I/O
 */
macro expr PP1000_Aux = {
    "E11", "A9", "C10", "D11", "B10", "B11", "D12", "A11",
    "E13", "C12", "D15", "D13", "C13", "E14", "A13", "D14",
    "C14", "E15", "C15", "A15", "D16", "B16", "B17", "C20",
    "E20", "B21", "C21", "D21", "B22", "E21", "D20", "D22",
    "A23", "C23", "E22", "B24", "D23", "A25", "E23", "B25",
    "D24", "C25", "B26", "E24", "C26", "D25", "A27", "A28",
    "E25", "C27"};

/*
 * Reset line
 */
macro expr PP1000_Reset = { "AL4" };

/*
 * Spare pins
 */
macro expr PP1000_Spare = {
    "U3", "M4", "F3", "F29", "AH5", "AJ1", "AA5", "U29",
    "AE31", "AF32", "A17", "B18", "C18", "B33", "E18", "D18",
    "A19", "C19", "D19", "E19", "B20", "C20", "D20", "D26",
    "B28", "B29", "E26", "E27", "E28", "D30",
    "E29", "AK30", "AJ29", "AN32", "AJ28", "AK29", "AL30", "AK28",
    "AM31", "AJ27", "AJ26", "AJ25", "AN29", "AJ23",
    "AN26", "AL24", "AK23", "AJ22", "AL23", "AM24", "AK22", "AM23",
    "AJ21", "AL22", "AN23", "AK21", "AM22", "AJ20", "AL21", "AN21",
    "AK20", "AL20", "AJ17", "AL17", "AL14", "AK14", "AJ14", "AN13",
    "AM13", "AL13", "AK13", "AJ13", "AM12", "AL12", "AK12", "AN11",
    "AJ12", "AL11", "AM10", "AL10", "AJ11", "AN9", "AK10", "AM9",
    "AJ10", "AM8", "AK9", "AL8", "AN7", "AJ9", "AL7",
    "AK8", "AN6", "AM5", "AN3", "AJ6",
    "AJ5", "AM1", "U5", "E4", "D4", "C4", "D17", "D5",
    "A2", "A3", "B4", "D7", "E8", "B5", "A5",
    "D8", "C7", "E9", "A6", "B7", "E10",
    "C11", "E15", "D15", "C16", "E16", "E17"};

macro expr PP1000_TDO = {"E6"};

/****************************************
* EXTERNAL RAM ACCESS MACRO DEFINITIONS *
****************************************/

/*
 * General RAM defintion - assume external clock divided by 4
 */
macro expr PP1000_RAMSpec(a, d, c, w, o) = 
{
    offchip = 1,
    addr = a,
    data = d,
    cs = c,
    we = w,
    oe = o,
#ifdef PP1000_DIVIDE1
    wegate = 1,
#elif defined(PP1000_DIVIDE3)
    westart = 1,    /* For external clock divided by 3, set write strobe to start */
    welength = 1,   /* 1/3 way through cycle and last for 1/3 of a cycle. */
#elif defined(PP1000_DIVIDE4)
    westart = 2,    /* For external clock divided by 4, set write strobe to start */
    welength = 1,   /* 1/2 way through cycle and last for 1/4 of a cycle. */
#endif
    warn = 0
};

#if defined(PP1000_32BIT_RAMS) && defined(PP1000_8BIT_RAMS)
#error Please define only one of PP1000_32BIT_RAMS or PP1000_8BIT_RAMS before including pp1000.h
#endif

#if !defined(PP1000_32BIT_RAMS) && !defined(PP1000_8BIT_RAMS)
#error Please define either PP1000_32BIT_RAMS or PP1000_8BIT_RAMS before including pp1000.h
#endif

#ifdef PP1000_32BIT_RAMS
/*
 * Declare 32 bit wide RAMs and access routines
 * Macros are:
 *  PP1000ReadBank#(DestReg, Address)
 *    where # is 0, 1, 2, 3
 *          DestReg is unsigned 32 bit word
 *          Address is 21 bit unsigned integer
 *  PP1000WriteBank#(Address, Value)
 *    where # is 0, 1, 2, 3
 *          Address is 21 bit unsigned integer
 *          Value is unsigned 32 bit expression
 */
ram unsigned 32 <FONT COLOR="#00a000">PP1000Bank0[2097152]<FONT COLOR="#202020"> with PP1000_RAMSpec(PP1000_Addr0, PP1000_Data0, PP1000_CS0,
                                                         PP1000_WE0, PP1000_OE0);
macro proc PP1000ReadBank0(Reg, Addr) { Reg = PP1000Bank0[Addr]; }
macro proc PP1000WriteBank0(Addr, Expr) { PP1000Bank0[Addr] = Expr; }

ram unsigned 32 <FONT COLOR="#00a000">PP1000Bank1[2097152]<FONT COLOR="#202020"> with PP1000_RAMSpec(PP1000_Addr1, PP1000_Data1, PP1000_CS1,
                                                         PP1000_WE1, PP1000_OE1);
macro proc PP1000ReadBank1(Reg, Addr) { Reg = PP1000Bank1[Addr]; }
macro proc PP1000WriteBank1(Addr, Expr) { PP1000Bank1[Addr] = Expr; }

ram unsigned 32 PP1000Bank2[2097152] with PP1000_RAMSpec(PP1000_Addr2, PP1000_Data2, PP1000_CS2,
                                                         PP1000_WE2, PP1000_OE2);
macro proc PP1000ReadBank2(Reg, Addr) { Reg = PP1000Bank2[Addr]; }
macro proc PP1000WriteBank2(Addr, Expr) { PP1000Bank2[Addr] = Expr; }

ram unsigned 32 PP1000Bank3[2097152] with PP1000_RAMSpec(PP1000_Addr3, PP1000_Data3, PP1000_CS3,
                                                         PP1000_WE3, PP1000_OE3);
macro proc PP1000ReadBank3(Reg, Addr) { Reg = PP1000Bank3[Addr]; }
macro proc PP1000WriteBank3(Addr, Expr) { PP1000Bank3[Addr] = Expr; }
#endif /* PP1000_32BIT_RAMS */


#ifdef PP1000_8BIT_RAMS
/*
 * Declare 8 bit wide RAMs and access routines
 * Macros are:
 *  PP1000ReadBank#(DestReg, Address)
 *    where # is 0, 1, 2, 3
 *          DestReg is unsigned 8 bit word
 *          Address is 23 bit unsigned integer (bottom 2 bit are byte select)
 *  PP1000WriteBank#(Address, Value)
 *    where # is 0, 1, 2, 3
 *          Address is 23 bit unsigned integer (bottom 2 bit are byte select)
 *          Value is unsigned 8 bit expression
 */
#define BUILD_RAM(n) \
ram unsigned 0 PP1000_Bank##n##WEOE[1] with PP1000_RAMSpec({}, {}, {}, PP1000_WE##n, PP1000_OE##n); \
ram unsigned 0 PP1000_Bank##n##Addr[2097152] with PP1000_RAMSpec(PP1000_Addr##n, {}, {}, {}, {}); \
ram unsigned 8 PP1000_Bank##n##Data0[1] with PP1000_RAMSpec({}, PP1000_Data##n##_0, {}, {}, {}); \
ram unsigned 0 PP1000_Bank##n##Ctrl0[1] with PP1000_RAMSpec({}, {}, PP1000_CS##n##_0, {}, {}); \
ram unsigned 8 PP1000_Bank##n##Data1[1] with PP1000_RAMSpec({}, PP1000_Data##n##_1, {}, {}, {}); \
ram unsigned 0 PP1000_Bank##n##Ctrl1[1] with PP1000_RAMSpec({}, {}, PP1000_CS##n##_1, {}, {}); \
ram unsigned 8 PP1000_Bank##n##Data2[1] with PP1000_RAMSpec({}, PP1000_Data##n##_2, {}, {}, {}); \
ram unsigned 0 PP1000_Bank##n##Ctrl2[1] with PP1000_RAMSpec({}, {}, PP1000_CS##n##_2, {}, {}); \
ram unsigned 8 PP1000_Bank##n##Data3[1] with PP1000_RAMSpec({}, PP1000_Data##n##_3, {}, {}, {}); \
ram unsigned 0 PP1000_Bank##n##Ctrl3[1] with PP1000_RAMSpec({}, {}, PP1000_CS##n##_3, {}, {}); \
macro proc PP1000ReadBank##n(Reg, Addr) \
{ \
    unsigned 0 Dummy[2] with {warn=0}; \
\
    par \
    { \
        Dummy[0] = PP1000_Bank##n##WEOE[0]; \
        PP1000_Bank##n##Addr[((unsigned 23)Addr)\\2] = 0; \
        switch(((unsigned 23)Addr)[1:0]) \
        { \
        case 0:\
            par \
            {\
                Reg = PP1000_Bank##n##Data0[0]; \
                Dummy[1] = PP1000_Bank##n##Ctrl0[0]; \
            } \
            break; \
        case 1:\
            par \
            {\
                Reg = PP1000_Bank##n##Data1[0]; \
                Dummy[1] = PP1000_Bank##n##Ctrl1[0]; \
            } \
            break; \
        case 2:\
            par \
            {\
                Reg = PP1000_Bank##n##Data2[0]; \
                Dummy[1] = PP1000_Bank##n##Ctrl2[0]; \
            } \
            break; \
        case 3:\
            par \
            {\
                Reg = PP1000_Bank##n##Data3[0]; \
                Dummy[1] = PP1000_Bank##n##Ctrl3[0]; \
            } \
            break; \
        default: delay; break; \
        } \
    } \
} \
\
macro proc PP1000WriteBank##n(Addr, Expr) \
{ \
    par \
    { \
        PP1000_Bank##n##WEOE[0] = 0; \
        PP1000_Bank##n##Addr[((unsigned 23)Addr)\\2] = 0; \
        switch(((unsigned 23)Addr)[1:0]) \
        { \
        case 0: \
            par \
            { \
                PP1000_Bank##n##Data0[0] = Expr; \
                PP1000_Bank##n##Ctrl0[0] = 0; \
            } \
            break; \
        case 1: \
            par \
            { \
                PP1000_Bank##n##Data1[0] = Expr; \
                PP1000_Bank##n##Ctrl1[0] = 0; \
            } \
            break; \
        case 2: \
            par \
            { \
                PP1000_Bank##n##Data2[0] = Expr; \
                PP1000_Bank##n##Ctrl2[0] = 0; \
            } \
            break; \
        case 3: \
            par \
            { \
                PP1000_Bank##n##Data3[0] = Expr; \
                PP1000_Bank##n##Ctrl3[0] = 0; \
            } \
            break; \
        default: delay; break; \
        } \
    } \
}

BUILD_RAM(0)
BUILD_RAM(1)
BUILD_RAM(2)
BUILD_RAM(3)

#endif /* PP1000_8BIT_RAMS */


#ifndef SIMULATE
/*
 * Macro to write word to FPGA->host status word
 */
unsigned 1 <FONT COLOR="#008080">PP1000_StatusValid<FONT COLOR="#202020"> = 1 with {warn = 0};
interface <FONT COLOR="#0040d0">bus_out() PP1000_StatusValidBus(PP1000_StatusValid)<FONT COLOR="#202020"> with {data = PP1000_FPGAStatusValid};
interface <FONT COLOR="#0040d0">bus_clock_in(unsigned 1) PP1000_StatusAck()<FONT COLOR="#202020"> with {data = PP1000_FPGAStatusAck};
unsigned 8 <FONT COLOR="#008080">PP1000_StatusByte<FONT COLOR="#202020"> with {warn = 0};
interface <FONT COLOR="#0040d0">bus_out() PP1000_StatusBus(PP1000_StatusByte)<FONT COLOR="#202020"> with {data = PP1000_FPGAStatus};

macro proc PP1000WriteStatus(Value)
{
    /*
     * Set value and assert valid pin
     */
    PP1000_StatusByte = Value;
    PP1000_StatusValid = 0;

    /*
     * Wait for acknowledge
     */
    <FONT COLOR="#008080">while (PP1000_StatusAck.in==1)
    {
        delay;
    }<FONT COLOR="#202020">

    /*
     * Clear valid pin
     */
    PP1000_StatusValid = 1;

    /*
     * Wait for acknowledge to clear
     */
    <FONT COLOR="#008080">while (PP1000_StatusAck.in==0)
    {
        delay;
    }<FONT COLOR="#202020">
}

/*
 * Macro to read word from host->FPGA control word
 */
unsigned 1 <FONT COLOR="#008080">PP1000_ControlAck<FONT COLOR="#202020"> = 1 with {warn = 0};
interface <FONT COLOR="#0040d0">bus_out() PP1000_ControlAckBus(PP1000_ControlAck)<FONT COLOR="#202020"> with {data = PP1000_FPGAControlAck};
interface <FONT COLOR="#0040d0">bus_clock_in(unsigned 1) PP1000_ControlValid()<FONT COLOR="#202020"> with {data = PP1000_FPGAControlValid};
interface bus_in(unsigned 8) PP1000_ControlByte() with {data = PP1000_FPGAControl};

macro proc PP1000ReadControl(Reg)
{
    /*
     * Wait for flag to be asserted
     */
    <FONT COLOR="#008080">while (PP1000_ControlValid.in==1)
    {
        delay;
    }<FONT COLOR="#202020">

    /*
     * Read data and assert acknowledge
     */
    par
    {
        Reg = PP1000_ControlByte.in;
        PP1000_ControlAck = 0;
    }

    /*
     * Wait for flag to be deasserted
     */
    <FONT COLOR="#008080">while (PP1000_ControlValid.in==0)
    {
        delay;
    }<FONT COLOR="#202020">

    /*
     * Deassert acknowledge
     */
    PP1000_ControlAck = 1;
}


/*
 * Macros to turn LEDs on and off
 */
unsigned 1 PP1000_LEDState[8] with { warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_LED0Bus(~PP1000_LEDState[0])<FONT COLOR="#202020"> with { data = PP1000_LEDPin0, warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_LED1Bus(~PP1000_LEDState[1])<FONT COLOR="#202020"> with { data = PP1000_LEDPin1, warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_LED2Bus(~PP1000_LEDState[2])<FONT COLOR="#202020"> with { data = PP1000_LEDPin2, warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_LED3Bus(~PP1000_LEDState[3])<FONT COLOR="#202020"> with { data = PP1000_LEDPin3, warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_LED4Bus(~PP1000_LEDState[4])<FONT COLOR="#202020"> with { data = PP1000_LEDPin4, warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_LED5Bus(~PP1000_LEDState[5])<FONT COLOR="#202020"> with { data = PP1000_LEDPin5, warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_LED6Bus(~PP1000_LEDState[6])<FONT COLOR="#202020"> with { data = PP1000_LEDPin6, warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_LED7Bus(~PP1000_LEDState[7])<FONT COLOR="#202020"> with { data = PP1000_LEDPin7, warn = 0 };
macro proc PP1000SetLEDs(Mask)
{
    par
    {
        PP1000_LEDState[0] = Mask[0];
        PP1000_LEDState[1] = Mask[1];
        PP1000_LEDState[2] = Mask[2];
        PP1000_LEDState[3] = Mask[3];
        PP1000_LEDState[4] = Mask[4];
        PP1000_LEDState[5] = Mask[5];
        PP1000_LEDState[6] = Mask[6];
        PP1000_LEDState[7] = Mask[7];
    }
}

macro proc PP1000LEDOn(Number)
{
    /*
     * Use a switch to allow Number to be a variable/expression
     */
    switch(Number<-3)
    {
    case 0:
        PP1000_LEDState[0] = 1;
        break;
    case 1:
        PP1000_LEDState[1] = 1;
        break;
    case 2:
        PP1000_LEDState[2] = 1;
        break;
    case 3:
        PP1000_LEDState[3] = 1;
        break;
    case 4:
        PP1000_LEDState[4] = 1;
        break;
    case 5:
        PP1000_LEDState[5] = 1;
        break;
    case 6:
        PP1000_LEDState[6] = 1;
        break;
    case 7:
        PP1000_LEDState[7] = 1;
        break;
    }
}

macro proc PP1000LEDOff(Number)
{
    /*
     * Use a switch to allow Number to be a variable/expression
     */
    switch(Number<-3)
    {
    case 0:
        PP1000_LEDState[0] = 0;
        break;
    case 1:
        PP1000_LEDState[1] = 0;
        break;
    case 2:
        PP1000_LEDState[2] = 0;
        break;
    case 3:
        PP1000_LEDState[3] = 0;
        break;
    case 4:
        PP1000_LEDState[4] = 0;
        break;
    case 5:
        PP1000_LEDState[5] = 0;
        break;
    case 6:
        PP1000_LEDState[6] = 0;
        break;
    case 7:
        PP1000_LEDState[7] = 0;
        break;
    }
}


/*
 * Macros to request/release RAM banks
 */
#define PP1000_BANK0    0x1
#define PP1000_BANK1    0x2
#define PP1000_BANK2    0x4
#define PP1000_BANK3    0x8

unsigned 1 <FONT COLOR="#008080">PP1000_RAMRequest[4]<FONT COLOR="#202020"> with { warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_RAMRequest0Bus(~PP1000_RAMRequest[0])<FONT COLOR="#202020"> with { data = PP1000_Bank0Req, warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_RAMRequest1Bus(~PP1000_RAMRequest[1])<FONT COLOR="#202020"> with { data = PP1000_Bank1Req, warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_RAMRequest2Bus(~PP1000_RAMRequest[2])<FONT COLOR="#202020"> with { data = PP1000_Bank2Req, warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_RAMRequest3Bus(~PP1000_RAMRequest[3])<FONT COLOR="#202020"> with { data = PP1000_Bank3Req, warn = 0 };
interface <FONT COLOR="#0040d0">bus_clock_in(unsigned 1) PP1000_RAMGrant0Bus()<FONT COLOR="#202020"> with { data = PP1000_Bank0Grant, warn = 0 };
interface <FONT COLOR="#0040d0">bus_clock_in(unsigned 1) PP1000_RAMGrant1Bus()<FONT COLOR="#202020"> with { data = PP1000_Bank1Grant, warn = 0 };
interface <FONT COLOR="#0040d0">bus_clock_in(unsigned 1) PP1000_RAMGrant2Bus()<FONT COLOR="#202020"> with { data = PP1000_Bank2Grant, warn = 0 };
interface <FONT COLOR="#0040d0">bus_clock_in(unsigned 1) PP1000_RAMGrant3Bus()<FONT COLOR="#202020"> with { data = PP1000_Bank3Grant, warn = 0 };

macro proc PP1000RequestMemoryBank(BankMask)
{
    macro expr GrantMask = <FONT COLOR="#0040d0">~(PP1000_RAMGrant3Bus.in @
                             PP1000_RAMGrant2Bus.in @
                             PP1000_RAMGrant1Bus.in @
                             PP1000_RAMGrant0Bus.in)<FONT COLOR="#202020">;

    /*
     * Request banks
     * Use if statements to allow multiple requests in parallel
     * while avoiding parallel writes to registers
     */
    par
    {
        <FONT COLOR="#0040d0">if (BankMask[0])
        {
            PP1000_RAMRequest[0] = 1;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
        <FONT COLOR="#0040d0">if (BankMask[1])
        {
            PP1000_RAMRequest[1] = 1;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
        <FONT COLOR="#0040d0">if (BankMask[2])
        {
            PP1000_RAMRequest[2] = 1;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
        <FONT COLOR="#0040d0">if (BankMask[3])
        {
            PP1000_RAMRequest[3] = 1;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
    }

    /*
     * Wait for requested banks to be granted
     */
    <FONT COLOR="#008080">while ((GrantMask&BankMask)!=BankMask)
    {
        delay;
    }<FONT COLOR="#202020">
}

macro proc PP1000ReleaseMemoryBank(BankMask)
{
    /*
     * Release requests
     * Use if statements to allow multiple requests in parallel
     * while avoiding parallel writes to registers
     */
    par
    {
        <FONT COLOR="#008080">if (BankMask[0])
        {
            PP1000_RAMRequest[0] = 0;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
        <FONT COLOR="#008080">if (BankMask[1])
        {
            PP1000_RAMRequest[1] = 0;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
        <FONT COLOR="#008080">if (BankMask[2])
        {
            PP1000_RAMRequest[2] = 0;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
        <FONT COLOR="#008080">if (BankMask[3])
        {
            PP1000_RAMRequest[3] = 0;
        }
        else
        {
            delay;
        }<FONT COLOR="#202020">
    }
}


/*
 * PLX General Purpose Input/Output
 */
unsigned 1 PP1000_PLXUser=0 with { warn = 0 };
interface <FONT COLOR="#0040d0">bus_out() PP1000_PLXUserInBus(PP1000_PLXUser)<FONT COLOR="#202020"> with { data = PP1000_PLXUserIn, warn = 0 };
interface bus_clock_in(unsigned 1) PP1000_PLXUserOutBus() with { data = PP1000_PLXUserOut, warn = 0 };

macro proc PP1000SetGPI(Value)
{
    PP1000_PLXUser = Value!=0 ? 1 : 0;
}
macro expr PP1000ReadGPO() = PP1000_PLXUserOutBus.in;


/*
 * Reset bus
 */
interface bus_clock_in(unsigned 1) PP1000_ResetBus() with { data = PP1000_Reset, warn =  0 };
macro expr PP1000Reset() = ~PP1000_ResetBus.in;

#endif

ÿ<FONT COLOR="#000000"><H3>
C:\USER\PETES\PhD\hwgpperf\hwgp.c
</H3>
<FONT COLOR="#202020">/**************************************************************************
 * hwgp: Hardware implementation of Genetic Programming. Written in
 * Handel-C for compilation to a Xilinx FPGA
 *
 * Pete Martin 2001
 *
 ***************************************************************************
 * This file implements the following versions:
 *
 * -DHANDELC     for compling under handelc, both simulator and edif
 * -DDEBUG       for compliling for the handelc simulator
 *               if this is not defined but HANDELC is then it will compile
 *               for EDIF
 * 
 * -DPOPSIZE     Overrides the default population size
 * -DMAXPROGLEN  Overrides the default maximum progam length
 * -DPROBLEM=xxx Set the problem to compile for
 *               XOR
 *               ANT
 ***************************************************************************/

#define VERSION "1.0"

/*#define PRESET*/

#ifndef HANDELC
#include <stdio.h> 
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#else
#ifdef DEBUG

set clock = external "P35";

#else
/*
 * Include RC1000-PP support header file
 */
#if defined XC4000
#define BOARD_TYPE PP1000_V2_4000
#define PP1000_CLOCKRATE  10
#define PP1000_CLOCK    PP1000_MCLK with {rate=PP1000_CLOCKRATE}
#define PP1000_32BIT_RAMS
#define PP1000_DIVIDE1
#else
#define BOARD_TYPE PP1000_V2_VIRTEX
#define PP1000_CLOCKRATE  40
#define PP1000_CLOCK    PP1000_MCLK
#define PP1000_32BIT_RAMS
#define PP1000_DIVIDE4
#endif
#include <pp1000.h>

#endif  /* DEBUG */
#endif  /* !HANDELC */

#include <stdlib.h>

#include <hwgph.h>

/* Define the internal population storage
* this is a subset of the full population that is held in external
* static RAM. These are used for internal operations.
* There are 2 separate sets of individuals in ram here.
* Each one is used for a different phase of the pipeline 
* The working ram is arranged as WORDLEN bit words. The evaluation
* function will decode this into instruction sized chunks as needed.
* MPRAMs are used here, not because we want to access the rams twice in once
* clock cycle, but because this allows better routing performance.
*/

RAM Word  <FONT COLOR="#00c000">workingPop  [MAXPHASE*MAXPAR][MAXNODES]<FONT COLOR="#202020"> WITHBLOCK;
RAM Bool <FONT COLOR="#d0f000">populationControl [POPSIZE]<FONT COLOR="#202020"> WITHBLOCK;
RAM Word <FONT COLOR="#00c000">populationFitness [POPSIZE]<FONT COLOR="#202020"> WITHBLOCK;
RAM Word <FONT COLOR="#00c000">populationLen [POPSIZE]<FONT COLOR="#202020"> WITHBLOCK;
/* Storage for the population control information
* This can be processed in parallel with the main population */
RAM Word <FONT COLOR="#00c000">workingLen [MAXPHASE] [MAXPAR]<FONT COLOR="#202020"> WITHBLOCK;
RAM    PopIndex <FONT COLOR="#00c000">workingprogNum[MAXPHASE][MAXPAR]<FONT COLOR="#202020"> WITHBLOCK;
RAM Word <FONT COLOR="#00c000">workingFitness      [MAXPHASE] [MAXPAR]<FONT COLOR="#202020"> WITHBLOCK;



RAM Word      <FONT COLOR="#008080">workingParentFitness[MAXPHASE] [MAXPAR]<FONT COLOR="#202020"> WITHBLOCK;

UINT32        <A NAME="delay0"><U><FONT COLOR="#f80000">cycles</U><SUB>66</SUB></A><FONT COLOR="#202020">; /* Count of cycles executed in main program */
Bool          <FONT COLOR="#008080">running<FONT COLOR="#202020">; /* Control the measurement of cycles */

#if 1
#if DEBUG
/* Provide some storage for sram if we are using the simulator */
ram UINT32  sram[4][POPSIZE*MAXNODES] WITHBLOCK;
#define RAMW (log2ceil(POPSIZE*MAXNODES))

macro proc PP1000WriteBank0(C_UINT addr, C_UINT val)
{
    sram[0][adju(addr,RAMW)]=val;
}

macro proc PP1000WriteBank1(C_UINT addr, C_UINT val)
{
    sram[1][adju(addr,RAMW)]=val;
}


macro proc PP1000ReadBank0(C_UINT val, C_UINT addr)
{
    val = sram[0][adju(addr,RAMW)];
}

macro proc PP1000ReadControl(x)
{
    x=1;
}

macro proc PP1000WriteStatus(x)
{

}

#endif


#if defined ANT
static UINT32 <FONT COLOR="#0040d0">initialMap[32]<FONT COLOR="#202020"> = {
  0x0000000e,
  0x00000008,
  0x0e000008,
  0x21000008,
  0x21000008,
  0x00601f78,
  0x20001000,
  0x00101000,
  0x00101000,
  0x20101000,
  0x00100000,
  0x00001000,
  0x20001000,
  0x00101000,
  0x1c101000,
  0x00820000,
  0x00000000,
  0x00001000,
  0x01011000,
  0x08011000,
  0x00011000,
  0x00011000,
  0x04001000,
  0x00801000,
  0x00010f98,
  0x00010002,
  0x00010002,
  0x00007f02,
  0x00000082,
  0x00000080,
  0x0000003c,
  0x00000000,
};

/* The active maps for the evalProgs to use */
RAM UINT32    <FONT COLOR="#00a000">map[MAXPAR][GRIDX]<FONT COLOR="#202020">;

/* Init the maps from the initialMap */
macro proc initMap(C_UINT i)
{
    unsigned int <FONT COLOR="#008080">p<FONT COLOR="#202020">;
    Bool     <FONT COLOR="#0040d0">done<FONT COLOR="#202020">;

    p = 0;
    <FONT COLOR="#008080">do {
        map[i][p]=initialMap[p];
        PAR {
	        p++;
            done = (p == 31);
        }
    } while(!done)<FONT COLOR="#202020">;
}
#endif

/*
* Define some control variables
*/
#if !defined HANDELC
Bool tree   = 0;   /* If true then print program tree */
Bool newseed= 0;   /* If true then ANSI_C version will generate seed */
#endif
Bool stopon = 0;   /* If true then stop if 100% correct prog */

UINT8 nbreed, nxover, ncopy, nmutate, nrand;

Phase <FONT COLOR="#008080">phBreed<FONT COLOR="#202020">;
Phase <FONT COLOR="#008080">phEval<FONT COLOR="#202020">;
Phase <FONT COLOR="#008080">phWriteback<FONT COLOR="#202020">;
unsigned char good = 0;
int   dumpProg     = 0;
int   dumpFittest  = 0;
int   dumpLengths  = 0;
int   verbose      = 0;
int   dumpFitlen   = 0;

/* 
 * Generic GP  function prototypes 
 */
macro proc initPop();
macro proc writeBack();
//macro proc writeBackInd(C_UINT phase, C_UINT ind);
//macro proc readIn(C_UINT i, C_UINT ind);
void readIn(PopIndex, WorkIndex);
macro proc findBest(C_UPTR best);
macro proc RandomGen();
macro proc evalProg(C_UINT indx);
macro proc CycleCount();

/*
 * output channel
 */
#ifdef HANDELC
/*chanout stdout;*/
chanout Short logout;
macro proc dooutdata(C_UINT c, C_UINT v)
{
#if DEBUG
	logout ! (Short)c;
	logout ! (Short)v;
#else	
	PP1000WriteStatus(c);
    PP1000WriteStatus(v);
#endif
}
#endif

/********************************************************************
 * Random number generator for Handelc
 *
 * Uses a shift register with taps and feedback
 ********************************************************************/
#ifdef HANDELC
#define RANDWIDTH  32  /* Number of bits in the generator 
                 			This is greater than the biggest number
                 			wanted from the generator*/ 
#endif

#define TAP1       0
#define TAP2       5
#define TAP3       9
#define TAP4       20
#define TAP5       30
#define TAP6       31

 


/* Channel for getting the seed */
#ifdef HANDELC
#ifdef SIMULATE
chanin  RandReg seedIn with {infile = "c:/tmp/seed.dat"};
chanout RandReg randout with {outfile = "c:/tmp/random.dat"};
#endif
#endif
#if defined HANDELC
/***************************************************************************
 * Name:     random
 *
 * Purpose:  Generate a pseudo-random number
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 *
 * Notes:    The number is stored in the static variable randReg
 * 
 ***************************************************************************/
RandReg <FONT COLOR="#00a000">randReg<FONT COLOR="#202020">;    /* The register used for generating the number */
macro proc random()
{
  static unsigned int BITW  <FONT COLOR="#0040d0">oldbit0<FONT COLOR="#202020">;
  unsigned int BITW <FONT COLOR="#0040d0">bit0<FONT COLOR="#202020">;
  par {
    bit0 = <FONT COLOR="#0040d0">randReg[TAP1] ^ 
      randReg[TAP2] ^ 
      randReg[TAP3] ^ 
      randReg[TAP4] ^ 
      randReg[TAP5] ^ 
      randReg[TAP6]<FONT COLOR="#202020">;
    /* Shift by using all bits except top bit and adding bit 0 */
    randReg = randReg[RANDWIDTH-2:0]@oldbit0; 
    oldbit0=bit0;
  }
}

macro proc RandomGen()
{
  <FONT COLOR="#0040d0">while(1) {
    random();
  }<FONT COLOR="#202020">
}

macro proc CycleCount()
{
  <FONT COLOR="#0040d0">while(1) {
    if(running) {
        <A NAME="delay1"><U><FONT COLOR="#f88000">cycles++</U><SUB>64</SUB></A><FONT COLOR="#0040d0">;
    } else {
        delay;
    }
  }<FONT COLOR="#202020">
}

/***************************************************************************
 * Name:     randseed
 *
 * Purpose:  Seed the random number generator
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 * 
 ***************************************************************************/
macro proc randseed()
{
#ifdef SIMULATE
  RandReg  seed;
  seedIn ? seed;
  randReg = seed;
#else
  PP1000RequestMemoryBank(1);
  PP1000ReadBank0(randReg,0);
  PP1000ReleaseMemoryBank(1);
#endif
}

/***************************************************************************
 * Name:     randXXXXX functions
 *
 * Purpose:  Generate random numbers of given widths and limits
 * 
 * Inputs:   None
 *
 * Returns:  A random number of the correct width
 *
 * Notes:    Each function requires 1 clock cycle for the random() call
 * 
 ***************************************************************************/

/* Return a value that is between 0 and MAXPROGLEN */
macro expr randPC() = 0@randReg[PROGW-1:0];

macro expr randLen() = <FONT COLOR="#0040d0">0@randReg[PROGW-1:0]|1<FONT COLOR="#202020">;

macro proc randMethod(method)
{
#define mask1 0x1f
#define mask2 0xfc
#define mask3 (~mask1)
#define mask4 (~mask2)

  UINT8 <FONT COLOR="#008080">v<FONT COLOR="#202020">, <FONT COLOR="#0040d0">v1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">v2<FONT COLOR="#202020">, <FONT COLOR="#0040d0">v3<FONT COLOR="#202020">, <FONT COLOR="#0040d0">v4<FONT COLOR="#202020">;

  v = adju(randReg,8);
  PAR {
    v1 = <FONT COLOR="#0040d0">v&mask1<FONT COLOR="#202020">;
    v2 = <FONT COLOR="#0040d0">v&mask2<FONT COLOR="#202020">;
    v3 = <FONT COLOR="#0040d0">v&mask3<FONT COLOR="#202020">;
    v4 = <FONT COLOR="#0040d0">v&mask4<FONT COLOR="#202020">;
    method = XOVER;   /* Default method */
  }

  /* This long winded code generates shallow logic as 
     compared to a long if-then-else chain */

  /* Only override if we have the less probable cases */
  <FONT COLOR="#00a000">if(!v3&&v1)
    method = MUTATE;
  else 
    delay;<FONT COLOR="#202020">
  <FONT COLOR="#00a000">if(!v4&&v2)
    method =  COPY;
  else 
    delay;<FONT COLOR="#202020">
}

macro expr randPopIndex() = randReg[POPW-1:0];
#endif


macro proc PP1000WriteBank0func(C_UINT addr, C_UINT val)
{
	UINT32 <FONT COLOR="#0040d0">v<FONT COLOR="#202020">;
	
	<FONT COLOR="#008080">do {
    	PP1000WriteBank0(addr, val);
	PP1000ReadBank0(v,addr);
	} while(v != val)<FONT COLOR="#202020">;

}

macro proc PP1000WriteBank1func(C_UINT addr, C_UINT val)
{
	UINT32 <FONT COLOR="#0040d0">v<FONT COLOR="#202020">;
	
	<FONT COLOR="#008080">do {
    	PP1000WriteBank1(addr, val);
	PP1000ReadBank1(v,addr);
	} while(v != val)<FONT COLOR="#202020">;

}


macro proc mutate(C_UINT ind)
{
    Index           address;
    Phase           ph;

    ph = phBreed;
    /* Select an instruction to mutate */
    address = randPC() & adju(WorkingLenRead(ph,ind), IDXW);
    WorkingPopWrite(ph, ind, address, genNode());
#if 0
    printf("MASK = 0x%x\n", (FUNCMASK << (REGBITS+REGBITS)) | (REGMASK << REGBITS) | REGMASK);
    printf("GETOPCODEMASK = 0x%x\n", FUNCMASK << (REGBITS+REGBITS));
    printf("GETEA1MASK = 0x%x\n", (((REGMASK << REGBITS))));
    printf("GETEA2MASK = 0x%x\n", (REGMASK));
#endif
}


/* Copy individual at work index w to work index w+1 
* w is used directly and is always even (bit 0 == 0) and
w+1 is always odd (bit 0 == 1) */
macro proc copyInd(C_UINT w)
{
  Word    val;
  Index_1     count;
  Index       i;
  Phase       ph;
  Bool        done;

  PAR {
    i  = 0;
    count = 0;
    ph = phBreed;
  }

  do {
    WorkingPopRead(ph,w, i, C_ADDR val);
    WorkingPopWrite(ph,w | 1, i, val);
    PAR {
        count++;
        i++;
        done = (count == MAXNODES-1);
    }
  }while(!done);
}

/* Original saturating crossover */
#if defined TRUNCATE
#warning Truncate method selected
macro proc xover(C_UINT w)
{
  Word  val, val2;
  Word  len1;
  Word  len2;
  Word  newlen1, newlen2;
  PC      x1, x2;
  PC      i1, i2;
  Index  idx1, idx2;
  Index  count1, count2;
  Phase    ph;

  ph = phBreed;
  /*
   * Choose two crossover points at random and get the program lengths
   */


  PAR {
    x1 = randPC();
    len1 = WorkingLenRead(ph,w);
  }
  PAR {
    x2 = randPC();
    len2 = WorkingLenRead(ph,w | 1);
  }

	/*
	* Crudely adjust the crossover points so that they lie within the 
	* individual
	*/
  PAR {
#if defined BOOLOP
    x1 &= adju(len1, PROGW);
    x2 &= adju(len2, PROGW);
#else
    x1 %= adju(len1, PROGW);
    x2 %= adju(len2, PROGW);
#endif
}
  /*
  * calculate the starting points for crossover 
  */
  	PAR {
    	i1 = x1;
    	i2 = x2;
	}

  /*
  * Calculate the count of instructions for copying
  * count1 correspnds to individual 1
  */
  PAR {
	count1 = adju(len1, IDXW) - i1;
	count2 = adju(len2, IDXW) - i2;
  }
  /*
   * Copy until both counts have been exhausted
   */
  do {
    PAR {
        idx1 = i1;
        idx2 = i2;
    }
    PAR {
        WorkingPopRead(ph, w, idx1, C_ADDR val);
        WorkingPopRead(ph,w | 1, idx2, C_ADDR val2);
    }
    PAR {
        WorkingPopWrite(ph,w,idx1, val2);
        WorkingPopWrite(ph, w | 1, idx2, val);
    }
	/* 
	* Calculate the counts, but don't let them go below zero 
	* and calculate the next indexes, but don't let them go beyond MAXNODES
	*/
    PAR {
		if(count1) 
			count1--;
        else
            delay;
		if(count2)
			count2--;
        else
            delay;
		if(i1 != MAXPROGLEN-1)
			i1++;
        else
            delay;
		if(i2 != MAXPROGLEN-1)
			i2++;
        else
            delay;
    }
  }while( count1|| count2);
  /*
   * Adjust the lengths - broken into 2 bits to speedup the logic
   */
   PAR {
        newlen1 = adju(x1 + (adju(len2,PROGW)), WORDW);
        newlen2 = adju(x2 + (adju(len1,PROGW)), WORDW);
   }
   PAR {
        newlen1 = newlen1 - adju(x2, WORDW);
        newlen2 = newlen2 - adju(x1, WORDW);
   }
   //   printf("x1=%d x2=%d len1=%d, len2=%d, newlen1=%d, newlen2=%d\n", 
   //	  x1,x2,len1,len2,newlen1,newlen2);
#if defined BOOLOP
    /* Guard against zero length programs whcih are no good at all */
    while(!len1) {
      len1 = randLen();
    }

    while(!len2) {
      len2 = randLen();
    }
#endif

    /* Saturate the sizes to the maximum */
    if(newlen1>MAXNODES-1) newlen1=MAXNODES-1;
    if(newlen2>MAXNODES-1) newlen2=MAXNODES-1;

    PAR {
        WorkingLenWrite(ph, w)     =  newlen1;
        WorkingLenWrite(ph, w | 1) =  newlen2;
    }
}


#elif defined LIMITED
#warning Limiting crossover selected
/* New improved crossover */
macro proc xover(C_UINT w)
{
  Word  <FONT COLOR="#0040d0">val<FONT COLOR="#202020">, <FONT COLOR="#0040d0">val2<FONT COLOR="#202020">;
  Word  <FONT COLOR="#008080">len1<FONT COLOR="#202020">;
  Word  <FONT COLOR="#0040d0">len2<FONT COLOR="#202020">;
  Word  <FONT COLOR="#0040d0">olap1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">olap2<FONT COLOR="#202020">;   
  PC      <FONT COLOR="#00a000">x1<FONT COLOR="#202020">, <FONT COLOR="#00a000">x2<FONT COLOR="#202020">;
  PC      i1, i2;
  Index  <FONT COLOR="#008080">idx1<FONT COLOR="#202020">, <FONT COLOR="#008080">idx2<FONT COLOR="#202020">;
  Index  <FONT COLOR="#008080">count1<FONT COLOR="#202020">, <FONT COLOR="#008080">count2<FONT COLOR="#202020">;
  Phase    <FONT COLOR="#0040d0">ph<FONT COLOR="#202020">;
  Word   <FONT COLOR="#00c000">newlen1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">newlen2<FONT COLOR="#202020">;
  Bool   <FONT COLOR="#00a000">done1<FONT COLOR="#202020">, <FONT COLOR="#00a000">done2<FONT COLOR="#202020">;
  Bool   <FONT COLOR="#0040d0">olapDone1<FONT COLOR="#202020">, <FONT COLOR="#0040d0">olapDone2<FONT COLOR="#202020">;



  ph = phBreed;
  
  <FONT COLOR="#008080">do {
    /*
     * Choose two crossover points at random and get the program lengths
     */
    PAR {
      x1 = randPC();
      len1 = WorkingLenRead(ph,w);
    }
    PAR {
      x2 = randPC();
      len2 = WorkingLenRead(ph,w | 1);
    }

    /*
     * Adjust the crossover points so that they lie within the 
     * individual. This is modulus by remainder.
     */
    PAR <FONT COLOR="#00c000">{
      while(x1>=adju(len1,PROGW)) {
         x1 -= adju(len1,PROGW);   
      }
      while(x2>=adju(len2,PROGW)) {
          x2 -= adju(len2,PROGW);
      }
    }<FONT COLOR="#008080">
    
    /* Get size of new individuals */
    newlen1 = <FONT COLOR="#d0f000">adju(x1, WORDW) + (len2 - adju(x2, WORDW))<FONT COLOR="#008080">;
    newlen2 = <FONT COLOR="#d0f000">adju(x2, WORDW) + (len1 - adju(x1, WORDW))<FONT COLOR="#008080">;

    /* See if the newlens are bigger than MAXNODES-1 */
    olap1 = newlen1 & ~(MAXNODES-1);
    olap2 = newlen2 & ~(MAXNODES-1);
    olapDone1 = !(olap1 == 0);
    olapDone2 = !(olap2 == 0);
#if defined DUALXOVER
#warning DUAL Xover
  } while(olapDone1 || olapDone2);
#else
#warning SINGLE xover
  } while(olapDone1 && olapDone2)<FONT COLOR="#202020">;
#endif
  
  /*
   * calculate the starting points for crossover 
   */
  PAR {
    i1 = x1;
    i2 = x2;
  }
  
  /*
   * Calculate the count of instructions for copying
   * count1 corresponds to individual 1
   */
  PAR {
    <FONT COLOR="#008080">if(!olap1)
      count1 = adju(len2, IDXW) - x2;
    else
      count1 = 0;<FONT COLOR="#202020">
    <FONT COLOR="#008080">if(!olap2) 
      count2 = adju(len1, IDXW) - x1;
    else
      count2 = 0;<FONT COLOR="#202020">
    idx1 = x1;
    idx2 = x2;
  }
  /*
   * Copy until both counts have been exhausted
   */
  <FONT COLOR="#00a000">do {
  	PAR {
		done1 = (count1 == 0);
		done2 = (count2 == 0);
	}
    PAR {
      WorkingPopRead(ph, w, idx1, C_ADDR val);
      WorkingPopRead(ph,w | 1, idx2, C_ADDR val2);
    }
    PAR {
      if(!done1) {
	WorkingPopWrite(ph,w,idx1, val2);
	count1--;
	idx1++;
      }
      if(!done2) {
	WorkingPopWrite(ph, w | 1, idx2, val);
	count2--;
	idx2++;
      }
      }
  }while( count1 || count2)<FONT COLOR="#202020">;
  
  PAR <FONT COLOR="#00a000">{
    if(!olap1)
      WorkingLenWrite(ph, w) =  newlen1;
    if(!olap2)
      WorkingLenWrite(ph, w | 1) =  newlen2;
    }<FONT COLOR="#202020">
}

#else
#error Please specify TRUNCATE or LIMITED crossover
#endif
/***************************************************************************
 * Name:     selection
 *
 * Purpose:  Selects MAXPAR individuals for breeding and copies them from
 *           external SDRAM into working ram
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 *
 * Notes:    Uses the phSelect to index into the required working memory
 *           No attempt is made to see if we overselect an individual.
 *           We only allow individuals that are not in workingPop
 * 
 * 	     The selection is tournament and uses a tournament size of 2.
 * 
 ***************************************************************************/
macro proc selection()
{
  WorkIndex    <FONT COLOR="#008080">w<FONT COLOR="#202020">;
  PopIndex     <A NAME="delay2"><U><FONT COLOR="#f8d000">i</U><SUB>47</SUB></A><FONT COLOR="#202020">, <FONT COLOR="#f8f000">i1<FONT COLOR="#202020">,<A NAME="delay3"><U><FONT COLOR="#f8f000">i2</U><SUB>46</SUB></A><FONT COLOR="#202020">;
  Word         <FONT COLOR="#0040d0">fit1<FONT COLOR="#202020">,<FONT COLOR="#0040d0">fit2<FONT COLOR="#202020">;
  Phase        <FONT COLOR="#0040d0">ph<FONT COLOR="#202020">;
  Word         <FONT COLOR="#00a000">fit<FONT COLOR="#202020">;

#if defined HANDELCXX && !defined DEBUG
    interface fastle(unsigned 1 A_LT_B)
        FastLt(Word A=fit1, Word B=fit2) with {busformat="B<I>"};
#endif

  PAR {
    w = 0;
    ph = phBreed;
  }

  <FONT COLOR="#0040d0">do {
    /* 
     * Find 2 individuals that are not the same and that are not in 
     * workingPop
     */
    <FONT COLOR="#f8f000">do {
      i1 = randPopIndex();
      fit1 = populationFitness[i1];
    } while(populationControl[i1])<FONT COLOR="#0040d0">;

    <FONT COLOR="#f8f000">do {
      i2 = randPopIndex();
      fit2 = populationFitness[i2];
    } while(populationControl[i2] || i1 == i2)<FONT COLOR="#0040d0">;
    /*
     * Choose the one with best fitness. 0 is best!
     */
    i = <FONT COLOR="#00c000">UnsignedLt(fit1, fit2, MAXFITW) ? i1 : i2<FONT COLOR="#0040d0">;
    /*
     * Read it into workingPop and remember the fitness in the parent array
     */
    <FONT COLOR="#00a000">readIn(i,w)<FONT COLOR="#0040d0">;
    fit = adju(<FONT COLOR="#00c000">workingFitness[ph]<FONT COLOR="#0040d0">[w], WORDW);
    workingParentFitness[ph][w] = fit;
    w++;
  }while(LIMIT(w,MAXPAR))<FONT COLOR="#202020">;
}



/***************************************************************************
 * Name:     breed
 *
 * Purpose:  Performs the breeding operations on the working ram pointed to
 *           by phBreed
 *           Once this has finished, there will be MAXPAR new individuals
 *           to evaluate
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 * 
 * Notes:    Since crossover and copy use 2 individuals, we arrange for
 *           all breed operations to operate on 2 individuals.
 *           This means that there are MAXWORK/2 breed operations.
 *           The individuals for breeding have already been placed in pairs
 *           in working memory, at addresses i, i+1
 ***************************************************************************/
macro proc breed()
{
  WorkIndex <FONT COLOR="#0040d0">count1<FONT COLOR="#202020">, count2;
  WorkIndex_1 <FONT COLOR="#0040d0">loop<FONT COLOR="#202020">;
  Method    method;

#if !defined PRESET
    /* Count1 and count2 get incremented twice in the do loop */
  PAR {
    count1 = 0;
    count2 = 0;
    loop   = 0;
  }

  <FONT COLOR="#008080">do {
    /* 
     * Select breed method
     */
    PAR {
        randMethod(C_ADDR method);
        count2++;   /* Now count 2 = count1+1 */
    }
	xover(count1);
	nxover++;
#if 0
    switch(method) {
        case MUTATE:
            mutate(count1);
            PAR {
                mutate(count2);
                nmutate++;
            }
            break;
        case XOVER:
            PAR {
                xover(count1);
                nxover++;
            }
            break;
        default:
            PAR {
                copyInd(count1);
                ncopy++;
            }
            break;
    }
#endif
    loop+=2;
  }while(!BITSET(loop, MAXPAR))<FONT COLOR="#202020">;
#endif
}

/***************************************************************************
 * Name:     replacement
 *
 * Purpose:  Replaces an individual with the newly evaluated individual.
 *
 * Inputs:   The PAR number
 *
 * Returns:  Nothing
 * 
 ***************************************************************************/
macro proc replacement()
{
    /* Decide whether the evaluated individual will replace 
     * the corresponding w'th parent */
    WorkIndex <FONT COLOR="#008080">w<FONT COLOR="#202020">;
    Phase     <FONT COLOR="#008080">ph<FONT COLOR="#202020">;
    Word      <FONT COLOR="#0040d0">myFit<FONT COLOR="#202020">;
    Word      <FONT COLOR="#0040d0">parentFit<FONT COLOR="#202020">;
    Bool      <FONT COLOR="#0040d0">better<FONT COLOR="#202020">;

#if defined HANDELCxx && !defined DEBUG
    interface fastle(unsigned 1 A_LE_B)
        FastLe(Word A=myFit, Word B=parentFit) with {busformat="B<I>"};
#endif

    PAR {
      w = 0;
      ph = phEval;
    }

    <FONT COLOR="#0040d0">do {
        /* See if new individual is better than or the same as it's parent */
        PAR {
            myFit = <FONT COLOR="#00c000">workingFitness[ph]<FONT COLOR="#0040d0">[w];
            parentFit = <FONT COLOR="#008080">workingParentFitness[ph]<FONT COLOR="#0040d0">[w];
        }
        better = UnsignedLe(myFit,parentFit, MAXFITW);
        if(better) {
            delay;   /* 
                      * Yes it is so leave the indicator set 
                      * so it gets written back 
                      */
        } else {
                    /* 
                     * The new program is worse than the worst parent so discard it
                     * by clearing the control bit so it doesn't get written back 
                    */
            populationControl[WorkingprogNumWrite(ph,w)] = 0;
        }
        w++;
    } while(LIMIT(w,MAXPAR))<FONT COLOR="#202020">;
}

/***************************************************************************
 * Name:     evaluate
 *
 * Purpose:  Evaluates the fitness of all individuals in working ram pointed 
 *           to by phEval;
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 * 
 ***************************************************************************/
macro proc evaluate()
{
  int w;

  <FONT COLOR="#0040d0">FORPAR(w=0; w<MAXPAR;w++) {
    evalProg(w);
  }<FONT COLOR="#202020">
}


/***************************************************************************
 * Name:     findBest
 *
 * Purpose:  Locates the best individual in the population
 * 
 * Inputs:   Nothing
 *
 * Returns:  The individual number
 * 
 ***************************************************************************/
macro proc findBest(C_UPTR best)
{
    PopIndex_1      count;
    Word            fit, bestf;

    PAR {
        bestf = -1;
        count = 0;
    }

    do {
        fit = populationFitness[adju(count, POPW)];
        if(UnsignedLt(fit, bestf, MAXFITW)){
            bestf = fit;
            C_PTR best  = adju(count, POPW);
        } else {
	        delay;
        }
        count++;     
    } while(!BITSET(count,POPSIZE));
}


macro proc donl()
{
#if !defined HANDELC
  printf("\n");
#endif
}

/***************************************************************************
 * Name:     printInstruction
 *
 * Purpose:  Prints the given program to the output channel
 * 
 * Inputs:   Nothing
 *
 * Returns:  The individual number
 * 
 ***************************************************************************/
macro proc printInstruction(C_UINT word)
{
  printf("0x%x ", word);
  dooutdata(FUNC,adju(GetOpcode(word),8));
  dooutdata(EA1,adju(GetEa1(word),8));
  dooutdata(EA2,adju(GetEa2(word),8));
  donl();
}

macro proc printProg(C_UINT idx)
{
  WorkIndex w;
  Index i;
  Word word;
  PopIndex prog;
  Index_1  len;
  Index_1 count;  /* We rely on the use of a carry into bit 
		     IDXW+1 to detect the end of the loop */

  PAR {
    w = 0;
    i = 0;
  }
  readIn(idx,w);

  prog = WorkingprogNumRead(phBreed,w);
  dooutdata(IND, adju(prog,8));
  donl();
  word = adju(WorkingFitnessRead(phBreed,w), WORDW);
  dooutdata(FIT, adju(word,8));
  donl();
  len = adju(WorkingLenRead(phBreed,w), IDXW+1);
  dooutdata(LEN, adju(len,8));
  donl();
  count = MAXNODES - len;

  while(!BITSET(count, MAXNODES)) {  /* Guard against zero length programs */
    WorkingPopRead(phBreed,w,i, C_ADDR word);
	i = i + 1;
    printInstruction(word);
    count++;
  }
#if defined ANT && !defined HANDELC
  {
    FILE    *df;
   
    if((df=fopen("trail.dat", "w")) == NULL ) {
      perror("Creating ant trail file");
      df = stdout;
    }
    for(i=0;i<len;i++) {
      WorkingPopRead(phBreed,w,i,C_ADDR word);
      printf("%d %d %d\n", GetOpcode(word), GetEa1(word), GetEa2(word));
      fprintf(df, "%d %d %d\n", GetOpcode(word), GetEa1(word), GetEa2(word));
    }
    if(df) fclose(df);
  }
#endif
}

macro proc printStats()
{
  dooutdata(NMUTATE, nmutate);
  dooutdata(NXOVER, nxover);
  dooutdata(NCOPY, ncopy);
}

macro proc printGen(C_UINT gen)
{
  dooutdata(GEN, gen);
}


<FONT COLOR="#0040d0">void dumpResults()
{
    MainPopIndex   <FONT COLOR="#008080">page0<FONT COLOR="#0040d0">;
    MainPopIndex   <FONT COLOR="#008080">page1<FONT COLOR="#0040d0">;
    MainPopIndex   <FONT COLOR="#008080">page2<FONT COLOR="#0040d0">;
	MainPopIndex   <FONT COLOR="#008080">addr<FONT COLOR="#0040d0">;
	UINT32         <FONT COLOR="#008080">val<FONT COLOR="#0040d0">;
    PopIndex_1     <FONT COLOR="#00c000">idx<FONT COLOR="#0040d0">;
    Word           <FONT COLOR="#008080">fit<FONT COLOR="#0040d0">, <FONT COLOR="#008080">len<FONT COLOR="#0040d0">;
	Bool           <FONT COLOR="#008080">done<FONT COLOR="#0040d0">;

    PP1000RequestMemoryBank(2);
    PAR {
        idx      = 0;
        page0    = 0;
        page1    = POPSIZE;
        page2    = POPSIZE*2;
    }
	addr = page0 | 1;
    PP1000WriteBank1func(addr, GENSIZE);
	addr = page0 | 2;
    PP1000WriteBank1func(addr, GENERATIONS);
	addr = page0 | 3;
    PP1000WriteBank1func(addr, MAXPAR);
	addr = page0 | 4;
    PP1000WriteBank1func(addr, MAXPROGLEN);
	addr = page0 | 5;
    PP1000WriteBank1func(addr, PROBLEMTYPE);
	addr = page0 | 6;
    PP1000WriteBank1func(addr, cycles);
	addr = page0 | 7;
    PP1000WriteBank1func(addr, POPSIZE);
    <FONT COLOR="#008080">do { 
        PAR {
            fit = populationFitness[adju(idx,POPW)];
            len = populationLen[adju(idx,POPW)];
        }
		PAR {
			addr = page1 | adju(idx, SRAMW);
			val  = adju(fit,32);
		}
        PP1000WriteBank1func(addr, val);
		PAR {
			addr = page2 | adju(idx, SRAMW);
			val  = adju(len,32);
		}
        PP1000WriteBank1func(addr, val);
		done = (idx == POPSIZE-1);
        <FONT COLOR="#00c000">idx++<FONT COLOR="#008080">;        
    }while(!done)<FONT COLOR="#0040d0">;
    PP1000ReleaseMemoryBank(2);
}<FONT COLOR="#202020">

<FONT COLOR="#00c000">void printLengths(Generation generation)
{
#if !defined HANDELC
  if(dumpLengths && generation % (POPSIZE/(MAXPAR)) == 0) {
    int i;
    
    for(i=0;i<POPSIZE;i++) {
      printf("%d ", populationLen[i]);
    }
    printf("\n");
  }
#endif
}<FONT COLOR="#202020">

/***************************************************************************
 * Name:     main
 *
 * Purpose:  The main function
 * 
 * Inputs:   nothing
 *
 * Returns:  nothing
 * 
 * Note:     
 *
 ***************************************************************************/
<FONT COLOR="#0040d0">MAINTYPE main MAINARGS
{
  /* Control variables to drive pipeline */
  Bool          <FONT COLOR="#008080">doEval<FONT COLOR="#0040d0">;
  Bool          <FONT COLOR="#40f000">selectionDone<FONT COLOR="#0040d0">;
  Generation_w  <FONT COLOR="#40f000">generation<FONT COLOR="#0040d0">;
  PopIndex      best;
#if defined HANDELC
  UINT8         ctrl;
#endif
  Bool evalDone;
  
  evalDone = 0;

#if !defined HANDELC && !defined PSIM
  if(argc >1) {
    int a = 1;
    do {
      if(strcmp(argv[a], "-s") == 0) {
    	newseed = 1;
      }
      else if(strcmp(argv[a], "-p") == 0) {
	dumpProg = 1;
      }
      else if(strcmp(argv[a], "-f") == 0) {
	dumpFittest = 1;
      }
      else if(strcmp(argv[a], "-l") == 0) {
	dumpLengths = 1;
      }
      else if(strcmp(argv[a], "-v") == 0) {
	verbose = 1;
      } 
      else if(strcmp(argv[a], "-t") == 0) { 
	dumpFitlen = 1;
      } else {
	printf("Usage: %s [-s] [-p] [-f]\n", argv[0]);
	printf("\t-s set the random number seed from the clock\n");
	printf("\t-p dump the best program at the end\n");
	printf("\t-f dump the value of the fittest program once per generation\n");
	printf("\t-l dump the program lengths for each generation\n");
	printf("\t-v print verbose debug information\n");
	printf("\t-t print the lengths of programs that are 100%% fit\n");
	exit(1);
      }
      a++;
    } while(a < argc);
  }
  stopon=1;
#endif

  /* Wait for the host to tell us to start */
  PP1000ReadControl(ctrl);

  /* Initialise variables etc */
  PAR {
    phBreed     = 0;
    phEval      = 1;   /* Delayed by one pass so starts at 1 */
    doEval      = 0;
    generation  = 0;
    cycles      = 0;
    randseed();
  }

  PP1000RequestMemoryBank(1);
  PP1000WriteStatus(1);
  running = 1;
  PAR {

    /* Count cycles */
    CycleCount();

    /* Run the random number generator */
    RandomGen();


    SEQ {
      /* Build the initial population */
      initPop();   /* Uses phase 0 */
      <FONT COLOR="#40f000">printLengths(0)<FONT COLOR="#0040d0">;
    
      /* 
       * Run the main pipeline. This will process MAXPAR individuals per pass
       * A generation is done when POPSIZE/MAXPAR individuals have been done
       * so the total number of passes is GENSIZE = GENERATONS * (POPSIZE/MAXPAR) 
       */
        <FONT COLOR="#40f000">do {
             selectionDone = 0;
	         PAR {
 		        	/* The selection block */
		   SEQ {
		     phWriteback = phBreed;   /* Write back this phase before we overwrite it */
		     writeBack();   
		     selection();  
		     selectionDone = 1;      
		     breed();
		     doEval=1;
		   }


            	  /* The eval block (only starts when we have done the 1st breed) */
	            SEQ {
	                if(doEval) {
#if defined NOFITNESS
#warning No fitness selected
#else
			  evaluate();
			  evalDone=1;

#endif
			  /*
			   * Now wait until selection() has finished with the 
			   * global fitness and population and perform the replacement
			   */
                        WAIT(selectionDone);
                        replacement();
	                } else delay;
	            } /* SEQ for eval block */
	        } /* PAR for main loop */
#if !defined HANDELC
		 if(dumpFittest && generation % (POPSIZE/MAXPAR) == 0) {
		   findBest(C_ADDR best);
		   printf("%d\n", populationFitness[best]);
		 }
		 printLengths(generation);
#endif
            PAR {
	        generation++;
                TOGGLE(phBreed);
                TOGGLE(phEval);
            }
	    //			printGen(adju(generation,8));
      } while(!BITSET(generation, GENSIZE))<FONT COLOR="#0040d0">;
      phWriteback = phBreed;
      writeBack();    /* Write the last evaluated individuals */

      /* Tell the cycle counter to stop */
      running = 0;
#if !defined HANDELC
      if(dumpProg) {
	findBest(C_ADDR best);
	printProg(best);
      }
      if(dumpFitlen) {
	int f;
	int l;

	findBest(C_ADDR best);
	readIn(best,0);
	if((f=WorkingFitnessRead(phBreed,0)) == 0) {
	  l = WorkingLenRead(phBreed,0);
	  printf("%d\n", l);
	}
      }
#endif
      PP1000ReleaseMemoryBank(1);

      /* Write the lengths and fitnesses to the sram */
      <FONT COLOR="#008080">dumpResults()<FONT COLOR="#0040d0">;

      /* Release all banks and signal that we have finished */
      PP1000WriteStatus(good);
      
      /*
       * This marks the end of the GP algorithm.
       * The machine will still be running the random number
       * generator and the cycle counter(s) however until 
	   * the machine is reset
       */        
    } /* SEQ */
  } /* par */
  MAINRET;
}<FONT COLOR="#202020">


/***************************************************************************
 * Name:     makeProg
 *
 * Purpose:  Make an individual program.
 * 
 * Inputs:   The phase to write to (1st index into block select ram )
 *           The individual number within the phase (2nd index into ram )
 *
 * Returns:  Nothing
 *
 * Notes:    We generate the maximal number of instructions regardless
 *           of the actual length to simplify the logic. It is not an expensive
 *           operation in the general scheme of things.
 * 
 ***************************************************************************/
macro proc makeProg() 
{ 
    PC        <FONT COLOR="#00c000">proglen<FONT COLOR="#202020">;
    Proglen_1 <FONT COLOR="#00a000">icount<FONT COLOR="#202020">;
    Index     <FONT COLOR="#008080">i<FONT COLOR="#202020">;
    Phase     <FONT COLOR="#00c000">zero<FONT COLOR="#202020">;
    static PopIndex <FONT COLOR="#0040d0">progNum<FONT COLOR="#202020"> = 0;

#if defined PRESET
#if defined ANT
    zero = 0;
    WorkingLen(zero,0) = 12;
    WorkingFitness(zero,0) = DEFAULT_FITNESS;
    WorkingprogNum(zero,0) = progNum;
    populationControl[progNum]= 1;
    progNum++;
    WorkingPopWrite(zero,0,0,0x07);
    WorkingPopWrite(zero,0,1,0x1c);
    WorkingPopWrite(zero,0,2,0x11);
    WorkingPopWrite(zero,0,3,0x07);
    WorkingPopWrite(zero,0,4,0x14);
    WorkingPopWrite(zero,0,5,0x12);
    WorkingPopWrite(zero,0,6,0x0b);
    WorkingPopWrite(zero,0,7,0xc);
    WorkingPopWrite(zero,0,8,0xc);
    WorkingPopWrite(zero,0,9,0xe);
    WorkingPopWrite(zero,0,10,0x19);
    WorkingPopWrite(zero,0,11,0xe);
#elif defined BOOLPARITY
    zero = 0;
    WorkingLenWrite(zero,0) = 8;
    WorkingFitnessWrite(zero,0) = DEFAULT_FITNESS;
    WorkingprogNumWrite(zero,0) = progNum;
    populationControl[progNum]= 1;
    progNum++;
    WorkingPopWrite(zero,0,0,0x33);
    WorkingPopWrite(zero,0,1,0x2f);
    WorkingPopWrite(zero,0,2,0x2f);
    WorkingPopWrite(zero,0,3,0x2f);
    WorkingPopWrite(zero,0,4,0x0);
    WorkingPopWrite(zero,0,5,0x2f);
    WorkingPopWrite(zero,0,6,0x18);
    WorkingPopWrite(zero,0,7,0x18);
#else
#error No preset data for this problem type
#endif
#else

    /* 
    * Determine initial program length. We ensure that this is greater than 0 
    */
    PAR {
      proglen = randLen();
      zero = 0;
    }
    /*
     * Initialise the program in block select memory 
     * Dont try to optimise the number of nodes to be the length
     * as this will add extra logic.
     */
    PAR {
        WorkingLenWrite(zero,0)       = adju(proglen, WORDW);
        WorkingFitnessWrite(zero,0)   = DEFAULT_FITNESS;
	WorkingprogNumWrite(zero,0)   = progNum;
    	i = 0;
	icount = 0;
        populationControl[progNum]= 1;  /* Signal that this should 
		                    			   get written */
	<FONT COLOR="#00c000">progNum++<FONT COLOR="#202020">;
	}

    <FONT COLOR="#008080">do  {
        WorkingPopWrite(zero, 0, i, genNode());
	    PAR {
	        i++;
	        icount++;
	    }
    } while(!BITSET(icount, MAXPROGLEN))<FONT COLOR="#202020">;
#endif
}



/***************************************************************************
 * Name:     writeBackInd
 *
 * Purpose:  Writes an individual back to external SRAM from on-chip
 *           block select ram.
 * 
 * Inputs:   The phase to use (1st index into ram arrays)
 *           The individual number (2nd index into ram arrays )
 *
 * Returns:  Nothing
 * 
 * Note:     The address to write to is calculated by taking the 
 *           individual number and multiplying by the program size.
 *           The instructions are packed into WORDLEN bit words to make memory
 *           access more efficient.
 *           The individual is not written back if it does not have it's
 *           control bit set.
 ***************************************************************************/
<FONT COLOR="#008080">void writeBackInd(Phase phase, WorkIndex ind)
{
    MainPopIndex <FONT COLOR="#f8f000">address<FONT COLOR="#008080">, addr;
    Index     <FONT COLOR="#f8f000">j<FONT COLOR="#008080">,<FONT COLOR="#f8f000">k<FONT COLOR="#008080">;
    PopIndex  num;
    Word f,n, word;
    UINT32  val;
    Bool   done, done2;

    num = adju(WorkingprogNumRead(phase,ind), POPW);

    <FONT COLOR="#f8f000">if(!populationControl[num]) {
        delay;
    } else {          
        PAR {
            indexToAddr(num, address);
            j = 0;
            k = 0;
            done = 0;
        }
            SEQ {
                populationControl[num] =0;
		f = WorkingFitnessRead(phase, ind);
		n = WorkingLenRead(phase, ind);
                populationFitness[num] = f;
                populationLen[num] = n;
            }


            do  {
				SEQ {
                	word = WorkingPopGet(phase,ind,j);
                	val  = adju(word,BIT32);
                	addr = address | adju(j, SRAMW);
//					delay;
#if defined HANDELC
                	PP1000WriteBank0func(addr , 0@word);
#else
                	PP1000WriteBank0func(addr , word);
#endif
                	PAR {
                    	done2 = (k == MAXNODES-1);
                    	j++;
                    	k++;
                	}
				}
            } while(!done2);
    }<FONT COLOR="#008080">
}<FONT COLOR="#202020">

/***************************************************************************
 * Name:     readIn
 *
 * Purpose:  Reads an individual from external SRAM
 * 
 * Inputs:   i   = The individual number in the main population
 *           ind = The individual in working ram
 *
 * Returns:  Nothing
 * 
 * Note:     The address to write to is calculated by taking the 
 *           individual number and multiplying by the program size
 *           The individual is marked as being in workingPop
 ***************************************************************************/
<FONT COLOR="#008080">void readIn(PopIndex i, WorkIndex ind)
{
    MainPopIndex  address;
	MainPopIndex  addr2;
    UINT32        val;
    Index_1       <FONT COLOR="#00a000">j<FONT COLOR="#008080">;
    Word          f,n;
    Phase         ph;
    Bool          done;

    PAR {
        indexToAddr(i, address);
        j = 0;
	    ph = phBreed;
        done = 0;
    }
        SEQ {
            populationControl[i]=1;
            f = populationFitness[i];
            n = populationLen[i];
	        WorkingFitnessWrite(ph, ind) = f;
	        WorkingLenWrite(ph, ind) = n;
	        WorkingprogNumWrite(ph, ind) = adju(i, POPW);
        }

        do {
		    addr2 = address|adju(j,SRAMW);
                PP1000ReadBank0(val, addr2);
                WorkingPopWrite(ph,ind,adju(j, IDXW), adju(val, WORDW));
                PAR {
                    j++;
                    done = (j == MAXNODES-1);
            }
        } while(!done);
}<FONT COLOR="#202020">

/***************************************************************************
 * Name:     initPop
 *
 * Purpose:  Initialise the population
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 * 
 * Note:     Side effect is to construct the programs in external SRAM
 *           The programs are built in the block ram first then copied to the
 *           external SRAM.
 *           The fitness of the built programs is evaluated as part of this
 *           before they are written back so that we start with a full set
 *           of fitness cases
 *           Two of the block select rams are used for the different phases
 *           which ensures that we don't break the rule about reading/writing
 *           to a block select ram more than once per clock cycle.
 ***************************************************************************/
macro proc initPop()
{
  PopIndex_1 <FONT COLOR="#00c000">idx<FONT COLOR="#202020">;
    
  idx      = 0;
  
  <FONT COLOR="#00c000">do {
      makeProg();
      PAR {
	    writeBackInd(0, 0);
        idx++;
      }
  } while(!BITSET(idx, POPSIZE))<FONT COLOR="#202020">;
}

/***************************************************************************
 * Name:     writeBack
 *
 * Purpose:  Writes all individuals in working ram pointed to by phWriteback
 *           out to external RAM, and clears the inwork bit for all
 *           individuals still in workingPop.
 * 
 * Inputs:   Nothing
 *
 * Returns:  Nothing
 * 
 ***************************************************************************/
macro proc writeBack()
{
    WorkIndex <FONT COLOR="#00a000">w<FONT COLOR="#202020">;
    
    w = 0;
    <FONT COLOR="#0040d0">do {
        <FONT COLOR="#00a000">writeBackInd(phWriteback, w)<FONT COLOR="#0040d0">;
        w++;
    } while(LIMIT(w,MAXPAR))<FONT COLOR="#202020">;
}


#if !defined HANDELC
/*************************************************************************** 
 * iso-c stubs for PP1000 and macro expression/procs
 **************************************************************************/
char * stoi(int v)
{
  static char b[10];
  sprintf(b, "%d", v);
  return b;
}

Word sram[4][POPSIZE*MAXNODES]; /* 4 banks */
Word READRAM(unsigned bank, unsigned long addr)
{
  return sram[bank][addr];
}

void WRITERAM(unsigned bank, unsigned addr, unsigned val)
{
  sram[bank][addr] = val;
}

/*
 * Random number routines for a regular ANSI-C system
 */
FILE *randlog;

RandReg randReg;    /* The register used for generating the number */
RandReg   s_random_lfsr(void)
{
 unsigned int BITW bit0;
 RandReg  t1, t2, t3, t4, t5, t6;
 t1 = !!(randReg & (1LL<<TAP1));
 t2 = !!(randReg & (1LL<<TAP2));
 t3 = !!(randReg & (1LL<<TAP3));
 t4 = !!(randReg & (1LL<<TAP4));
 t5 = !!(randReg & (1LL<<TAP5));
 t6 = !!(randReg & (1LL<<TAP6));
 bit0 = t1^t2^t3^t4^t5^t6;
 randReg <<= 1;
 randReg |= bit0;
 nrand++;
 return randReg;
}

#ifdef LFSR_16
RandReg s_random(void)
{
  int i;

  for(i=0;i<15;i++) {
    s_random_lfsr();
  }
  return s_random_lfsr();
}
#elif defined CA_16
typedef  unsigned long Rbits;

#define  BMAX ((sizeof(Rbits)*8)-1)
#define  BIT_P1(b) (b==BMAX?0:(b+1))
#define  BIT_M1(b) (b==0?BMAX:(b-1))
#define  BIT(v,n)  (!!(v&(1<<n)))
#define  SBIT(v,n,b) (b ? (v|=(1<<n)):(v&=(~(1<<n))))
#define CABIT(ca,bit) ((BIT(ca,BIT_P1(bit))|BIT(ca,bit))^BIT(ca,BIT_M1(bit)))

RandReg s_random(void)
{
  static Rbits v1 = 0x8000;
  Rbits  v2;
  Rbits  r;
  int i;


  v2 = 0;

  for(i=0;i<=BMAX;i++) {
    int m;
    int e,w,x;
    e=BIT(v1,BIT_M1(i));
    w=BIT(v1,BIT_P1(i));
    x=BIT(v1,i);
    m = CABIT(v1,i);
    SBIT(v2,i,CABIT(v1,i));
  }
  r=v1;
  v1=v2;
  return r;
}
#elif defined CONGRNG
RandReg s_random()
{
  return rand();
}
#elif defined SEQRNG
RandReg s_random()
{
  return randReg++;
}
#elif defined SPARSE
RandReg s_random()
{
  static r = 2;
  r+=2;
  return r & 0xfffffff0;
}
#elif defined TRUERAND
RandReg s_random()
{
  static int fd = -1;
  unsigned long v;

  if(fd==-1) {
    fd = open("10megs-random.1", O_RDONLY);
    if(fd == -1) {
      perror("Opening random number file");
      exit(1);
    }
    lseek(fd, randReg%1000000, SEEK_SET);
  }
  read(fd, &v, sizeof v);
  return v;
}
#else
RandReg s_random()
{
  return s_random_lfsr();
}
#endif
void RandomGen(void)
{
}

void CycleCount(void)
{
}

void randseed(void)
{
#if !defined PSIM
	FILE *fp;
	time_t t;
	struct timeval tv;
	struct timezone tz;

	gettimeofday(&tv, &tz);
	t = time(NULL);
	t = tv.tv_usec + tv.tv_sec;
	if(newseed) {
		fp=fopen(RANDFILE, "w");
		if(fp) {
		  fprintf(fp, "%lu", t);
		  randReg = t;
		} else {
		  randReg=t;
		}
	} else {
		fp=fopen(RANDFILE, "r");
		if(fp) {
		  fscanf(fp, "%d", &randReg); 
		} else {
		  randReg = time(NULL);
		}
	}
	if(fp) fclose(fp);
	if(verbose && !tree) {
	  printf("SEED=%d\n", randReg);	
	}
	randlog=fopen(RANDLOG, "w");
	srand(randReg);
#else
	randReg = 260158;
#endif
}

PC randPC()
{
  return s_random() % MAXPROGLEN;
}

/* Return a non-zero program length */
PC randLen()
{
  PC r = 0;
  do {
    r = randPC();
  }while(r==0);
  return r;
}

void randMethod(Method *method)
{
  static const UINT8 mask1 = 0x1f;
  static const UINT8 mask2 = 0xfc;
  UINT8 mask3;
  UINT8 mask4;
  UINT8 v, v1, v2, v3, v4;

  PAR {
    v = s_random() & 0xff;
    mask3 = ~mask1;
    mask4 = ~mask2;
  }

  PAR {
    v1 = v&mask1;
    v2 = v&mask2;
    v3 = v&mask3;
    v4 = v&mask4;
  }
  if(!v3&&v1)
    *method = MUTATE;
  else if(!v4&&v2)
    *method = COPY;
  else
    *method = XOVER;
}

PopIndex randPopIndex()
{
  return s_random() % POPSIZE;
}

/***************************************************************************
 * Name:     decodeTerm
 *
 * Purpose:  Print a term for the ant problem
 * 
 * Inputs:   The term number
 *
 * Returns:  a pointer to static data describing the term 
 *
 ***************************************************************************/
#if !defined HANDELC
char * decodeTerm(int t)
{
  static char * termTab[] = {
    "Left", 
    "Right",
    "Move", 
    "Nop",
  };

  if(t<0 || t>3)
    return "Unknown";
  else
    return termTab[t];
}
#endif

void dooutdata(int v1, int v2)
{
  char * vs1 = "";
  char * vs2 = "";
  static  char buf[100];

  switch(v1) {
  case LEN:
    vs1 = "Length";
    vs2 = stoi(v2);
    break;
  case GEN:
    vs1 = "Generation";
    vs2 = stoi(v2);
    break;
  case IND:
    vs1 = "Individual";
    vs2 = stoi(v2);
    break;
#if XOR
  case FUNC:
    vs2 = "";
    switch(v2) {
    case AND:
      vs2="AND";
      break;
    case OR:
      vs2="OR";
      break;
    case NAND:
      vs2="NAND";
      break;
    case NOR:
      vs2="NOR";
      break;
    default:
      sprintf(buf, "Unkown Opcode");
      break;
    }
    vs1 = "FUNC";
    break;
 case EA1:
   vs1 = "Ea1";
   vs2 = stoi(v2);
   break;
 case EA2:
   vs1 = "Ea2";
   vs2 = stoi(v2);
   break;
 case K:
   vs1 = "K";
   vs2 = stoi(v2);
   break;
#endif
#if BOOLPARITY
  case FUNC:
    vs2 = "";
    switch(v2) {
    case AND:
      vs2="AND";
      break;
    case OR:
      vs2="OR";
      break;
    case NOR:
      vs2="NOR";
      break;
    case NAND:
      vs2="NAND";
      break;
    default:
      sprintf(buf, "Unkown Opcode");
      break;
    }
    vs1 = "FUNC";
    break;
 case EA1:
   vs1 = "R";
   vs2 = stoi(v2);
   break;
 case EA2:
   vs1 = "R";
   vs2 = stoi(v2);
   break;
#endif
#if ANT
  case FUNC:
    vs2 = "";
    switch(v2) {
    case IF_FOOD:
      vs2 = "IF_FOOD";
      break;
    case PROGN2:
      vs2 = "PROGN";
      break;
    default:
      sprintf(buf, "Unknown opcode %d\n", v2);
      vs2=buf;
      vs1="Func";
    }
    break;
 case EA1:
   vs1 = "";
   vs2 = decodeTerm(v2);
   break;
 case EA2:
   vs1 = "";
   vs2 = decodeTerm(v2);
   break;
#endif
 case FIT:
   vs1 = "Fitness";
   vs2 = stoi(v2);
   break;
  case INIT:
    vs1 = "InitPop";
    vs2 = stoi(v2);
    break;
  case NMUTATE:
    vs1="Mutate";
    vs2=stoi(v2);
    break;
  case NXOVER:
    vs1="Crossover";
    vs2=stoi(v2);
    break;
  case NCOPY:
    vs1="Copy";
    vs2=stoi(v2);
    break;
 default:
   sprintf(buf,"Unknown op (%d)", v1);
   vs1 = buf;
   vs2 = stoi(v2);
   break;
  }
  printf("%s %s ",vs1, vs2);
}

void     WorkingPopWrite(unsigned int a, unsigned int b, unsigned int c, unsigned int v)
{
  workingPop[a*b][c]=v;
}

void     WorkingPopRead(unsigned int a, unsigned int b, unsigned int c, unsigned int *  v)
{
  *v = workingPop[a*b][c];
}

Word     WorkingPopGet(unsigned int a, unsigned int b, unsigned int c)
{
  return workingPop[a*b][c];
}
 
#endif

/*************************************************************************
 * fitness functions
 ************************************************************************/
#if defined XOR
/***************************************************************************
 * Name:     evalProg
 *
 * Purpose:  Runs a program for an individual
 * 
 * Inputs:   The phase index
 *           the population index (individual)
 *
 ***************************************************************************/
macro proc evalProg(C_UINT indx_in)
{
  Index       pc;   /* Index into words of instructions */
  Index_1     counter;
  Register    ea1, ea2,r;
  Bool        regs[MAXREGS]; 
  Register    i;
  Opcode      opcode;
  Bool        res;
  Word        fit;
  Bool        done;
  Word        word;
  WorkIndex   indx;
  Fcase       curFit;
  Bool        done;
  Phase       ph;



/*
* Per-run initialisation
*/

  WorkingFitnessWrite(phEval,indx) = DEFAULT_FITNESS;
  curFit = 0;

    do {
  /*
   * Per-fitness case initialisation.
   * All done in 1 cycle for Handelc
   * a) Zero the register set
   * b) copy the input parameters
   * c) Set up control variables
   */
  PAR {
    i=0;
    FORPAR (r=2; r < MAXREGS; r++ ) {
      regs[r] = 0;
    }
    regs[0] = BIT0(curFit);
    regs[1] = BIT1(curFit);
    res     = BIT0(curFit) ^ BIT1(curFit);
    pc      = 1;
    counter = MAXNODES - adju(WorkingLenRead(phEval,indx),IDXW_1);
    fit     = WorkingFitnessRead(phEval,indx);
    done    = 0;
    word    = WorkingPopGet(phEval, indx, 0);
    indx    = indx_in;
  }

    do {
      /* Decode the instruction and maintain the counters */
      PAR {
        counter++;
	    ea1 = GetEa1(word);
	    ea2 = GetEa2(word);
	    opcode = GetOpcode(word);
        word = WorkingPopGet(phEval, indx, pc);
        pc++;
        done = (counter == MAXNODES-1);
      }
  
      switch(opcode) {
      case AND:
	    regs[ea1] &= (regs[ea2]);
	    break;
      case OR:
	    regs[ea1] |= regs[ea2];
	    break;
      case NAND:
	    regs[ea1]  = !(regs[ea1] & regs[ea2]);
	    break;
      case NOR:
	    regs[ea1] = !(regs[ea1] | regs[ea2]);
	    break;
      }  /* switch */
    } while(!done);
    /*
     * Calculate the new raw fitness
     */
    if(regs[r0] == res ) {
      fit--;
      WorkingFitnessWrite(phEval,indx) = fit;
    } else {
      delay;
    }

    PAR {
        done = (curFit == MAXFITNESS-1);
        curFit++;
    }
    } while(!done);
}
#endif


#if defined ANT
/***************************************************************************
 * Name:     evalProg
 *
 * Purpose:  Runs a program for an individual
 * 
 * Inputs:   The population index (individual)
 *
 * Returns:  Nothing
 * 
 ***************************************************************************/
macro proc evalProg(C_UINT indx)
{
  Index       <FONT COLOR="#008080">pc<FONT COLOR="#202020">;
  Index       <FONT COLOR="#008080">len<FONT COLOR="#202020">;
  Index_1     <FONT COLOR="#00a000">counter<FONT COLOR="#202020">;
  Opcode      <FONT COLOR="#008080">opcode<FONT COLOR="#202020">;
  Direction   <FONT COLOR="#008080">dir<FONT COLOR="#202020">;
  Pos         <FONT COLOR="#00a000">x<FONT COLOR="#202020">;
  Pos         <FONT COLOR="#00a000">y<FONT COLOR="#202020">;
  Pos         <FONT COLOR="#008080">ax<FONT COLOR="#202020">, <FONT COLOR="#008080">ay<FONT COLOR="#202020">;
  Food        <FONT COLOR="#00a000">food<FONT COLOR="#202020">;
  Food        <FONT COLOR="#d0f000">uneaten<FONT COLOR="#202020">;
  Time        <FONT COLOR="#00c000">timeval<FONT COLOR="#202020">;
  Register    <FONT COLOR="#008080">ea1<FONT COLOR="#202020">, <FONT COLOR="#008080">ea2<FONT COLOR="#202020">;
  Register    <FONT COLOR="#40f000">eas[2]<FONT COLOR="#202020">;
  Bool        <FONT COLOR="#40f000">flags[2]<FONT COLOR="#202020">;
  Bool        <FONT COLOR="#00c000">e<FONT COLOR="#202020">;
  Bool        <FONT COLOR="#0040d0">foodHere<FONT COLOR="#202020">;
  Bool        <FONT COLOR="#008080">timeleft<FONT COLOR="#202020">;
  Bool        <FONT COLOR="#008080">foodleft<FONT COLOR="#202020">;
  Word        <FONT COLOR="#00c000">word<FONT COLOR="#202020">;
  Phase       <FONT COLOR="#008080">ph<FONT COLOR="#202020">;


  /*
   * Per run initialisation
   */
  initMap(indx);

  /*
   * Initialisation.
   * All done in 1 cycle for Handelc
   * a) Zero the register set
   * b) copy the input parameters
   * c) Set up control variables
   */
  PAR {
    ph        = phEval;
    food      = MAXFOOD - FOOD;     /* Start all food to collect */
    uneaten   = FOOD;
    dir       = EAST;        /* Pointing to the right */
    x         = 0;           /* At the first cell */
    y         = 0;
    timeval   = 0;
    pc        = 0;
    len       = adju(WorkingLenRead(phEval,indx),IDXW);
  }
  <FONT COLOR="#008080">do {
      /* Get the 1st word and set up counter. pc is set to 1 for the next get */
      PAR {
        counter = MAXNODES - adju(len, IDXW+1);
	pc = 1;
        word = WorkingPopGet(ph,indx,0);
      }
    do {
      /* Decode the instruction */
      PAR {
	ea1 = GetEa1(word);
	ea2 = GetEa2(word);
	opcode = GetOpcode(word);
	ax=x;
	ay=y;
	word = WorkingPopGet(ph,indx,pc);
	pc++;
	counter++;
      }
	
      switch(opcode) {
      case IF_FOOD:
	switch(dir) {
	case EAST:  ax++; break;
	case WEST:  ax--; break;
	case NORTH: ay--; break;
	case SOUTH: ay++; break;
	default: delay;   break;
	} /* Switch  dir */
	/* Now check the cell 'ahead' */
	<FONT COLOR="#40f000">if(MAP(map, indx, adju((ax&31), 6), ay&31)) {
	  PAR {
	    eas[0] = ea1;
	    flags[0]=1;
	    flags[1]=0;
	  }
	} else {
	  PAR {
	    eas[0] = ea2;
	    flags[0]=1;
	    flags[1]=0;
	  }
	}<FONT COLOR="#008080">
	break;  /*if_food */
      case PROGN2:
	PAR {
	  eas[0]=ea1;
	  eas[1]=ea2;
	  flags[0]=1;
	  flags[1]=1;
	}
	break;
      }  /* switch */
      /* Now execute the DOTERM proc as many times as needed */
      e = 0;
      do {
	<FONT COLOR="#00a000">if(flags[e]) {
	  PAR {
	    timeval = <FONT COLOR="#00c000">(timeval==MAXTIME) ? timeval : timeval+1<FONT COLOR="#00a000">;  
	    switch(eas[e]) {
	    case LEFT:
	      dir = (dir-1) & 3; break;
	    case RIGHT:                      
	      dir = (dir+1) & 3; break;
	    case MOVE:                              
	      switch(dir) {                   
	      case EAST:  x++; break;
	      case WEST:  x--; break;
	      case SOUTH: y++; break;
	      case NORTH: y--; break;
	      default: delay;  break;
	      }   
#if !defined HANDELC                                      
	      PAR {                           
		y &= GRIDMASK;            
		x &= GRIDMASK;            
	      }  
#endif
	      foodHere = MAP(map, indx, adju(x,6),y);
	      if(foodHere && !BITSET(food, MAXFOOD)) {  
		PAR {
		  food++; 
		  <FONT COLOR="#d0f000">uneaten--<FONT COLOR="#00a000">;
		  CLRBIT(map, indx, adju(x,6), y);               
		}
	      } 
	      break;
	    default: delay; break;
	    } /* switch eas */  
	  } /* PAR */                                
	} else {
	  delay;
	}<FONT COLOR="#008080">
	TOGGLE(e);
      }while(e);
    } while(!BITSET(counter, MAXNODES));
    PAR {
      foodleft  = !(food==MAXFOOD);
      timeleft  = !(timeval==MAXTIME);
    }
  } while(timeleft && foodleft)<FONT COLOR="#202020">;
  /*
   * Calculate the new raw fitness
   */

  WorkingFitnessWrite(ph, indx) = uneaten;
#if !defined HANDELC
  if(dumpProg && uneaten == 0) {
      int i;
      printf("100%% prognum %d\n", workingprogNum[phEval][indx]);
      printf("--------------------------\n");
      printf("len=%d\n", len);
      for(i=0;i<len;i++) {
       WorkingPopRead(phEval, indx, i, C_ADDR word);
       printf("%d %d %d\n", GetOpcode(word), GetEa1(word), GetEa2(word));
      }
      printf("--------------------------\n");
  }
#endif
}
#endif  /* ANT */


#if defined BOOL11MUX
/***************************************************************************
 * Name:     evalProg
 *
 * Purpose:  Runs a program for an individual
 * 
 * Inputs:   The phase index
 *           the population index (individual)
 *
 * Returns:  1 if we found 100% fit program
 *           0 otherwise
 * 
 ***************************************************************************/
macro proc evalProg(C_UINT indx)
{
  Index       pc;   /* Index into words of instructions */
  Index       len;
  Index_1     counter;
  Register    ea1, ea2,r;
  Bool        regs[MAXREGS]; 
  Register    i;
  Opcode      opcode;
  Word        word;
  Bool        res;
  Word        fit;
  unsigned int curFit;
  unsigned r2;

  fit = DEFAULT_FITNESS;
  curFit = 0;
  do {
    /*
     * Initialisation.
     * All done in 1 cycle for Handel-C
     * a) Zero the register set
     * b) copy the input parameters
     * c) Set up control variables
     */
    PAR {
      i=0;
      FORPAR (r=13; r < MAXREGS; r++ ) {
	regs[r] = 0;
      }
      FORPAR(r2=1; r2 < 13; r2++ ) {
	regs[r2] = !!(curFit & (1<<r2));
      }
      regs[0]=0;
      res = !!((curFit>>3) & (1<<(curFit & 7)));
	       //      res     = !!(curFit[10:3]&(1<<curFit[2:0]));
      /*      printf("Cur = 0x%x data = 0x%x Address = 0x%x result = 0x%x\n", curFit, 
	      curFit>>3, curFit & 7, res);*/
      pc      = 0;
      counter = MAXNODES - adju(WorkingLenRead(phEval,indx),IDXW_1);

    }

    do {
      /* Decode the instruction and maintain the counters */
      PAR {
        counter++;
	ea1 = GetEa1(WorkingPopGet(phEval,indx,pc));
	ea2 = GetEa2(WorkingPopGet(phEval,indx,pc));
	opcode = GetOpcode(WorkingPopGet(phEval,indx,pc));
        pc++;
      }
  
      switch(opcode) {
      case AND:
	regs[ea1] &= (regs[ea2]);
	break;
      case OR:
	regs[ea1] |= regs[ea2];
	break;
      case NOT:
       	regs[ea1]   = !(regs[ea1]);
	break;
      case IF:
	if(regs[ea1]) {
	  PAR {
	    pc++;
	    counter++;
	  }
	}else{ 
	  delay;
	}
	break;
      }  /* switch */
    } while(!BITSET(counter, MAXNODES));
    /*
     * Calculate the new raw fitness
     */
    if(regs[r0] == res ) {
      fit--;
    } else {
      delay;
    }
    curFit++;
  } while(curFit != MAXFITNESS);
  WorkingFitnessWrite(phEval,indx) = fit;
}
#endif

#if defined BOOLPARITY
/***************************************************************************
 * Name:     evalProg
 *
 * Purpose:  Runs a program for an individual
 * 
 * Inputs:   The phase index
 *           the population index (individual)
 *
 * Returns:  1 if we found 100% fit program
 *           0 otherwise
 * 
 ***************************************************************************/
macro proc evalProg(C_UINT indx)
{
  Index       pc;   /* Index into words of instructions */
  Index_1     counter;
  Register    ea1, ea2,r;
  Bool        regs[MAXREGS]; 
  Register    i;
  Opcode      opcode;
  Bool        res;
  Bool        done;
  Bool		  doneFit;
  Word        fit;
  Word curFit;
  Word tmpFit;
  unsigned r2;
  Word bits;
  Word  b;
  Phase       ph;

  PAR {
  	fit = DEFAULT_FITNESS;
  	ph  = phEval;
  	curFit = 0;
  }
  do {
    /*
     * Initialisation.
     * All done in 1 cycle for Handel-C
     * a) Zero the register set
     * b) copy the input parameters
     * c) Set up control variables
     */
    PAR {
      i=0;
      FORPAR (r=PARITYBITS; r < MAXREGS; r++ ) {
	regs[r] = 0;
      }
      FORPAR(r2=0; r2 < PARITYBITS; r2++ ) {
	regs[r2] = !!(curFit & (1<<r2));
      }
#if 0
      for(i=0;i<MAXREGS;i++) {
	printf("curFit = 0x%x, reg %d = %d\n", curFit, i, regs[i]);
      }
#endif
      bits = 0;
      tmpFit = curFit;
      b=0;
      pc      = 0;
      counter = MAXNODES - adju(WorkingLenRead(ph,indx),IDXW_1);
    }  /* PAR */
 

/* Do the calculation of the parity in parallel with the fitness eval */
   PAR {

    do {
        if(tmpFit & 0x1) {
            bits++;
        } else {
            delay;
        } 
        PAR {
            tmpFit >>= 1;
            done = (b==PARITYBITS-1);
            b++;
#if defined HANDELC
            res = bits[0];
#else
			res = bits & 1;
#endif
      }
    }while(!done);
 


    do {
      /* Decode the instruction and maintain the counters */
      /*PAR*/ {
        counter++;
	ea1 = GetEa1(WorkingPopGet(ph,indx,pc));
	ea2 = GetEa2(WorkingPopGet(ph,indx,pc));
	opcode = GetOpcode(WorkingPopGet(ph,indx,pc));
	//		printf("PC %d: I=0x%x, op = 0x%x, ea1 = 0x%x, ea2 = 0x%x\n", pc, WorkingPopGet(ph,indx,pc), opcode, ea1, ea2);
        pc++;
      }
  
      switch(opcode) {
      case AND:
	regs[ea1] &= (regs[ea2]);
	break;
      case OR:
	regs[ea1] |= regs[ea2];
	break;
      case NAND:
	regs[ea1]  = !regs[ea2];
	break;
      case NOR:
	regs[ea1] = (regs[ea1] ^ regs[ea2]);
	break;
      }  /* switch */
    } while(!BITSET(counter, MAXNODES));
    /*
     * Calculate the new raw fitness
     */
   } /* PAR */
  if(regs[r0] == res ) {
    fit--;
  } else {
    delay;
  }
  curFit++;
  doneFit = (curFit == MAXFITNESS);
 } while(!doneFit);

  WorkingFitnessWrite(ph,indx) = fit;
}
#endif

#if defined PSIM
int _start()
{
  static char *argv[] = {"lgpc",NULL};
  return main(1, argv);
}
 
int printf(const char * fmt, ...)
{
  return 0;
}
 
int fprintf(FILE *f, const char * fmt, ...)
{
  return 0;
}
 
int sprintf(char *s, const char * fmt, ...)
{
  return 0;
}
 
int rand(void)
{
  int v;
  return v++;
}                        
#endif
#else

ram unsigned int 32 array[32];
void main(void)
{
    unsigned int 5 count;
    unsigned int 16 loop;
    count = 0;
    loop  = 0;
    PP1000RequestMemoryBank(1);
  
  /* Initialise */
    do {
        array[count]=adju(count,32);
        PP1000WriteBank0func(adju(count,21), array[count]);
        count++;
    } while(count);

    do {
    /* Modify */
    count = 0;
    do{ 
        unsigned int 32 val;
        PP1000ReadBank0(val, adju(count,21));
        array[count] = val;
        val <<= 1;
        array[count] = val;
        PP1000WriteBank0func(adju(count,21),array[count]);
        count++;
    } while(count);
    loop++;
    } while(loop);
    PP1000ReleaseMemoryBank(1);
    PP1000WriteStatus(1);
}
#endif


ÿ<FONT COLOR="#000000"><H3>
C:\USER\PETES\PhD\hwgpperf\hwgph.h
</H3>
<FONT COLOR="#202020">#ifndef LGPC_H
#define LGPC_H

#define VERSION "1.0"

typedef enum {PXOR, PANT, PBOOLEANPARITY} problemType ;
/*
 * Problem specific values
 */
#if defined XOR
#warning doing the XOR problem
#define PROBLEMTYPE PXOR
#define GENERATIONS    (64)                
#define POPSIZE    (64)
#define MAXPROGLEN (16)
#define MAXFITNESS (4) 
#define MAXFUNCS   (4)
#define MAXREGS    (4)
#define MAXFITW    4
/**************************************************************************
 * Function set members
 * This must match MAXFUNCS
 ***************************************************************************/
typedef enum {
  AND, OR, NAND, NOR
} FuncTypeE;

/***************************************************************************
 * Registers (terminal set) for the processor
 * Must match MAXREGS
 ***************************************************************************/
typedef enum {
  r0,r1,r2,r3
} RegisterE;

#define DEFAULT_FITNESS 4

/*
 * The layout of an 'instruction'
 */
#define EA2BITS 1:0
#define EA1BITS 3:2
#define OPCODEBITS 5:4
#define GetOpcode(val) (((val&0x30)>>4)&(MAXFUNCS-1))
#define GetEa1(val)    ((val&0x0c)>>2)
#define GetEa2(val)    ((val&3))
#define genNode() rand() & 0xff


#elif defined BOOLPARITY
/*************************************************************************
 * B O O L E A N   P A R I T Y 
 *************************************************************************/
#warning Doing boolean parity

#define PROBLEMTYPE PBOOLEANPARITY
#if !defined GENERATIONS
#define GENERATIONS    (64)                
#endif
#if !defined POPSIZE
#define POPSIZE    (1024)
#endif
#if !defined MAXPROGLEN
#define MAXPROGLEN (64)
#endif
#if !defined PARITYBITS
#define PARITYBITS 6
#endif
#define MAXFITNESS (1<<PARITYBITS)
#define FUNCBITS   2                 /* Number of bits for a function */
#define MAXFUNCS   (1<<FUNCBITS)
#define FUNCMASK   (MAXFUNCS-1)
#if !defined REGBITS
#define REGBITS    4               /* Number of bits for the registers */
#endif
#define MAXREGS    (1<<REGBITS)
#define REGMASK    (MAXREGS-1)
#define MAXFITW    12
#define DEFAULT_FITNESS MAXFITNESS
/**************************************************************************
 * Function set members
 * This must match MAXFUNCS
 ***************************************************************************/
typedef enum {
  AND, OR, NAND, NOR
} FuncTypeE;

/***************************************************************************
 * Registers (terminal set) for the processor
 * Must match MAXREGS
 ***************************************************************************/
typedef enum {
  r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15
} RegisterE;

#if !defined HANDELC
#define GetOpcode(val) (((val&(FUNCMASK << (REGBITS+REGBITS)))>>(REGBITS+REGBITS))&(MAXFUNCS-1))
#define GetEa1(val)    ((val&(REGMASK << REGBITS))>>REGBITS)
#define GetEa2(val)    (val&REGMASK)
#define genNode() (rand() &  ((FUNCMASK << (REGBITS+REGBITS)) | (REGMASK << REGBITS) | REGMASK))
#else
#define EA1BITS        REGBITS-1:0   
#define EA2BITS        REGBITS+REGBITS-1:REGBITS
#define OPCODEBITS     REGBITS+REGBITS+FUNCBITS-1:REGBITS+REGBITS
#define NODEBITS       REGBITS+REGBITS+FUNCBITS-1:0
#endif

#elif defined BOOL11MUX
/*************************************************************************
 * B O O L E A N   11 M U L T I P L E X E R
 *************************************************************************/
#warning Doing boolean multiplexer

#define PROBLEMTYPE PBOOLEANPARITY
#define GENERATIONS    (1024)                
#define POPSIZE    (128)
#define MAXPROGLEN (32)
#define MAXFITNESS (2048)
#define MAXFUNCS   (4)
#define MAXREGS    (16)
#define MAXFITW    12
#define DEFAULT_FITNESS MAXFITNESS
/**************************************************************************
 * Function set members
 * This must match MAXFUNCS
 ***************************************************************************/
typedef enum {
  AND, OR, NOT, IF
} FuncTypeE;

/***************************************************************************
 * Registers (terminal set) for the processor
 * Must match MAXREGS
 ***************************************************************************/
typedef enum {
  r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15
} RegisterE;

#define GetOpcode(val) (((val&0x300)>>8)&(MAXFUNCS-1))
#define GetEa1(val)    ((val&0xf0)>>4)
#define GetEa2(val)    ((val&0xf))
#define genNode() rand() & 0x3ff

#elif defined ANT
/**************************************************************************
 * ANT 
 ***************************************************************************/
#warning doing the ANT problem
#define PROBLEMTYPE PANT
#define GENERATIONS  (32)     /* Number of generation equivalents */
#define POPSIZE      (1024)
#if !defined MAXPROGLEN
#define MAXPROGLEN   (32)
#endif
#define MAXFITNESS   (1)
#define GRIDX        (32)
#define GRIDY        (32)   
#define MAXFUNCS     (2)
#define MAXREGS      (4)
#define FOOD         (89)
#define MAXFOOD      (128)
#define MAXTIME      (750)
#define MAXDIRECTION (4)
#define MAXFITW    7

typedef enum {
  IF_FOOD, PROGN2
} FuncTypeE;
typedef enum {
    t1,t2
} RegisterE;

#define DEFAULT_FITNESS FOOD

#if defined HANDELC
#define FOODW      (log2ceil(MAXFOOD)+1)
#define TIMEW      (log2ceil(MAXTIME)+1)
#define DIRW       (log2ceil(MAXDIRECTION))
#define POSW       (log2ceil(GRIDX))
#else
#define FOODW
#define TIMEW
#define DIRW
#define POSW
#endif

#define GRIDMASK   (GRIDX-1)

typedef unsigned int FOODW    Food;
typedef unsigned int TIMEW    Time;
typedef unsigned int DIRW     Direction;
typedef unsigned int POSW     Pos;
/*
 * Direction values. Arranged so that incrementing turns right,
 * and decrementing turns left
 */
#define EAST  0
#define SOUTH 1
#define WEST  2
#define NORTH 3	

/*
 * Terminals 
 */
#define LEFT  0
#define RIGHT 1
#define MOVE  2
#define NOP   3

/*
 * The layout of an 'instruction'
 */
#define EA2BITS 1:0
#define EA1BITS 3:2
#define OPCODEBITS 4

#if !defined HANDELC
#define GetOpcode(val) (((val&0x30)>>4)&(MAXFUNCS-1))
#define GetEa1(val)    ((val&0x0c)>>2)
#define GetEa2(val)    ((val&3))
#define genNode() rand() & 0xff
#endif

#else
#error Must specify problem type of XOR, ANT
#endif /* ANT */

/**************************************************************************
 * The rest of the general definitions
 **************************************************************************/

#define GENSIZE      (GENERATIONS * (POPSIZE/(MAXPAR)))

#define MAXNODES   (MAXPROGLEN)       /* Maximum words per individual
											including the control words at the start
                                           In the Virtex device being used
                                           the Block Select Rams are 4096 bits
                                           deep. To ensure that each individual
                                           is in it's own ram so that we can
                                           use parallel evaluations, the depth
                                           of each individual should be maximal
                                           ie:128 words, even if this is not the
                                           maximum program length! */

#define MAXPHASE   (2)           /* Two phases in the pipeline  */
#ifndef MAXPAR
#define MAXPAR     (2)           /* Number of individuals being evaluated
				  * in parallel. Must be at least 2 because
				  * this is also used to dimension workingPop
				  * which needs at least 2 individuals to do
				  * breeding with */
#endif
#define MAXINITLEN (MAXPROGLEN)       /* Max length for creation      */
#define MAXMETHODS (4)
#define WORDLEN    (16)               /* Size of RAM storage */

/*****************************************************************
 * Handle-c specific defines
 *****************************************************************/
#ifdef HANDELC
/* Define the widths of the various values */
#define FTW       		(log2ceil(MAXFUNCS))        		/* Bits needed for function     */
#define NTW       		(log2ceil(MAXNODETYPES))  	/* Bits to represent node types */
#define IDXW      		(log2ceil(MAXNODES))        	/* Width of index into nodes (words)   */
#define IDXW_1          (IDXW+1)
#define PROGW           (log2ceil(MAXPROGLEN))          /* Width of program counter */
#define PROGW_1         (PROGW+1)
#define GENW      		(log2ceil(GENSIZE))         		/* Width if generation index    */
#define GENW_1          (GENW+1)
#define POPW      		(log2ceil(POPSIZE))         		/* Width of population index    */
#define POPW_1          (POPW+1)
#define REGW      		(log2ceil(MAXREGS))
#define FUNCW     		(log2ceil(MAXFUNCS))
#define MTHW      		(log2ceil(MAXMETHODS))
#define FCASEW    	    (log2ceil(MAXFITNESS))
#define FCASEW_1        (FCASEW+1)
#define SHORTW    	    8
#define BITW      		1
#define PHASEW    	    1
#define WORKW     	    (log2ceil(MAXPAR))
#define WORKW_1         (WORKW+1)
#define VW        		1
#define SRAMW           21
#define BIT8             8
#define BIT16           16
#define BIT32           32
#define PCNW             2
#define RAM             ram
#define STARTW      (log2ceil(START))
#define WORDW       (WORDLEN)
#define CTRLW            2

#define BOOLW     		1
#define RANDWIDTH 32
#define MAINTYPE  	void
#define MAINARGS  	(void)
#define MAINRET
#define RETVAL
#define FORPAR     	par
#define PAR         par
#define PARX        
#define SEQ         seq
#define INLINE	  	inline
#define take      	<-
#define outstr(x)
#define outdata(x,y) 	dooutdata(x,(Short)adju(y,SHORTW))

/* Define some control bits */
#define INWORK (0)   /* Indicates individual is in workingPop */
#define MOD4(v) 
#if defined XC4000
#define WITHBLOCK
#else
#define WITHBLOCK with {block=1}
#define WITHBLOCK4  with {block=1,rclkpos = {1.0},wclkpos = {3.5},clkpulselen = 0.5,westart = 3.0,welength = 1.0}  
#endif
#define TOGGLE(x)  x=!x
#define WAIT(x)    while(!x) delay

/* Define the types for iso-c that allow macros to be compiled */
#define C_UINT
#define C_UPTR
#define C_PTR
#define C_ADDR
#define C_U8PTR

/* Define some bit macros */
#define BIT0(x) x[0]
#define BIT1(x) x[1]

#else /* HANDELC */

/* Non-Handlec definitions to make this compile as normal ANSI-C */
#define FTW
#define NTW
#define AW
#define VW   
#define IDXW
#define IDXW_1
#define PROGW
#define PROGW_1
#define LENW
#define GENW
#define GENW_1
#define POPW
#define POPW_1
#define INDW 
#define REGW
#define MDW
#define LOOPW
#define MTHW
#define PCNW
#define BITW
#define FCASEW
#define FCASEW_1
#define SPOPW
#define WORKW
#define WORKW_1
#define PHASEW
#define SRAMW
#define BIT8
#define BIT16
#define BIT32
#define WORDW
#define FUNCW
#define CTRLW
#define RANDWIDTH

#define MAINTYPE  int
#define MAINARGS  (int argc, char ** argv)
#define MAINRET   return 0
#define FORPAR    for
#define PAR     
#define PARX     
#define SEQ
#define mpram union
#define signal
#define BOOLW
#define SHORTW
#define delay     ;  
#define INLINE
#define adju(a,b) a
#define adjs(a,b) a
#define width(v)
#define take
#define RAM
#define WITHBLOCK
#define TOGGLE(x) (x = (x+1) & 0x1)
#define WAIT(x)
#define outstr(x) dooutstr(x)
#define outdata(x,y) dooutdata(x,y)
#define macro  
#define proc void

/* defines to allow macros to be compiled as thoughthey were C */
#define C_UINT unsigned int
#define C_UPTR unsigned int *
#define C_U8PTR UINT8 *
#define C_ADDR &
#define C_PTR  *
#define IncrIdx1(x) (x++)

/* Working pop prototypes */

#endif  /* HANDELC */

/* Layout of the individual */
#define PROGN  (0)
#define FITN   (1)
#define PLEN   (2)
#define CONTRL (3)

/* Define the layout of the control parameters in SRAM
 * These are set up by the host before the run starts */
#define R_SEED  0  /* Random number seed */
#define R_GEN   1  /* Maximum number of generations to run for */

/* *************************************************************
 * Breeding ratios 
 ***************************************************************/
typedef enum {
  COPY, XOVER, MUTATE 
} ReproMethod;

/*
 * typedef the commonly used types
 */
typedef unsigned int PROGW    PC;
typedef unsigned int PROGW_1  Proglen_1;
typedef unsigned int IDXW     Index;
typedef unsigned int IDXW_1   Index_1;
typedef unsigned int VW       Value;
typedef unsigned int VW       UValue;
typedef unsigned int GENW     Generation;
typedef unsigned int GENW_1   Generation_w;
typedef unsigned int POPW     PopIndex;
typedef unsigned int POPW_1   PopIndex_1;
typedef unsigned int POPW     Depth;
typedef unsigned int REGW     Register;
typedef unsigned int FTW      FuncType;
typedef unsigned int MTHW     Method;
typedef unsigned int FCASEW   Fcase;
typedef unsigned int FCASEW_1 Fcase_1;
typedef unsigned int BOOLW    Bool;
typedef unsigned int SHORTW   Ushort;
typedef signed   int SHORTW   Short;
typedef unsigned int WORKW    WorkIndex;
typedef unsigned int WORKW_1  WorkIndex_1;
typedef unsigned int PHASEW   Phase;
typedef unsigned int SRAMW    MainPopIndex;
typedef unsigned int SRAMW    ControlIndex;
typedef unsigned int BIT8     UINT8;
typedef   signed int BIT8     INT8;
typedef unsigned int BIT16    ProgNum;
typedef unsigned int BIT32    UINT32;
typedef unsigned int FUNCW    Opcode;
typedef unsigned int CTRLW    Ctrl;
typedef unsigned int WORDW    Word;
typedef unsigned int RANDWIDTH RandReg;  



/*
 * Tags for outputting the data from handlec
 */
typedef enum {
	LEN, GEN, IND, FUNC, EA1, EA2, K, FIT, BADOP, INIT, NMUTATE, NCOPY, NXOVER
} Tag;
#define EOL "\n"

#if defined HANDELC
/*
* Some macros
*/
extern RAM Word     workingPop  [MAXPHASE*MAXPAR][MAXNODES];
extern RAM Word     workingFitness   [MAXPHASE] [MAXPAR];
extern RAM Word     workingLen       [MAXPHASE] [MAXPAR];
extern RAM PopIndex workingprogNum   [MAXPHASE] [MAXPAR];


macro expr LIMIT(v,l)   = (v);
macro expr BITSET(v,l)  = (v[log2ceil(l)]);
macro expr InWork(ctrl) = ctrl[INWORK];
macro expr GetOpcode(v) = v[OPCODEBITS];
macro expr GetEa1(v)    = v[EA1BITS];
macro expr GetEa2(v)    = v[EA2BITS];
macro expr MakeInstruction(f,e1,e2) =  0@f@e1@e2;
macro expr MakeCombined(n4,n3,n2,n1) = n4@n3@n2@n1;
macro  expr UnsignedGt(a,b,w)  =  (adju(a,w) > adju(b,w));

#if defined DEBUG || defined XC4000
macro expr UnsignedLt(a,b,w) = (<FONT COLOR="#00a000">adju(a,w) < adju(b,w)<FONT COLOR="#202020">);
macro expr UnsignedLe(a,b,w) = (<FONT COLOR="#00a000">adju(a,w) <= adju(b,w)<FONT COLOR="#202020">);
#else
#define UnsignedLt(a,b,w)  FastLt.A_LT_B
#define UnsignedLe(a,b,w)  FastLe.A_LE_B
#define UnsignedGt(a,b,w)  FastGt.A_LE_B
#endif
#define IDXW1_2 ((IDXW_1+1)/2)

/* Fast(er) increment. Requires less gate delays since there is less
* carry bits, but requires two clock cycles as compared to one for the
* iso-c x++ operator */
macro proc IncrIdx1(x)
{
    static const unsigned IDXW_1 y = 1;
    unsigned (IDXW1_2+1) temp1;
    unsigned (IDXW1_2)   temp2;

    par  {
        temp1 = (0@(x<-IDXW1_2)) + (0@(y<-IDXW1_2));
        temp2 = (x \\ IDXW1_2) + (y \\ IDXW1_2);
    }
    x = (temp2+(0@temp1[IDXW1_2])) @ temp1[(IDXW1_2-1):0];
}

/* Convert an index into a SRAM address. */
macro proc indexToAddr(idx, addr)
{
  addr =(<FONT COLOR="#008080">adju(idx, SRAMW) << PROGW<FONT COLOR="#202020">);
}

/* Convert an index into a control ram address */
macro proc indexToCtrl(idx, addr)
{
  addr =(adju(idx, SRAMW) << 2);
}

macro proc WorkingPopRead(a,b,c,v)
{
    v = <FONT COLOR="#00c000">workingPop[a@b]<FONT COLOR="#202020">[c];
}

macro expr WorkingPopGet(a,b,c) = <FONT COLOR="#00c000">workingPop[a@b]<FONT COLOR="#202020">[c];

macro proc WorkingPopWrite(a,b,c,v)
{
    workingPop[a@b][c]=v;
}

macro expr WorkingControl(a,b) = workingControl[a][b];
macro expr WorkingFitnessRead(a,b) = <FONT COLOR="#00c000">workingFitness[a]<FONT COLOR="#202020">[b];
macro expr WorkingFitnessWrite(a,b) = workingFitness[a][b];
macro expr WorkingprogNum(a,b) = workingprogNum[a][b];

macro expr WorkingprogNumRead(a,b) = <FONT COLOR="#00c000">workingprogNum[a]<FONT COLOR="#202020">[b];
macro expr WorkingprogNumWrite(a,b) = <FONT COLOR="#00c000">workingprogNum[a]<FONT COLOR="#202020">[b];

macro expr WorkingLenRead(a,b)     = <FONT COLOR="#00c000">workingLen[a]<FONT COLOR="#202020">[b];
macro expr WorkingLenWrite(a,b)     = workingLen[a][b];

extern UINT32 randReg;
macro expr genNode() = 0@randReg[7:0];

#if DEBUG
macro proc PP1000RequestMemoryBank(b)
{
    unsigned int 2 bank;
    bank=b;
}
macro proc PP1000ReleaseMemoryBank(b)
{
    unsigned int 2 bank;
    bank=b;
}
#endif

#else
/* ISO-C definitions and macro replacements */
#warning using iso-c
typedef enum {FALSE=0, TRUE=1} TrueFalse;
UINT32 READRAM(unsigned bank, unsigned long addr);
void WRITERAM(unsigned bank, unsigned addr, unsigned val);
UINT8 MakeInstruction(unsigned long,unsigned long, unsigned long);
RandReg   s_random(void);
void randseed(void);
PC       randPC();
void     randMethod(Method *);
PopIndex randPopIndex();
Register randEa();
FuncType randInstruction();
void     WorkingPopWrite(unsigned int a, unsigned int b, unsigned int c, unsigned int v);
void     WorkingPopRead(unsigned int a, unsigned int b, unsigned int c, unsigned int *  v);
Word     WorkingPopGet(unsigned int a, unsigned int b, unsigned int c);
void dooutdata(int,int);
#define WorkingPop(p,i,o) workingPop[p][i][o]

#define WorkingLenWrite(p,i)   workingLen[p][i]
#define WorkingLenRead(p,i)   workingLen[p][i]
#define WorkingFitnessWrite(p,i)   workingFitness[p].Write[i]
#define WorkingFitnessRead(p,i)   workingFitness[p][i]
#define WorkingprogNumWrite(p,i)   workingprogNum[p][i]
#define WorkingprogNumRead(p,i)   workingprogNum[p][i]
#define WorkingControl(p,i)   workingControl[p][i]
#define PP1000ReadBank0(val,addr)  val=READRAM(0, addr)
#define PP1000WriteBank0(addr,val) WRITERAM(0, addr,val)
#define PP1000ReadBank1(val,addr)  val=READRAM(1, addr)
#define PP1000WriteBank1(addr,val) WRITERAM(1, addr,val)
#define PP1000ReleaseMemoryBank(b)
#define PP1000RequestMemoryBank(b)
#define PP1000SetGPI(val)
#define PP1000ReadGPO() 1
#define PP1000WriteStatus(v)
#define PP1000ReadControl(v)
#define InWork(ctrl)   (ctrl&1)
#define indexToAddr(i,a) (a=i*MAXNODES)
#define LIMIT(v,l)     (v < l)
#define BITSET(v,l)    (v & l)
#define MOD4(v)        (v=v&0x3)
#define BIT0(x)        (x&1)
#define BIT1(x)        (!!(x&2))

#define UnsignedGt(a,b,w) (a > b)
#define UnsignedLt(a,b,w) (a < b)
#define UnsignedLe(a,b,w) (a <= b)
#define RANDFILE   "randseed"
#define RANDLOG    "randlog"
PC randLen();
#endif

#if defined ANT
#if defined HANDELC
#define ANDGRIDMASK 
#define ANDDIRMASK
macro expr MAP(map,t,x,y) = (<FONT COLOR="#00c000">!!((map[t][y])&(1<<x)<A NAME="delay4"><U>)</U><SUB>24</SUB></A><FONT COLOR="#202020">);
#define CLRBIT(map,t,x,y)  map[t][y] &= ~(1<<x)
#else
#define ANDGRIDMASK &(GRIDX-1)
#define ANDDIRMASK  &3
#define MAP(map,t,x,y) !!(map[t][y]&(1<<x))
#define CLRBIT(map,t,x,y) map[t][y] &= ~(1<<x)
#endif

#endif

#endif
ÿendif
<FONT COLOR="#000000"><H3>
Highlight Colours Table: </H3><FONT COLOR="#ffffff">
<SPAN STYLE="background-color: #202020"> =         0.00 </SPAN>
<SPAN STYLE="background-color: #0040d0"> <         6.60 </SPAN>
<SPAN STYLE="background-color: #008080"> <        13.20 </SPAN>
<SPAN STYLE="background-color: #00a000"> <        19.80 </SPAN>
<SPAN STYLE="background-color: #00c000"> <        26.40 </SPAN>
<SPAN STYLE="background-color: #40f000"> <        33.00 </SPAN>
<SPAN STYLE="background-color: #d0f000"> <        39.60 </SPAN>
<SPAN STYLE="background-color: #f8f000"> <        46.20 </SPAN>
<SPAN STYLE="background-color: #f8d000"> <        52.80 </SPAN>
<SPAN STYLE="background-color: #f8b000"> <        59.40 </SPAN>
<SPAN STYLE="background-color: #f88000"> <        66.00 </SPAN>
<SPAN STYLE="background-color: #f80000"> =        66.00 </SPAN>

</PRE>
</BODY></HTML>
