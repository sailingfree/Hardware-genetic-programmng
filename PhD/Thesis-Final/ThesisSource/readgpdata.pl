#!/usr/bin/perl -w
# Script to erad th egp data abse and make a CSV file ready for 
# translation into LyX
#use gpdata;
#select GP_desc, GP_cite  INTO "/home/pete/XXX" FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
#      LINES TERMINATED BY "\n" from gpmain;

use DBI;

@header = (
"lyxformat 220",
"textclass essex",
"language english",
"inputencoding auto",
"fontscheme default",
"graphics default",
"paperfontsize default",
"papersize Default",
"paperpackage a4",
"use_geometry 0",
"use_amsmath 0",
"use_natbib 0",
"use_numerical_citations 0",
"paperorientation portrait",
"secnumdepth 3",
"tocdepth 3",
"paragraph_separation indent",
"defskip medskip",
"quotes_language english",
"quotes_times 2",
"papercolumns 1",
"papersides 1",
"paperpagestyle default",
"layout Standard"
	   );


# Three arrays defining teh table. The first array defines the column names
# in the database.
# The second array defines the titles in the table
# The third array defines the column sizes in cm
# This is a hack, and the data should come from the database.
@cols = (
	 "x",
	 "GP_cat",
	 "GP_desc",
	 "Pop",
	 "Gen",
	 "Size",
	 "GP_cite"
	 );

@titles = (
	   "",
	   "Category", 
	   "Description", 
	   "Pop", 
	   "Gen", 
	   "Size", 
	   "Reference");
@colsz = (
	  0.5,
	  1.8, 
	  4,
	  1.0, 
	  0.9, 
	  0.8, 
	  4);   

$database = "gpdata";
$query = "select x, GP_cat,GP_desc, M, G, size, GP_cite from gpmain where GP_cite is not null order by GP_cat, GP_desc";

open SIZES, ">sizes.tex" || die "Cannot create the sizes.tex file\n";
open LYXTABLE, ">TaxonomyTable.lyx" || die "Cannot create the TaxonomyTable.lyx file";

print LYXTABLE "# LyX file generated by mysqltolyx.\n";
print LYXTABLE "# Generated for LyX 1.2 \n";
print LYXTABLE "# By Peter Martin\n";
print LYXTABLE "# Database = $database\n";
print LYXTABLE "# Query = $query\n";

foreach $w (@header) {
    print LYXTABLE "\\$w\n";
}

my $columns = "".@cols;

$dbh = DBI->connect("DBI:mysql:$database");


### Get the column names
$sth = $dbh->prepare("show columns from gpmain");
$rv = $sth->execute() || die "Error executing show columns: $sth->errstr\n";

$ncols = 0;
while(@cols = $sth->fetchrow_array) {
    $colnames[$ncols]=$cols[0];
    $ncols++;
}
print "There are $ncols columns\n";
#foreach $c (@colnames) {
#    print "$c\n";
#}

$sth = $dbh->prepare("select count(*) from gpmain where GP_cite is not null");
$rv  = $sth->execute || die "Cannot read number of rows from gpmain: $sth->errstr\n";
$rows = $sth->fetchrow_array;
#print "#There are $rows rows\n";

$tablerows=$rows+1;
print LYXTABLE "\\begin_inset Tabular\n";
print LYXTABLE "<lyxtabular version=\"3\" rows=\"$tablerows\" columns=\"$columns\">\n";
print LYXTABLE "<features islongtable=\"true\">\n";

for($col=0;$col<$columns;$col++) {
    $rline="\"false\"";
    if($col+1==$columns) {
	$rline="\"true\"";
    }
    print LYXTABLE "<column alignment=\"left\" valignment=\"top\" leftline=\"true\" rightline=$rline width=\"$colsz[$col]cm\">\n";
}

print LYXTABLE "<row topline=\"true\" bottomline=\"true\" endhead=\"true\">\n";
foreach $t (@titles) {
    print LYXTABLE "<cell alignment=\"left\" valignment=\"top\" topline=\"true\" leftline=\"true\" usebox=\"none\">\n";
    print LYXTABLE "\\begin_inset Text\n\n";
    print LYXTABLE "\\layout Standard\n\n";
    print LYXTABLE "\\size footnotesize\n";
    print LYXTABLE "$t\n";
    print LYXTABLE "\\end_inset\n";
    print LYXTABLE "</cell>\n";
}
print LYXTABLE "</row>\n";


# Prepare and execute the query to get the data for the main table
$sth = $dbh->prepare($query) || die "Can't prepare $query: $dbh->errstr\n";
$rv = $sth->execute || die "Can't execute the query: $sth->errstr\n";

$thisrow=0;
$BOTTOM="false";
while(@row = $sth->fetchrow_array) {
    if($thisrow == $rows-1) {
	$BOTTOM="true";
    }
    @row[0]=$thisrow+1;
#    print "THISROW=$thisrow ROWS=$rows BOTTOM=$BOTTOM @row\n";
    print LYXTABLE "<row topline=\"true\" bottomline=\"$BOTTOM\" >\n";
    foreach  (@row) {
	print LYXTABLE "<cell alignment=\"left\" valignment=\"top\" topline=\"true\" leftline=\"true\"  usebox=\"none\">\n";
	print LYXTABLE "\\begin_inset Text\n\n";
	print LYXTABLE "\\layout Standard\n\n";
	print LYXTABLE "\\size footnotesize\n";
	if($_ && /cite/) {
	    s/pages/pp/;
	    print LYXTABLE "\\begin_inset LatexCommand ";
	    print LYXTABLE "$_\n\n";
	    print LYXTABLE "\\end_inset\n\n";
	} elsif(!$_) {
	    print LYXTABLE "--\n";
	} else {
	    print LYXTABLE "$_\n";
	}
	print LYXTABLE "\\end_inset\n\n";
	print LYXTABLE "</cell>\n\n";
    }
    print LYXTABLE "</row>\n\n";
    $thisrow++;
}

print LYXTABLE "</lyxtabular>\n\n";
print LYXTABLE "\\end_inset\n\n\n";
addcounter("tablerows", $rows);


# Write values to a file as new counters.
# These can then be used by the lyx file by inclding this file and 
# using \arabic{countername}
sub addcounter {
    my $ctr = shift;
    my $val = shift;
    print SIZES "\\newcounter{$ctr}\n";
    print SIZES "\\setcounter{$ctr}{$val}\n";
}

print LYXTABLE "\\the_end\n";
close LYXTABLE;

%cats=();

## Get the confidence values. We score an entry as ok if it is not null and does not contain the
## string unknown.
## We key initially using the 'x' field which is suppoed to be a unique key.
sub doconfidence {
    %cats=();
    @confidence = ();
    $query1="select x from gpmain where GP_cite is not null order by x";
    $row=0;
    $sth = $dbh->prepare($query1);
    $rv = $sth->execute || die "Error executing $query1 : $sth->errstr\n";
    while (@row = $sth->fetchrow_array) {
	$x = $row[0];
	$confidence[$x] = 0;  # set to zero at start of each row
	for($col=0;$col< $ncols; $col++) {
	    $name=$colnames[$col];
	    $sth2 = $dbh->prepare("select $name from gpmain where $name is not null and GP_cite  is not null and x=$x");
	    $sth2->execute || die "Error executing select $name from gpmain where $name is not null GP_cite is not null: $sth2->errstr\n";
	    @val = $sth2->fetchrow_array;
	    $nfields = @val."";
	    #print "nfields = $nfields\n";
	    #print "val is @val\n";
	    if($nfields != 0) {
		$confidence[$x]++;
	    }
	}
#	print "Count for row $x is $confidence[$x]\n";
	$conf = ($ncols-$confidence[$x])/$ncols * 100;
#	print "Percentage = $conf\n";
	if(!$cats{$conf}) {
	    $cats{$conf}=0;
	}
	$cats{$conf}++;	
    }
    $cats{98.9}=0;  ## fix to make sure we get top category as well even if empty.
    plotchart("Confidence", 10);
}

##############################################################################################
# Barchart procedure for a single column
##############################################################################################
sub makebarchart {
    my $column = shift(@_);
    my $name   = shift(@_);
    my $bins   = shift(@_);
    my $extras = shift(@_);
   
    
# Execute the query to get the number of different instances of column 
# and make a gnuplot bar chart
    %cats=();

# Get all category names and add them to cats
    $query = "select $column from gpmain where $column is not null $extras and GP_cite is not null order by $column";
    $sth = $dbh->prepare($query);
    print "Query->$query\n";
    $rv =  $sth->execute || die "Cannot query $query\n";
    while (@row = $sth->fetchrow_array) {
	if(!$cats{$row[0]}) {
	    $cats{$row[0]} = 0;
	}
	$cats{$row[0]}++;
    }
    plotchart($name, $bins);
}

sub plotchart {    
    my $name   = shift(@_);
    my $bins   = shift(@_);
   
    
    $datafile = $name . ".dat";
    $plotfile = $name . ".plt";
    $epsfile  = "images/" . $name . ".eps";
    $totalfile= $name . "_total.txt";
    open CATFILE,  ">$datafile"  || die "Error opening data file $datafile\n";
    open CATPLOT,  ">$plotfile"  || die "Error opening plot file $plotfile\n";
    open TOTALFILE,">$totalfile" || die "Cannot open the total text file $totalfile\n";
    $total=0;
    $ncats=0;
    foreach $key (sort keys %cats) {
	if($bins == 0) {
	    print CATFILE "$key  $cats{$key}\n";
	}
	$total += $cats{$key};
	$ncats++;
    }
    
    print "Total is $total\n";
    print TOTALFILE "$total\n";
    addcounter($name, $total);

    # If bins is not zero then sort into a number of bins otherwise
    # use the categories as labels
    if($bins > 0 ) {
	for($i=0;$i<$bins;$i++) {
	    $hist[$i]=0;
	}
	# find max value 
	$max=0;
	foreach $key (keys %cats) {	    
	    if($key > $max) {
		$max = $key;
	    }
	}
	$interval = int(($max+1)/$bins)+1;
	print "Max value is $max\n";
	print "Interval = $interval\n";
	## total fudge here to scale the intervals to nice numbers
	if($interval >97000 && $interval < 99999) {
	    $interval = 100000;
	}
	if($interval > 250 && $interval < 255) {
	    $interval = 250;
	}
	if($interval > 500 && $interval < 505) {
	    $interval = 125;
	}
	print "New Interval = $interval\n";

	# Now count the values into the bins.
	foreach $key (keys %cats) {
	    $b = int($key/$interval);
	    $hist[$b] += $cats{$key};
#	    print "Value $key going into bin $b\n";
	}

	# Finally dump the bin values
	$i=0;
	for ($i=0;$i<$bins;$i++) {
	    print CATFILE "$i $hist[$i]\n";
	}

	# Ahh yes the labels
	$pos=0;
	$i=0;
	print CATPLOT "set xtics rotate (";
	for( $r = 0; $r<$bins;$r++) {
	    if($pos == $bins-1) {
		$SEP="";
	    } else {
		$SEP = ",";
	    }
	    $top = $i  + $interval - 1;
	    print CATPLOT "\"$i-$top\" $pos $SEP ";
	    $pos++;
	    $i+=$interval;
	}
	print CATPLOT ")\n";
    } else {
	$pos=0;
	print CATPLOT "set xtics (";
	foreach $key (sort keys %cats) {
	    if($pos==$ncats-1) {
		$SEP="";
	    } else {
		$SEP=",";
	    }
	    print CATPLOT "\"$key \" $pos $SEP ";
	    $pos++;
	}
	print CATPLOT ")\n";
    }
    print CATPLOT "set nokey\n";
    print CATPLOT "set offsets 1,1,0,0\n";
    print CATPLOT "plot '$datafile' using 2 with boxes\n";
    print CATPLOT "set output '$epsfile' \n";
    print CATPLOT "set term postscript eps 'Times-Roman' 16\n";
    print CATPLOT "replot\n";
    #    print CATPLOT "pause 4\n";
    close CATPLOT;

    close CATFILE;
    close TOTALFILE;
    
    open PLOT, "|gnuplot $plotfile";
    close PLOT;
}

doconfidence();
makebarchart("M", "Populationsizes",20, "and M > 0");
makebarchart("M", "Populationsizes-II",20, "and M > 0 and M < 10000");
makebarchart("Nfit", "FitnessCases", 20, "and Nfit > 0");
makebarchart("G","Generations", 20, "and G > 0");
makebarchart("GP_cat", "categories",0, "");
makebarchart("rep", "representations",0, "");
makebarchart("size", "progsizes",20, "and size > 0");
makebarchart("F", "fsetsize", 20, "and F > 0");

close SIZES;
