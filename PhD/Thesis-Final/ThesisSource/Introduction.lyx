#LyX 1.2 created this file. For more info see http://www.lyx.org/
\lyxformat 220
\textclass essex
\begin_preamble
%
% Change this to input the prologue file for your own thesis
%
\input{shortheader.tex}
\end_preamble
\language british
\inputencoding auto
\fontscheme pslatex
\graphics default
\paperfontsize 11
\spacing single 
\papersize a4paper
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Standard

It has long been a goal of computer scientists to automatically translate
 a problem statement directly into a computer program without having to
 explicitly describe how the program should be created.
 This has often been referred to as automatic programming.
 The mechanics of how it might be achieved were hinted at by Alan Turing
 in his essay ``Computing Machinery and Intelligence'' 
\begin_inset LatexCommand \cite{turing:1950}

\end_inset 

.
 He suggested that a machine, seeded with random elements, could monitor
 the results it generated and subsequently modify itself in the light of
 those results.
 The idea of adopting automatic computer program generation is also of great
 interest to the general software engineering community.
 In the early 1980's this idea was considered interesting but ``somewhat
 beyond the current frontier of the state of the art'' (
\begin_inset LatexCommand \cite[Chapter 33]{boehm:1981}

\end_inset 

).
\layout Standard

Evolutionary techniques in general, and 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
acf{GP}
\end_inset 

 in particular, have brought this goal closer to reality.
 Several researchers, for example 
\begin_inset LatexCommand \cite{Friedberg:1958,Friedberg:1959,fogel:1966,Smith:1980,icga85:cramer,Hicklin:1986,Fujiki:1987,Schmidhuber:1987}

\end_inset 

, have used evolutionary techniques for this problem, with varying degrees
 of success, but it was not until the early 1990's, when John Koza coined
 the term Genetic Programming 
\begin_inset LatexCommand \cite{koza-90}

\end_inset 


\begin_inset LatexCommand \cite{koza:1991:alife}

\end_inset 

, that a robust evolutionary method for automatic program creation became
 available.
 Since then, Genetic Programming has grown into a distinct research field
 with several major conferences and over 2000 published papers, reports
 and books.
\layout Standard

GP systems are generally realised as programs running on general purpose
 computers.
 Most of the earliest GP systems were implemented in LISP.
 More recently, GP systems have been implemented in C, C++, Java and other
 languages.
 However, even with modern processors running at over 2\SpecialChar ~
GHz, and the use
 of massively parallel computers, using GP still requires large amounts
 of time and computer resources to tackle some of the harder problems.
\layout Standard

This research was motivated by the observation that tackling some problems
 using GP is not practical because of the very long execution time required.
 One way of reducing the execution time of an algorithm is to implement
 some, or all, of the algorithm in hardware rather than software.
 This led to the hypothesis 
\lang english
that implementing GP in hardware will reduce the time needed to run the
 GP algorithm.
 A reduced run time for GP would then allow the detailed operation of GP
 to be explored in ways that previously would have required an uneconomic
 investment in time and equipment.
 Reducing the running time of GP would also allow GP to be applied to problems
 that to date have been hard or impossible for GP to solve.
 
\layout Standard

Reducing the running time of the GP algorithm is of interest to two different
 groups of GP users.
 The first group are the practitioners who are using GP for solving problems.
 If the run time of the GP algorithm can be reduced, then more difficult
 problems could be tackled using GP.
 Faster execution of the GP algorithm, in particular the fitness evaluation
 part of the algorithm, also opens up the possibility of using GP in real-time
 applications, for example signal processing.
 Secondly, reduced running time would be of benefit to the researcher who
 is investigating the theoretical operation of GP by, for example, allowing
 the dynamics of GP to be explored in ways that previously would have required
 an uneconomic investment in time and equipment.
\layout Section

Contributions
\layout Standard

This thesis makes 
\begin_inset LatexCommand \ref{NUM:Last main contribution}

\end_inset 

 main contributions:
\layout Enumerate

It shows that a complete GP system can be designed and implemented in hardware.
 This is in contrast to all previously reported work involving hardware
 which implemented only parts of the GP algorithm in hardware, or that only
 demonstrated the idea using software simulations.
\layout Enumerate

It explores the role that the GP algorithm plays in the larger process of
 problem solving.
 This is called 
\emph on 
Meta-GP
\emph default 
.
\layout Enumerate


\begin_inset LatexCommand \label{NUM:Last main contribution}

\end_inset 

It gives an empirical analysis of the behavioural aspects of the system,
 by considering the population dynamics.
 This shows that the length distribution of GP is important when choosing
 appropriate operational parameters.
 From this analysis, an alternative crossover operator is presented.
 The new crossover operator -- called 
\emph on 
single child limiting crossover
\emph default 
 -- has the effect of reducing the impact of bloat for the two problems
 which were investigated.
\layout Standard

This thesis also makes 
\begin_inset LatexCommand \ref{NUM:Last secondary contribution}

\end_inset 

 secondary contributions:
\layout Enumerate

A taxonomy of the attributes of GP is presented which allows a GP problem
 to be categorised with respect to its problem--specific and GP--specific
 attributes.
\layout Enumerate

It shows how a high level language to hardware compilation system allows
 a software approach to the hardware design of GP.
\layout Enumerate

A comparative analysis of different random number generators for hardware
 platforms is presented.
\layout Enumerate


\begin_inset LatexCommand \label{NUM:Last secondary contribution}

\end_inset 

An economic analysis of implementing GP in hardware is given.
\layout Section

Organisation
\layout Standard

Following this introductory chapter, Chapter 
\begin_inset LatexCommand \ref{main:GP Introduction}

\end_inset 

 introduces GP and identifies the attributes of GP.
 A taxonomy of the attributes is then presented.
 From the data collected during the construction of the taxonomy of attributes,
 a number of niches can be identified which merit further research, in particula
r, implementing a complete GP platform in hardware.
 Chapter 
\begin_inset LatexCommand \ref{main:GP Introduction}

\end_inset 

 also considers GP as part of a problem solving process, called Meta-GP.
 Because Meta-GP uses the GP algorithm repeatedly in the search for solutions
 to a problem, the importance of reducing the execution time of the GP algorithm
 is shown.
\layout Standard

Chapter 
\begin_inset LatexCommand \ref{main:FPGAs and HandelC}

\end_inset 

 reviews the main hardware and software technologies that are available
 to implement a GP system in hardware.
 In particular it looks at 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
acf{ASIC}
\end_inset 

 and 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
acf{FPGA}
\end_inset 

 technologies and reviews work that has used these devices in the general
 field of evolutionary computing.
 The languages and tools that are used to program these devices are then
 examined.
 Traditional approaches that use hardware design languages are compared
 to high level languages.
 Chapter 
\begin_inset LatexCommand \ref{main:FPGAs and HandelC}

\end_inset 

 then describes a high level language to hardware compilation system called
 Handel-C that can be used to translate C-like programs into the configuration
 data for a FPGA.
 The features of Handel-C that were of importance to this work are highlighted,
 together with a comparative analysis of Handel-C and other high level language
 to hardware compilation systems.
\layout Standard

Chapter 
\begin_inset LatexCommand \ref{main:implementation}

\end_inset 

 describes an implementation of GP in hardware that was designed to prove
 the general concept of using an FPGA for GP.
 This implementation is deliberately limited in its scope in order to explore
 the essential characteristics of such a system.
 Two simple example problems are then shown which illustrate the principles.
 A quantitative performance comparison is made between the hardware implementati
on and a traditional software implementation of the same algorithm using
 a microprocessor emulator.
 The limitations of this initial design are analysed and a number of alternative
s are suggested.
\layout Standard

Chapter 
\begin_inset LatexCommand \ref{main:Optimised implementation}

\end_inset 

 builds on the results in Chapter 
\begin_inset LatexCommand \ref{main:implementation}

\end_inset 

 and describes a more general solution that supports larger populations
 by exploiting the on-chip memory of the FPGA and by using external memory.
 A pipeline is also implemented in this revised design that enables the
 design to achieve a higher level of throughput.
 The performance of this design is illustrated using three problems.
\layout Standard

Chapter 
\begin_inset LatexCommand \ref{main:Behavioural analysis}

\end_inset 

 presents a behavioural analysis of two of the experiments from Chapter
 
\begin_inset LatexCommand \ref{main:Optimised implementation}

\end_inset 

, focusing on the crossover operator.
 A new crossover operator is presented that appears to reduce the effects
 of bloat.
 Chapter 
\begin_inset LatexCommand \ref{main:Behavioural analysis}

\end_inset 

 also analyses the behaviour of the random number generator used in the
 design, and compares it to a number of alternative random number generators,
 including a source of true random numbers.
 It shows that there are better generators than the generator used in Chapters
 
\begin_inset LatexCommand \ref{main:implementation}

\end_inset 

 and 
\begin_inset LatexCommand \ref{main:Optimised implementation}

\end_inset 

.
\layout Standard

Chapter 
\begin_inset LatexCommand \ref{main:Economic considerations}

\end_inset 

 considers the economics of implementing GP in hardware and suggests some
 application areas that would be appropriate for such an implementation.
 The process of using Handel-C to implement GP is reviewed in the light
 of the experience gained while doing this research.
\layout Standard

Chapter 
\begin_inset LatexCommand \ref{main:Conclusions}

\end_inset 

 summarises the work and presents the main conclusions of the work.
 Finally, a number of suggestions for future research are discussed and
 some possible applications, some of which are only made possible by implementin
g GP in an FPGA, are outlined.
\layout Standard

The main body of the thesis is followed by 4 appendixes:
\layout Itemize

Appendix 
\begin_inset LatexCommand \ref{main:Problem details}

\end_inset 

 gives a detailed problem description for the experiments in Chapters 
\begin_inset LatexCommand \ref{main:implementation}

\end_inset 

, 
\begin_inset LatexCommand \ref{main:Optimised implementation}

\end_inset 

 and 
\begin_inset LatexCommand \ref{main:Behavioural analysis}

\end_inset 

.
 It uses the format developed for the GP taxonomy in Chapter 
\begin_inset LatexCommand \ref{main:GP Introduction}

\end_inset 

.
\layout Itemize

Appendix 
\begin_inset LatexCommand \ref{main:Taxonomy data}

\end_inset 

 provides details of the data used to construct the taxonomy, giving the
 problem category, title, author and a subset of the problem specific data.
\layout Itemize

Appendix 
\begin_inset LatexCommand \ref{main:Experimental setup}

\end_inset 

 describes the details of the hardware and software tools used for the experimen
tal work.
\layout Itemize

Appendix 
\begin_inset LatexCommand \ref{main:Random number generator test results}

\end_inset 

 gives a detailed set of results from the random number generator analysis
 given in Chapter 
\begin_inset LatexCommand \ref{main:Behavioural analysis}

\end_inset 

.
\layout Standard

The first implementation of GP in hardware, described in Chapter 
\begin_inset LatexCommand \ref{main:implementation}

\end_inset 

, originally appeared in Genetic Programming and Evolvable Machines, volume
 2, number 4 
\begin_inset LatexCommand \cite{martin:2001:gpem}

\end_inset 

.
 The optimised design was described in the proceedings of EuroGP'2002 
\begin_inset LatexCommand \cite{martin:2002:eurogp2002}

\end_inset 

, while the results in Chapter 
\begin_inset LatexCommand \ref{main:Behavioural analysis}

\end_inset 

 appeared in the proceedings of GECCO 2002 
\begin_inset LatexCommand \cite{martin:2002:gecco:behaviour}

\end_inset 

 and 
\begin_inset LatexCommand \cite{martin:2002:random}

\end_inset 

.
 
\the_end
