#LyX 1.2 created this file. For more info see http://www.lyx.org/
\lyxformat 220
\textclass essex
\begin_preamble
\input{shortheader.tex}
\input{sizes.tex}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize a4paper
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Comment


\size giant 
Conclusions
\layout Standard

The Genetic Programming algorithm requires a lot of computing resources
 because it often has to evaluate hundreds, thousands or millions of programs
 during a run.
 Furthermore, the algorithm often needs to be run multiple times to find
 an acceptable solution to a problem.
 It is also the case that numerous runs of the GP algorithm are needed when
 empirically investigating the behaviour of a GP system.
 
\layout Standard

The hypothesis of this research is that implementing GP in hardware will
 reduce the time needed to run the GP algorithm.
 A reduced run time for GP would allow the detailed operation of GP to be
 explored in ways that previously would have required an uneconomic investment
 in time and equipment.
 Reducing the running time of GP would also allow GP to be applied to problems
 that, so far, have been hard or impossible for GP to solve.
 
\layout Section

Recapitulation of the Contributions
\layout Subsection

Hardware Genetic Programming
\layout Standard

This thesis approached the idea of implementing GP in hardware from a practical
 standpoint by combining GP with two technologies -- a 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
acf{FPGA}
\end_inset 

 and Handel-C -- to produce the first published complete GP system in hardware.
 The implementation of a proof of concept design, described in Chapter 
\begin_inset LatexCommand \ref{main:implementation}

\end_inset 

, shows that implementing all the stages of GP in hardware is a practical
 proposition, and that using Handel-C it was possible to design the hardware
 using an algorithmic approach.
 By using a simplified design, and accepting that there would be limitations
 in such a design, practical issues surrounding the use of Handel-C and
 designing for an FPGA were addressed.
 However, the proof of concept design used an essentially serial GP algorithm,
 as used in software implementations of GP.
 The results from the problems used to test the design (simple regression
 and the XOR problem) showed that ignoring the opportunities to fully exploit
 the parallelism offered by hardware meant that throughput was limited and
 that the potential speedups were not achieved.
 The proof of concept design also showed that, without external memory,
 an FPGA can only support a very limited population size.
\layout Standard

The results from the optimised implementation (Chapter 
\begin_inset LatexCommand \ref{main:Optimised implementation}

\end_inset 

), which used pipelines, confirmed that exploiting the parallelism in hardware
 could lead to substantial increases in throughput.
 The results from the optimised implementation also showed that, by using
 external memory, it is feasible to implement some common GP benchmark problems
 entirely in hardware, and, for one of the problems used (Boolean even-6-parity
 problem), speed up the execution of GP by a factor of over 400 when compared
 to the same algorithm executed in software.
\layout Subsection

Meta-GP
\layout Standard

To support the hypothesis, this research also considered the question of
 why it is important to reduce the run time of GP.
 Using GP is almost always presented as a linear series of steps.
 In reality, most users know this is not an accurate reflection and that
 using GP often requires extensive experimentation to produce acceptable
 results.
 In this thesis the process of using the GP algorithm has been presented
 explicitly as an algorithm -- called Meta-GP.
 Furthermore, the term Meta-GP has been used to describe the broad activity
 of using an evolutionary approach to discovering acceptable operational
 parameters for the GP algorithm, rather than the narrow interpretation
 often used to describe the automatic optimisation of a single parameter.
 By recognising that Meta-GP is an essential part of developing and using
 GP systems, it is shown that the time to execute the core GP algorithm
 is more important than is normally assumed.
 Reducing the time for the core algorithm means that more GP runs can be
 completed, given a fixed time budget.
\layout Standard

A practical demonstration of the benefits of using a hardware GP implementation
 in the Meta-GP process was highlighted during the investigation into the
 behaviour in Chapter 
\begin_inset LatexCommand \ref{main:Behavioural analysis}

\end_inset 

.
 The speedup offered by the hardware implementation meant that it was feasible
 to repeatedly run the experiments for 500 runs in order to get an average
 of many runs, while still being able to experiment with parameter settings
 and modify the crossover operators.
 Using a software implementation would have required a much longer running
 time, nearly 12 hours for the Boolean even-6-parity problem, which would
 have hindered experimentation with parameter settings and exploration of
 different operators.
\layout Subsection

Exploring GP Behaviour
\layout Standard

The standard method of describing the behaviour of GP systems in the published
 literature is to plot a graph of average fitness versus generation, sometimes
 together with a plot of the effort required to find a solution, as originally
 described in 
\begin_inset LatexCommand \cite{koza:book}

\end_inset 

.
 While this method shows how quickly a GP system reaches an average fitness
 level, it does not show how the GP system is behaving internally.
 Furthermore, as shown in Chapter 
\begin_inset LatexCommand \ref{main:Behavioural analysis}

\end_inset 

, the standard method does not clearly show the differences between two
 similar GP systems.
 In this thesis, the number of correct programs at the end of a run has
 been used, which shows more directly the differences in behaviour between
 experiments.
 Although the number of correct programs has previously been used as a measure
 of effort, for example by Miller and 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cbstart 
\end_inset 

 Thomson 
\begin_inset ERT
status Collapsed

\layout Standard
 
\backslash 
cbend 
\end_inset 

 in 
\begin_inset LatexCommand \cite{miller:2000:CGP}

\end_inset 

, this thesis also considered the program size distribution.
 The results were presented as a histogram of the lengths of the 100% correct
 programs.
 This gave another insight into the choice of operational parameters.
 The program size distribution for the artificial ant problem suggested
 modifying the maximum length that programs were allowed to grow to.
 The modifications showed that the number of 100% correct solutions could
 be increased.
\layout Standard

When investigating the behaviour of different crossover operators, the changes
 in the population length distribution during a GP run gives an insight
 into the pressures that different operators can have on the program lengths
 of the population.
 Using this insight, a new crossover operator -- called single child limiting
 crossover -- has been developed.
 The single child limiting crossover operator has been shown to be effective
 in constraining the maximum length of programs and in controlling the tendency
 of GP programs to bloat.
\layout Subsection

Taxonomy of GP Attributes
\layout Standard

Arranging the attributes of GP into a taxonomy was prompted because there
 has not been a unified classification of this information before.
 The taxonomy makes it explicit which attributes are related to the problem
 and which attributes are GP specific.
 Just as in software engineering, where there is a clear distinction between
 the specification of a problem and the implementation, explicitly identifying
 which attributes are problem specific and which are GP specific should
 help in identifying suitable attribute values for problems.
 The survey of problems highlighted several features of how GP has been
 applied.
 Firstly, the lack of formal methods to specify problems runs counter to
 the general adoption of such methods in general software engineering.
 Secondly, the ranges of population sizes, generations run and resultant
 program sizes all suggest that GP has only tackled problems with modest
 dimensions.
 Lastly, it showed that software implementations of GP dominate the published
 results.
 These three features all suggest areas of further research, indeed, the
 lack of hardware GP systems was one motivation for the research described
 in this thesis.
\layout Standard

It is not claimed that the taxonomy presented in Chapter 
\begin_inset LatexCommand \ref{main:GP Introduction}

\end_inset 

 is complete but it is given as a starting point for further refinement.
\layout Subsection

High Level Language Hardware Compilation
\layout Standard

The principle benefit of using Handel-C as an implementation language was
 that the implementation could be expressed as an algorithm, rather than
 a structural description of the hardware.
 A second benefit was that the same algorithm could be implemented in both
 hardware and software with minimal changes.
 Being able to re-use the same algorithm for a software implementation and
 for an FPGA was found to be important for three reasons.
 Firstly, it facilitated the initial development of the algorithm in software.
 This is advantageous because using Handel-C meant the hardware development
 process required a longer time to iterate through the design-code-test
 cycle than the software cycle.
 Secondly, because the code can be made portable between Handel-C and ISO-C,
 the porting of the algorithm from the software development environment
 to Handel-C, and vice versa, is simplified, reducing the opportunities
 for errors to be introduced in the porting process.
 Thirdly, it allowed the direct comparison of the algorithm's performance
 when implemented in software and hardware.
 In the published literature of evolutionary computation, most of the previously
 reported comparisons between hardware and software have either used a software
 simulation of the hardware design, or have only used very loosely related
 software algorithm equivalents of the hardware.
\layout Subsection

Random Number Generation for Hardware
\layout Standard

There is a popular theme in the literature of evolutionary computation which
 implies that a very good source of random numbers is essential.
 Previous studies have shown that, given a reasonably good generator, the
 quality of a random number generator is probably not as important as some
 have stated.
 The analysis of the hardware random number generators confirmed that for
 most hardware generators the quality of the generator has little measurable
 effect on the performance of the GP algorithm.
 However, it also showed that a demonstrably poor generator, such as a simple
 linear feedback shift register generator, can impair the performance of
 the GP algorithm.
\layout Standard

In addition to using pseudo random number generators and true random number
 generators, the analysis also showed that using a non-random source of
 numbers allowed the GP algorithm to find solutions, though with a much
 lower probability of success than the pseudo random and truly random generators.
 
\layout Subsection

Economics of Hardware Genetic Programming
\layout Standard

This thesis started with the hypothesis that implementing GP in hardware
 could result in reduced running times for the GP algorithm.
 The experimental evidence shows that it is indeed practical to implement
 GP in hardware and for the implementation to be able to solve some test
 problems in a much shorter time than an equivalent software implementation.
 However, it is unlikely that a hardware GP system would be appropriate
 for all problems and for all classes of user.
 Because the initial investment in hardware and software is significant,
 using hardware GP may not be cost-effective for some problems.
 By considering both the time to run an experiment and the potential for
 running many more experiments in a given time, a method of quantifying
 the cost benefit of using hardware GP has been presented, which allows
 a practitioner to objectively evaluate the usefulness of hardware GP.
\layout Section

Further Work
\layout Subsection

Alternative FPGAs
\layout Subsubsection*

Higher Performance FPGAs
\layout Standard

The design in Chapters 
\begin_inset LatexCommand \ref{main:implementation}

\end_inset 

 and 
\begin_inset LatexCommand \ref{main:Optimised implementation}

\end_inset 

 used the Xilinx XCV2000e device, which was one of the most advanced devices
 available at the time the research was carried out.
 However, technological advances have taken place and the more recent Virtex-II
 FPGAs from Xilinx are bigger and faster than the Virtex-E devices and promise
 even better speedups.
 Initial studies using these devices have indicated that a further speedup
 of two to three times is possible.
 This speedup is achieved by a higher clock rate, up to 420\SpecialChar ~
MHz, and better
 routing resource utilisation.
 The Virtex-II devices also have larger gate counts and bigger on-chip BRAMs.
 The largest of these devices currently available (mid-2002), -- the XC2V8000
 -- has 46\SpecialChar ~
592 slices.
 Early work suggests that this device could accommodate up to 128 parallel
 fitness evaluations for the artificial ant problem, and 256 for the Boolean
 even-6-parity problem.
 These devices also have on-chip multipliers which would make it possible
 to use function sets that require multiplication and division operators,
 often required for regression problems.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cbstart 
\end_inset 

 On-chip multipliers would also mean that other PRNGs could be used, such
 as the Mother PRNG described in 
\begin_inset LatexCommand \prettyref{sec:Random-Number-Generator}

\end_inset 

.
 
\begin_inset ERT
status Collapsed

\layout Standard
 
\backslash 
cbend 
\end_inset 

 The initial indication is that by combining the faster clock frequency
 and more parallel fitness evaluations the ant problem could see a further
 10 times speedup, and the Boolean even-6-parity problem a speedup of 20
 times.
 Further work needs to be carried out to verify this.
 
\layout Subsubsection*

Low Cost FPGAs
\layout Standard

At the other end of the device spectrum, there are some low cost FPGAs that
 may be suitable for embedding into equipment.
 For example, the Spartan range from Xilinx which is fitted to the low cost
 RC100 development board, available from Celoxica.
 This board has a Spartan XC2S200 FPGA which has 5\SpecialChar ~
292 logic cells.
 Initial experiments using this device indicate that it could accommodate
 the hardware GP system.
\layout Subsubsection*

Alternative FPGA Manufacturers
\layout Standard

While this work has used FPGAs from Xilinx, FPGAs are available from a number
 of other manufacturers.
 To date, none of these has been considered for implementing GP.
 However, one of the features of Handel-C is that it is not tied to one
 device manufacturer.
 This allows a single design to be targeted at many different FPGA families,
 often with little or no change to the design.
 For particular applications, other manufacturers devices may offer advantages
 such as gate count, specialised hardware features, speed, power consumption
 or cost.
\layout Subsection

Generalised Design
\layout Standard

As already noted in Chapter 
\begin_inset LatexCommand \ref{main:Economic considerations}

\end_inset 

, the cost in time to make small changes to a GP system in an FPGA can be
 large, so it would seem reasonable to add the means of varying some of
 the run-time parameters for a given design.
 This could be done by supplying them during start-up.
 For example, a design with a fixed maximum population size could have a
 run-time limit below the maximum specified by the host program.
 This would make the technique more useful for exploring particular aspects
 of GP behavior.
 
\layout Standard

Two possible approaches to realising a more general design have been suggested
 in Chapter 
\begin_inset LatexCommand \ref{main:Economic considerations}

\end_inset 

: JBits 
\begin_inset LatexCommand \cite{Sundararajan:2000}

\end_inset 

 and a configurable virtual gate array 
\begin_inset LatexCommand \cite{Sekanina:2000}

\end_inset 

.
 Both these approaches use the idea of being able to reconfigure the FPGA
 so that the logic can be altered externally.
 Another alternative, mentioned in Chapter 
\begin_inset LatexCommand \ref{main:implementation}

\end_inset 

, is to implement a general set of functions, modelled, for example, on
 the Java virtual machine.
 Implementing a virtual machine in hardware would then allow the function
 set and the fitness functions to be compiled externally and then made available
 to the FPGA for execution, without needing to alter the FPGA contents.
 The fitness function could be placed in SRAM and executed directly by the
 FPGA hosted virtual machine.
 However, using this approach is likely to reduce the speedups that are
 obtained when an optimised and problem specific function set is implemented
 in the FPGA.
\layout Subsection

Techniques from Standard Genetic Programming
\layout Standard

Several specialised techniques have been used to facilitate the implementation
 of GP in hardware.
 In particular, the use of a linear representation and the crossover operators
 described in Chapter 
\begin_inset LatexCommand \ref{main:Behavioural analysis}

\end_inset 

.
\layout Standard

The crossover operators investigated in Chapter 
\begin_inset LatexCommand \ref{main:Behavioural analysis}

\end_inset 

 used a linear representation, but from the results in 
\begin_inset LatexCommand \cite{poli:2001:EuroGP_general}

\end_inset 

 similar behavior would be expected when the truncating crossover and the
 single child limiting crossover techniques are applied to standard tree
 based GP.
 This is an area that should be investigated.
\layout Standard

Other techniques have been suggested for controlling the program size during
 evolution such as homologous and size fair operators 
\begin_inset LatexCommand \cite{langdon:1999:fairxo}

\end_inset 

 and smooth operators 
\begin_inset LatexCommand \cite{page:1999:smuxspmGP}

\end_inset 

, which could also be adapted to a hardware implementation.
\layout Standard

The linear representation was used because of its simplicity and regularity.
 Other regular representations that should be straightforward to implement
 in hardware include Cartesian Genetic Programming by Miller and Thompson
 
\begin_inset LatexCommand \cite{miller:2000:CGP}

\end_inset 

.
\layout Subsection

Applications
\layout Standard

In this thesis, hardware GP has been used to implement only a limited number
 of problems.
 To get a more complete picture of the effects of the design decisions,
 and the limitations of the design, more problems would need to be implemented
 and analysed.
\layout Standard

None of the applications described in this thesis, or suggested as future
 applications, require large fitness functions.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cbstart 
\end_inset 

 Although the initial population creation, breeding and support functions
 used around 20% of the chip area, the amount of logic that can be accommodated
 on an FPGA is severely limited.
 
\begin_inset ERT
status Collapsed

\layout Standard
 
\backslash 
cbend 
\end_inset 

 It is therefore not clear how fitness functions that require a lot of computing
 resources will be able to be accommodated on an FPGA.
 For example, Bennett 
\begin_inset LatexCommand \cite{bennet:1996:ices60db}

\end_inset 

 
\begin_inset LatexCommand \cite{bennet:1999:astsaecGP}

\end_inset 

, Koza 
\emph on 
et al.

\emph default 
 
\begin_inset LatexCommand \cite{koza:1996:adtsaec}

\end_inset 


\begin_inset LatexCommand \cite{koza:2000:idas}

\end_inset 


\begin_inset LatexCommand \cite{koza:1997:ascc}

\end_inset 


\begin_inset LatexCommand \cite{koza:1999:aigp3}

\end_inset 

 and others have used one or more Spice circuit simulators to evolve electrical
 circuits.
 It is doubtful whether Spice could be ported to an FPGA using current technolog
ies, so there is going to be a class of problems that would be hard to implement
 completely in hardware.
\layout Standard

None of the applications implemented in this thesis have used floating point
 mathematical functions.
 Although Celoxica provide a fixed point and floating point library with
 Handel-C, no work has yet been done to evaluate how efficiently fitness
 functions that use fixed or floating point arithmetic can be implemented.
 
\layout Standard

Although hardware GP has been shown to give useful speedups for the problems
 already implemented, these are all problems that have already been solved
 by standard GP.
 However, hardware GP offers the opportunity to tackle problems that have
 not yet been considered practical.
 Because the FPGA system has the potential to evaluate individuals in a
 far shorter time than even the fastest Pentium class computers, it becomes
 possible for a GP system to process fast real-time data.
 This would be particularly appropriate where fitness data are available
 only as a real-time data stream, for example in signal processing applications,
 where real-time data, such as telemetry from remote sensors, could be processed
 directly by the FPGA.
 For example, this might find use in applications that need to continuously
 optimise a signal processing algorithm, such as a filter, in response to
 changing conditions, 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cbstart 
\end_inset 

 or where real-time constraints must be met.
 An example of such an applications is scheduling hard disc operations as
 investigated by Turton
\emph on 
 
\emph default 
and Arslan 
\begin_inset LatexCommand \cite{turton:95}

\end_inset 

.
 
\begin_inset ERT
status Collapsed

\layout Standard
 
\backslash 
cbend 
\end_inset 


\layout Standard

FPGAs are typically endowed with a large number of 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
ac{I/O}
\end_inset 

 pins.
 Using these I/O pins, a fitness function implemented in an FPGA would have
 direct access to external signals.
 These pins could, for example, be connected directly to an image sensor
 device, giving the fitness functions direct access to raw image data.
 This would find applications in image recognition problems.
 
\layout Standard

Another interesting possibility for using an FPGA is that the output signals
 can be directly encoded into the function set, thereby opening up the possibili
ty of embedding the GP system and having it directly control hardware devices
 while evaluating the fitness of the programs.
 An example of this would be a robotic control that reads sensor inputs
 directly using some of the I/O pins on the FPGA.
 The evolving programs would then generate control signals directly to the
 robot, again using some of the I/O pins.
 Although FPGAs have previously been embedded in robots, for example in
 
\begin_inset LatexCommand \cite{thompson:1997:er97}

\end_inset 

, 
\begin_inset LatexCommand \cite{seok:2000:arob}

\end_inset 

 and 
\begin_inset LatexCommand \cite{haddow:1999}

\end_inset 

 using hardware GP would mean that the robot's behaviour could be evolved
 using GP without the need for an external PC.
\layout Standard

The applications suggested in this section have only hinted at the possibilities
 made possible by implementing GP in an FPGA.
 It is hoped that the fast execution of the hardware GP algorithm coupled
 with the compact hardware requirements of an FPGA would suggest other applicati
ons of this work.
\layout Section

Conclusions About the Hypothesis
\layout Standard

The research has supported the hypothesis that implementing GP in hardware
 can speedup the operation of the GP algorithm.
 It has also been shown that a hardware GP system reduces the time needed
 to investigate the detailed operation of GP.
 However, the analysis of the economic factors that influence the choice
 of whether to use a hardware or software GP system shows that, although
 a large speedup is possible, a hardware GP system would not be appropriate
 in every application due to the high initial capital cost and the time
 required to develop the GP system.
 Finally, some of the potential applications suggest that hardware GP could
 open up areas of research which would otherwise be impractical for software
 based GP.
 
\the_end
