#LyX 1.2 created this file. For more info see http://www.lyx.org/
\lyxformat 220
\textclass essex
\begin_preamble

\input{shortheader.tex}
\usepackage{url}
\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\float_placement !ht
\paperfontsize default
\spacing single 
\papersize a4paper
\paperpackage a4
\use_geometry 1
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\leftmargin 4cm
\topmargin 2cm
\rightmargin 3cm
\bottommargin 2cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Standard

Chapters 
\begin_inset LatexCommand \ref{main:implementation}

\end_inset 

 and 
\begin_inset LatexCommand \ref{main:Optimised implementation}

\end_inset 

 described two hardware implementations of GP.
 In both cases the work concentrated on the implementation issues and improving
 the clock speed of the implementation, but put to one side the performance
 of the system with respect to its ability to solve GP problems.
 Now that the raw throughput issues have been addressed it is time to look
 at how well the hardware implementation performs, in particular the biases
 introduced by the crossover operator and the 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
acf{RNG}.
\end_inset 


\layout Standard

This chapter begins with an empirical analysis of the crossover operator.
 Three crossover operators that limit the lengths of programs are used;
 the truncating operator used in the work described previously, a standard
 limiting operator that constrains the lengths of both offspring and a new
 limiting operator that only constrains the length of one offspring.
 The latter has some interesting properties that suggest this operator has
 the effect of limiting code growth in the presence of fitness.
 
\layout Standard

In Chapter 
\begin_inset LatexCommand \ref{main:implementation}

\end_inset 

 it was suggested that the RNG should be looked at more closely.
 The behaviour of the 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
acf{LFSR}
\end_inset 

 RNG is analysed and compared to six alternative RNGs.
 The results show that an alternative RNG allows the hardware GP system
 to produce more correct programs.
\layout Section


\begin_inset LatexCommand \label{sec:Analysis-of-the-crossover}

\end_inset 

Analysis of the Crossover Operator
\layout Standard

The hardware design uses a linear program representation with a fixed maximum
 size.
 Choosing a fixed maximum size made the storage of programs in on-chip RAM
 and off-chip RAM efficient and simple to implement.
 Consequently a method of limiting the program size during crossover was
 needed.
 The first implementation, described in the preceding chapters, used a 
\shape italic 
truncating crossover
\shape default 
 operator.
 This is compared to a second method of limiting lengths, called the 
\emph on 
limiting crossover
\emph default 
 operator.
 
\layout Standard

The analysis is performed by running a number of experiments and by comparing
 the results.
 Two different implementations of GP were used for the experiments.
 First, a simple program that simulated the effects of GP crossover was
 used to show the expected program length distributions in the absence of
 fitness using a linear representation.
 This is referred to as the 
\emph on 
GP simulator
\emph default 
.
 Second, the hardware implementation described in Chapter 
\begin_inset LatexCommand \ref{main:Optimised implementation}

\end_inset 

 was used to obtain results both with and without fitness.
 The test problems for all the experiments where fitness is used were the
 artificial ant and the even-6-parity problems described in Chapter 
\begin_inset LatexCommand \ref{main:Optimised implementation}

\end_inset 

.
 In the case of the experiments that do not use fitness, all programs are
 assigned the same fitness value.
 This means that all individuals have the same probability of being selected
 for the breeding phase.
\layout Subsection

Behavioural Analysis
\layout Standard

The measurement of overall GP behavior is frequently limited to plotting
 the average population fitness vs.
 generation.
 This is shown for the artificial ant problem, using the hardware implementation
 described in the previous chapter, in Figure 
\begin_inset LatexCommand \ref{fig:Initial Performance}

\end_inset 

.
 The graph shows the average of 500 runs.
 This will be used as a baseline when looking at changes to the original
 design.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_trunc_lfsr_perf.eps
	display color
	size_type 1
	width 10cm
	height 4.5cm
	rotateOrigin center
	lyxsize_type 1
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:Initial Performance}

\end_inset 

GP performance of the original design for the artificial ant problem.
\end_inset 

However, when looking for the reasons to explain why a feature of an operator
 or representation has an effect, raw performance gives us a very restricted
 view of what is happening, and more analytical methods are needed.
 One such method is to consider one or more aspects of the internal population
 dynamics during a run.
 Recently a lot of work has been done to develop exact schema theories for
 Genetic Programming 
\begin_inset LatexCommand \cite{poli:2001:EuroGP_general}

\end_inset 


\begin_inset LatexCommand \cite{poli:2001:EuroGP_exact}

\end_inset 

, which, among other things, give us a description of the expected changes
 in the program length distribution during a GP run.
 The asymptotic distribution of program lengths is important to us because
 it is a way of comparing the sampling behavior (search bias) of different
 crossover operators and replacement strategies.
\layout Standard

Starting with the standard GP model using standard subtree crossover, uniform
 initial length distribution and ignoring the effects of fitness, Figure
 
\begin_inset LatexCommand \ref{fig:DIST sim stdgp}

\end_inset 

 shows the expected length distribution for generations 0,1,10 and 31.
 The population was initialised using a uniform random distribution of lengths
 between 1 and 31 inclusive.
 In this case there is no maximum program size.
 This agrees with the results in 
\begin_inset LatexCommand \cite{poli:2001:EuroGP_exact}

\end_inset 

 where the distribution asymptotically converges to a discrete Gamma distributio
n.
 The mean program length at generation 31 is 16.
 Note, only program lengths 1 -- 32 are shown in the graph, but the tail
 continues towards infinity.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/sim_nofit_stdgp.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 10cm
	lyxheight 4.5cm
\end_inset 


\layout ShortCaption

Length distribution for standard GP with no fitness.
\layout Caption


\begin_inset LatexCommand \label{fig:DIST sim stdgp}

\end_inset 

Program length distribution for standard GP crossover operating on linear
 strings , using a global replacement strategy, non-steady state and no
 fitness, using the GP simulator.
 Average of 500 runs.
\end_inset 


\layout Subsection


\begin_inset LatexCommand \label{sec:Truncating crossover}

\end_inset 

Truncating Crossover Operator
\layout Standard

This crossover operator (described in Chapter 
\begin_inset LatexCommand \ref{main:implementation}

\end_inset 

, Section 
\begin_inset LatexCommand \ref{sub:Cross-over-1}

\end_inset 

) ensures programs do not exceed the maximum program length by selecting
 crossover points in two individuals at random and exchanging the tail portions
 up to the maximum program length.
 Crossovers that result in programs exceeding the maximum length are truncated
 at the maximum length.
\layout Standard

The behavior of the hardware implementation using the truncating crossover
 operator, without fitness, is shown in Figure 
\begin_inset LatexCommand \ref{fig:DIST hw nofit trunc}

\end_inset 

.
 
\layout Standard


\begin_inset Float figure
placement h
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_nofit_trunc.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 1
	lyxwidth 12cm

\end_inset 


\layout ShortCaption

Length distribution using truncating crossover without fitness from hardware
 GP.
\layout Caption
\paragraph_spacing single 


\begin_inset LatexCommand \label{fig:DIST hw nofit trunc}

\end_inset 

Program length distribution using truncating crossover using a linear program
 representation without fitness.
 From the hardware implementation of the artificial ant problem.
 Average of 500 runs.
\end_inset 


\layout Standard

A feature of this result is that there is initially a large peak at the
 maximum program size of 31, but in subsequent generations the distribution
 tends to resemble a Gamma distribution like the one in 
\begin_inset LatexCommand \ref{fig:DIST sim stdgp}

\end_inset 

.
 However, it is important to note that it not the same Gamma distribution,
 because the mean program length tends to decrease with this crossover operator.
 The reason is that with the truncation the amount of genetic material removed
 from the parents when creating the offspring may be bigger than the amount
 of genetic material replacing it.
 At generation 31 the mean program length is 12.5, down from the initial
 mean length of 16.
\layout Standard

When fitness is used, the length distribution for the artificial ant problem
 changes as shown in Figure 
\begin_inset LatexCommand \ref{fig:DIST hw fit trunc}

\end_inset 

, but it still retains some of the features of a Gamma distribution.
 The striking feature is the large peak at the maximum program length limit
 which represents 13% of the total population at generation 31.
 At generation 31, the mean program length is 16.5, up from the initial mean
 value of 16.
\layout Standard

The corresponding result from the Boolean even-6-parity problem is shown
 in Figure 
\begin_inset LatexCommand \ref{fig:DIST hw fit trunc bool}

\end_inset 

, which also shows a large peak at the maximum program length of 255.
 At generation 63, the mean program length is 144, up from the initial mean
 value of 128.
\layout Standard


\begin_inset Float figure
placement h
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_fit_trunc.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Length distribution using truncating crossover for ant problem.
\layout Caption


\begin_inset LatexCommand \label{fig:DIST hw fit trunc}

\end_inset 

Program length distribution using truncating crossover using a linear program
 representation with fitness.
 From the hardware implementation of the artificial ant problem.
\end_inset 


\begin_inset Float figure
placement h
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_bool_parity_truncate.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Length distribution using truncating crossover for parity problem.
\layout Caption


\begin_inset LatexCommand \label{fig:DIST hw fit trunc bool}

\end_inset 

Program length distribution using truncating crossover using a linear program
 representation with fitness.
 From the hardware implementation of the Boolean even-6-parity problem.
 Average of 500 runs.
\end_inset 


\layout Subsection

Limiting Crossover Operator
\layout Standard

An alternative method of ensuring that programs do not exceed the fixed
 limit is to repeatedly choose crossover points until the lengths of both
 child programs are below the program size limit 
\begin_inset Formula $L_{\mathrm{max}}$
\end_inset 

.
 For two programs 
\begin_inset Formula $a$
\end_inset 

 and 
\begin_inset Formula $b$
\end_inset 

, with lengths 
\begin_inset Formula $l_{a}$
\end_inset 

 and 
\begin_inset Formula $l_{b}$
\end_inset 

, two crossover points 
\begin_inset Formula $x_{a}$
\end_inset 

 and 
\begin_inset Formula $x_{b}$
\end_inset 

 are chosen so that 
\begin_inset Formula $0\leq x_{a}<l_{a}$
\end_inset 

 and 
\begin_inset Formula $0\leq x_{b}<l_{b}$
\end_inset 

.
 After crossover, the new lengths are simply 
\begin_inset Formula $l_{a}'=x_{a}+l_{b}-x_{b}$
\end_inset 

 and 
\begin_inset Formula $l_{b}'=x_{b}+l_{a}-x_{a}$
\end_inset 

.
 If 
\begin_inset Formula $l_{a}'>L_{\mathrm{max}}$
\end_inset 

 or 
\begin_inset Formula $l_{b}'>L_{\mathrm{max}}$
\end_inset 

 the selection of 
\begin_inset Formula $x_{a}$
\end_inset 

 and 
\begin_inset Formula $x_{b}$
\end_inset 

 is repeated until 
\begin_inset Formula $l_{a}'\le L_{\mathrm{max}}$
\end_inset 

 AND 
\begin_inset Formula $l_{b}'\le L_{\mathrm{max}}$
\end_inset 

.
 Because both child programs are required to be shorter than 
\begin_inset Formula $L_{\mathrm{max}}$
\end_inset 

 this operator is termed the 
\shape italic 
dual-child limiting
\shape default 
 crossover operator.
\layout Standard

This is the approach taken in lilgp (versions 1.02 and 1.1) when the 
\family typewriter 
keep_trying
\family default 
 parameter is enabled 
\begin_inset LatexCommand \cite{zonger:1996:lilgp}

\end_inset 

 to limit the tree depth and the total number of nodes in a program tree
 during crossover.
\layout Standard

When this method of limiting the program length was implemented in the hardware
 version, but without fitness, we obtained the distribution shown in Figure
 
\begin_inset LatexCommand \ref{fig:DIST hw nofit limit dual}

\end_inset 

.
 The mean program lengths for all generations is 16.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_nofit_limit.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Length distribution using dual child limiting crossover for ant problem.
\layout Caption


\begin_inset LatexCommand \label{fig:DIST hw nofit limit dual}

\end_inset 

Program length distribution using limiting crossover without fitness, from
 the hardware implementation of the artificial ant problem.
 Average of 500 runs.
\end_inset 


\layout Standard

When fitness is enabled using the dual-child variant for the artificial
 ant problem, there is a bias in favor of longer programs, as shown in Figure
 
\begin_inset LatexCommand \ref{fig:DIST hw fit limit dual}

\end_inset 

.
 A feature of the results for the artificial ant problem is the sharp rise
 in program lengths for generations 10 and 31 above length 15, and the peak
 after length 15.
 This is likely to be due to the distribution of fitness in the program
 search space and can be seen as a form of what is commonly termed bloat.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cbstart 
\end_inset 

Bloat is the term given to the tendency of GP programs to grow in length
 without any increase in their fitness.
 This tendency is well documented in the GP literature 
\begin_inset LatexCommand \cite{koza:book}

\end_inset 


\begin_inset LatexCommand \cite{BT94}

\end_inset 


\begin_inset LatexCommand \cite{Nordin:1995:cce}

\end_inset 


\begin_inset LatexCommand \cite{soule:thesis}

\end_inset 


\begin_inset LatexCommand \cite{luke:2000:cgnci}

\end_inset 


\begin_inset LatexCommand \cite{langdon:1997:bloatSAHCP}

\end_inset 

.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cbend 
\end_inset 

At generation 31, the mean program length has increased to 20.3, up from
 the initial mean length of 16.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_fit_limit.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Length distribution using dual child limiting crossover for ant problem.
\layout Caption


\begin_inset LatexCommand \label{fig:DIST hw fit limit dual}

\end_inset 

Program length distribution using limiting crossover with fitness and the
 dual-child variant.
 From the hardware implementation of the artificial ant problem.
 Average of 500 runs.
\end_inset 


\layout Standard

The results for the Boolean even-6-parity problem are shown in Figure 
\begin_inset LatexCommand \ref{fig:DIST hw fit limit dual bool}

\end_inset 

, which also exhibits a similar peak of program lengths.
 At generation 63, the mean program length has increased to 162, up from
 the initial mean length of 128.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_bool_parity_dual.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 181pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Length distribution using dual child limiting crossover for parity problem.
\layout Caption


\begin_inset LatexCommand \label{fig:DIST hw fit limit dual bool}

\end_inset 

Program length distribution using limiting crossover with fitness and the
 dual-child variant.
 From the hardware implementation of the even-6-parity problem.
 Average of 500 runs.
\end_inset 


\layout Subsection

Modified Limiting Crossover Operator
\layout Standard

The above crossover operator (dual-child limiting) requires both of the
 child programs to have lengths less than 
\begin_inset Formula $L_{\mathrm{max}}$
\end_inset 

.
 A variation of this operator is to require only one of the child programs
 to be shorter than 
\begin_inset Formula $L_{\mathrm{max}}$
\end_inset 

.
 That is, the selection of 
\begin_inset Formula $x_{a}$
\end_inset 

 and 
\begin_inset Formula $x_{b}$
\end_inset 

 is repeated until 
\begin_inset Formula $l_{a}'\le L_{\mathrm{max}}$
\end_inset 

 OR 
\begin_inset Formula $l_{b}'\le L_{\mathrm{max}}$
\end_inset 

.
 If one of the child programs is larger than the maximum, it is simply discarded
 and the parent substituted in its place.
 This is termed the 
\shape italic 
single-child limiting
\shape default 
 crossover operator.
 When the hardware implementation was modified to incorporate the single-child
 limiting operator, the result without fitness is shown in Figure 
\begin_inset LatexCommand \ref{fig:DIST hw nofit limit single}

\end_inset 

 was obtained.
 A feature of this result is that the mean program length moves towards
 smaller values.
 At generation 31, the mean program length is 11.5, down from the initial
 mean length of 16.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_nofit_limit_single.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Length distribution using single child limiting crossover without fitness.
\layout Caption


\begin_inset LatexCommand \label{fig:DIST hw nofit limit single}

\end_inset 

Program length distribution using limiting crossover without fitness and
 the single-child variant.
 From the hardware implementation of the artificial ant problem.
 Average of 500 runs.
\end_inset 


\layout Standard

However, when the program length distribution using the single-child variant
 was plotted for the artificial ant problem, shown in Figure 
\begin_inset LatexCommand \ref{fig:DIST hw fit limit single}

\end_inset 

, the length distribution peaks closer to the mean of 
\begin_inset Formula $L_{\mathrm{max}}$
\end_inset 

.
 At generation 31 the mean program length is 17.2.
 This behavior is interesting since it appears to have avoided the phenomenon
 commonly known as bloat.
 The corresponding plot for the Boolean even-6-parity problem is shown in
 Figure 
\begin_inset LatexCommand \ref{fig:DIST hw fit limit single bool}

\end_inset 

.
 Again there is a peak of lengths near the mean of 
\begin_inset Formula $L_{\mathrm{max}}$
\end_inset 

.
 At generation 63, the mean program length is 140, up from the initial mean
 length of 128.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_fit_limit_single.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Length distribution using single child limiting crossover for ant problem.
\layout Caption


\begin_inset LatexCommand \label{fig:DIST hw fit limit single}

\end_inset 

Program length distribution using limiting crossover with fitness and the
 single-child variant.
 From the hardware implementation of the artificial ant problem.
 Average of 500 runs.
\end_inset 


\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_bool_parity_single.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 181pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Length distribution using single child limiting crossover for parity problem.
\layout Caption


\begin_inset LatexCommand \label{fig:DIST hw fit limit single bool}

\end_inset 

Program length distribution using limiting crossover with fitness and the
 single-child variant.
 From the hardware implementation of the even-6-parity problem.
 Average of 500 runs.
\end_inset 


\layout Standard

In both examples of the single child limiting crossover with fitness, the
 plots (Figures 
\begin_inset LatexCommand \ref{fig:DIST hw fit limit single}

\end_inset 

 and 
\begin_inset LatexCommand \ref{fig:DIST hw fit limit single bool}

\end_inset 

) are less smooth than the dual child limiting crossover results (Figures
 
\begin_inset LatexCommand \ref{fig:DIST hw fit limit dual}

\end_inset 

 and 
\begin_inset LatexCommand \ref{fig:DIST hw fit limit dual bool}

\end_inset 

).
 The plots for the single child limiting crossover suggest some form of
 instability, suggesting an area for future research.
\layout Standard

The effect of using the limiting crossover operator with and without the
 single-child variant on the mean population fitness using the artificial
 ant problem is shown in Figure 
\begin_inset LatexCommand \ref{fig:PERF combined}

\end_inset 

 together with the original mean population fitness.
 This graph shows that all three crossover implementations have a similar
 rate of improvement, with the limiting crossover operator with single-child
 variant maybe performing slightly better on the artificial ant problem.
\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_limit_lfsr_single_perf.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Comparative GP behaviour for ant problem.
\layout Caption


\begin_inset LatexCommand \label{fig:PERF combined}

\end_inset 

Comparative mean population fitness of the hardware implementation for the
 artificial ant problem using truncating crossover, dual child limiting
 crossover and single child limiting crossover.
 Average of 500 runs.
\end_inset 


\layout Standard

Finally, the distribution of 100% correct program lengths was measured for
 truncating and both limiting crossovers.
 The hardware implementation was run 500 times, and if a 100% correct program
 was generated, the length was recorded.
 These are shown in Figures 
\begin_inset LatexCommand \ref{fig:LEN truncate}

\end_inset 

, 
\begin_inset LatexCommand \ref{fig:LEN limit dual}

\end_inset 

 and 
\begin_inset LatexCommand \ref{fig:LEN limit single}

\end_inset 

 respectively for the artificial ant problem.
 
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_trunc_lengths.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Lengths of programs using truncating crossover for ant problem.
\layout Caption


\begin_inset LatexCommand \label{fig:LEN truncate}

\end_inset 

Distribution of lengths of 100% correct programs using the truncating crossover
 operator for the artificial ant problem over 500 runs.
\end_inset 


\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_limit_lengths.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Lengths of programs using dual child limiting crossover for ant problem.
\layout Caption


\begin_inset LatexCommand \label{fig:LEN limit dual}

\end_inset 

Distribution of lengths of 100% correct programs using the dual-child variant
 limiting crossover operator for the artificial ant problem over 500 runs.
\end_inset 


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_limit_lengths_single.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Lengths of programs using single child crossover for ant problem.
\layout Caption


\begin_inset LatexCommand \label{fig:LEN limit single}

\end_inset 

Distribution of lengths of 100% correct programs using the the single-child
 variant limiting crossover operator for the artificial ant problem over
 500 runs.
\end_inset 

These plots show that truncating crossover has allowed GP to find more 100%
 correct programs than the limiting crossover using the dual-child variant.
 However, when using the single-child variant, limiting crossover found
 the most 100% correct programs.
 It is interesting to note that the results shown in Figure 
\begin_inset LatexCommand \ref{fig:PERF combined}

\end_inset 

 do not show this difference in the outcome, highlighting the weakness of
 using the standard measure of performance.
\layout Standard

The corresponding program plots for the Boolean even-6-parity problem are
 shown in Figures 
\begin_inset LatexCommand \ref{fig:LEN truncate bool}

\end_inset 

, 
\begin_inset LatexCommand \ref{fig:LEN limit dual bool}

\end_inset 

 and 
\begin_inset LatexCommand \ref{fig:LEN limit single bool}

\end_inset 

 for the truncate, dual-child limiting and the single-child limiting crossovers
 respectively.
 Again, from these results the truncating crossover has produced more 100%
 correct programs than the limiting crossover using the dual child variant,
 and the single child variant has produced the most 100% correct programs,
 though the difference is not as marked as for the artificial ant problem.
 This is possibly due to the fact that the parameters chosen for the Boolean
 even-6-parity problem were more favourable to finding a solution than the
 artificial ant problem.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_bool_parity-6_lengths-truncate.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 181pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Lengths of programs using truncating crossover for parity problem.
\layout Caption


\begin_inset LatexCommand \label{fig:LEN truncate bool}

\end_inset 

Distribution of lengths of 100% correct programs using the truncating crossover
 operator for the Boolean even-6-parity problem over 500 runs.
\end_inset 


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_bool_parity-6_lengths-dual.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 181pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Lengths of programs using dual child limiting crossover for parity problem.
\layout Caption


\begin_inset LatexCommand \label{fig:LEN limit dual bool}

\end_inset 

Distribution of lengths of 100% correct programs using the dual-child variant
 limiting crossover operator for the even-6-parity problem over 500 runs.
\end_inset 


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_bool_parity-6_lengths-256.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 181pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Lengths of programs using single child limiting crossover for parity problem.
\layout Caption


\begin_inset LatexCommand \label{fig:LEN limit single bool}

\end_inset 

Distribution of lengths of 100% correct programs using the the single-child
 variant limiting crossover operator for the even-6-parity problem over
 500 runs.
\end_inset 


\layout Subsection

Tuning the Maximum Length Parameter
\layout Standard

The results shown in Figures 
\begin_inset LatexCommand \ref{fig:LEN truncate}

\end_inset 

, 
\begin_inset LatexCommand \ref{fig:LEN limit dual}

\end_inset 

 and 
\begin_inset LatexCommand \ref{fig:LEN limit single}

\end_inset 

 suggest that for the artificial ant problem implemented in hardware, programs
 of length 4 or 5 are most likely to be correct, though this can only be
 confirmed by either exhaustively testing every possible program or by randomly
 sampling all possible programs.
 It was then observed that the peak program length in Figure 
\begin_inset LatexCommand \ref{fig:DIST hw fit limit single}

\end_inset 

 was larger than length 4.
 It was then conjectured that if the maximum program length was changed
 so that the peak was moved so that it was closer to the most frequently
 successful program, that GP would find even more successful programs.
 The experiments using the artificial ant problem using the single child
 limiting crossover were repeated but using maximum lengths of 16 and 8.
 The results of running the hardware implementation with these modified
 lengths are shown in Figures 
\begin_inset LatexCommand \ref{fig:LEN limit single 16}

\end_inset 

 and 
\begin_inset LatexCommand \ref{fig:LEN limit single 8}

\end_inset 

 for maximum lengths 16 and 8 respectively.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_limit_lengths_single_16.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Lengths of programs for ant problem, max length = 16.
\layout Caption


\begin_inset LatexCommand \label{fig:LEN limit single 16}

\end_inset 

Distribution of lengths of 100% correct programs using the the single-child
 variant limiting crossover operator and a length limit of 16 for the artificial
 ant problem over 500 runs.
\end_inset 


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_limit_lengths_single_8.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Lengths of programs for ant problem, max length = 8.
\layout Caption


\begin_inset LatexCommand \label{fig:LEN limit single 8}

\end_inset 

Distribution of lengths of 100% correct programs using the the single-child
 variant limiting crossover operator and a length limit of 8 for the artificial
 ant problem over 500 runs.
\end_inset 

 \SpecialChar ~
This confirmed the idea that by limiting the program lengths that GP is
 allowed to create, that GP could create more 100% correct programs.
 The corresponding program length distributions are shown in Figures 
\begin_inset LatexCommand \ref{fig:DIST hw fit limit single 16}

\end_inset 

 and 
\begin_inset LatexCommand \ref{fig:DIST hw fir limit single 8}

\end_inset 

.
 Again these show that the program length distribution peaks near the peak
 of the successful programs.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_fit_limit_single-16.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Length distribution for ant problem, max length = 16.
\layout Caption


\begin_inset LatexCommand \label{fig:DIST hw fit limit single 16}

\end_inset 

Program length distribution using limiting crossover with fitness and the
 single-child variant.
 Maximum length limited to 16.
 From the hardware implementation of the artificial ant problem over 500
 runs.
\end_inset 


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/hw_fit_limit_single-8.eps
	display color
	size_type 1
	width 10cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0
	lyxwidth 226pt
	lyxheight 127pt
\end_inset 


\layout ShortCaption

Length distribution for ant problem, max length = 8.
\layout Caption


\begin_inset LatexCommand \label{fig:DIST hw fir limit single 8}

\end_inset 

Program length distribution using limiting crossover with fitness and the
 single-child variant.
 Maximum length limited to 8.
 From the hardware implementation of the artificial ant problem over 500
 runs.
\end_inset 

 
\layout Section

Discussion
\layout Standard

The differences between the dual-child and single-child variants can be
 explained by considering first the dual-child case.
 Starting with a uniform distribution of program lengths, the average program
 length is given by 
\begin_inset Formula $L_{\mathrm{avg}}=\frac{L_{\mathrm{max}}}{2}$
\end_inset 

 and the average crossover point is 
\begin_inset Formula $\frac{L_{\mathrm{avg}}}{2}$
\end_inset 

.
 Every crossover produces two offspring, the average length of which is
 
\begin_inset Formula $\frac{L_{\mathrm{max}}}{2}$
\end_inset 

, with one small and one large program produced.
 When one of the offspring exceeds 
\begin_inset Formula $L_{\mathrm{max}}$
\end_inset 

 both crossover points are re-selected until both programs satisfy the length
 constraint.
 The result is that the average program length using this crossover will
 remain 
\begin_inset Formula $\frac{L_{\mathrm{max}}}{2}$
\end_inset 

.
 However, in the single-child case, only one child needs to meet the length
 constraint.
 With one long and one short offspring, the short offspring will be more
 likely to satisfy the constraint and so be retained for propagation.
 Because the shorter program is preferred, the mean program length will
 tend to continually decrease.
 In summary, in the absence of fitness, the single-child variant selects
 programs that are on average smaller than 
\begin_inset Formula $\frac{L_{\mathrm{max}}}{2}$
\end_inset 

.
\layout Standard

In the presence of fitness we believe that this pressure to decrease the
 mean program length competes with the well documented tendency of GP programs
 to grow in the presence of fitness in a variety of problems.
 The result is that when using the single length constraint and an upper
 bound on the program length, the program length distribution does not have
 a strong bias to longer lengths and is more likely to remain in an equilibrium.
\layout Standard

A side effect of using the single child variant is that when a long program
 is rejected, a copy of the parent is propagated to the next generation.
 This means that even if crossover is used as the only operator, a proportion
 of reproduction will be present.
 The effect of this bias has not been investigated.
\layout Standard

A practical penalty of the dual child limiting crossover approach is that
 multiple passes may be required to obtain two crossover points that satisfy
 the length constraints.
 Depending on the implementation this could have an impact on the time needed
 to complete a GP run.
 In practice, for most problems the time required for crossover in a standard
 GP system is much smaller that the time for evaluating programs, and so
 will only extend the time required by a small factor.
 In the hardware implementation, crossover is performed in parallel with
 evaluation, so there will be no impact for most problems, where fitness
 evaluation takes longer than selection and breeding.
 For the artificial ant problem and the Boolean even-6-parity problem implemente
d in hardware, the limiting crossover operators did not have any effect
 on the overall behavior of the design, both the clock speed and number
 of clock cycles remained the same as the truncating crossover implementation.
 It is worth noting that the single-child limiting crossover will need zero
 iterations to find a legal offspring, so this will have a smaller effect
 on the overall performance in a serial implementation of the algorithm.
\layout Standard

The effect of adjusting the program length limit so that the peak in the
 length distribution is closer to the peak of correct program lengths suggests
 that allowing programs to be unlimited in length may be detrimental to
 using GP effectively because of the time needed for carrying out unnecessary
 processing.
\layout Standard

The speedup that hardware GP had over a software implementation meant that
 it was feasible to perform 500 runs of the experiments in a reasonable
 time.
 Using the elapsed times from Table 
\begin_inset LatexCommand \vref{table:Results of running the 6-parity problem}

\end_inset 

, and ignoring the overhead of the scripts used to run the experiments,
 500 runs of the Boolean even-6-parity problem took 
\begin_inset Formula $1.18\times 500=590$
\end_inset 

\SpecialChar ~
s, or nearly 10 minutes.
 Using a software implementation on a processor running at 1\SpecialChar ~
GHz would have
 required 
\begin_inset Formula $454/5\times 500=45\, 400$
\end_inset 

\SpecialChar ~
s or nearly 12 hours.
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
newpage
\end_inset 


\layout Section


\begin_inset LatexCommand \label{sec: RNG performance}

\end_inset 

Analysis of the Random Number Generator
\layout Standard

This section analyses the 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
acf{RNG}
\end_inset 

, or more correctly the 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
acf{PRNG},
\end_inset 

 chosen for the work in Chapters 
\begin_inset LatexCommand \ref{main:implementation}

\end_inset 

, 
\begin_inset LatexCommand \ref{main:Optimised implementation}

\end_inset 

 and Section 
\begin_inset LatexCommand \ref{sec:Analysis-of-the-crossover}

\end_inset 

 of this chapter.
 The behaviour of the system is then compared using several other RNGs.
 This section starts with a survey of RNGs and PRNGs that have previously
 been used to generate random or pseudo-random sequences in hardware.
\layout Subsection

Previous Work on Random Number Generator Quality
\layout Standard

The effect of RNG quality on the performance of GA and GP has been investigated
 in 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cite{meysenburg:thesis}
\end_inset 

,
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cite{meysenburg:1997}
\end_inset 

, 
\begin_inset LatexCommand \cite{meysenburg:1999:RGPR}

\end_inset 

,
\begin_inset LatexCommand \cite{meysenburg:1999:RGQGP}

\end_inset 

,
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cite{Meyesenburg:2002:gecco}
\end_inset 

,
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cite{daida:1997:vrmGP}
\end_inset 

,
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cite{daida:1999:CVRMCGPGM}
\end_inset 

 and 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cite{Cantu-Paz2:2002:gecco}
\end_inset 

.
 The general conclusions from these investigations are that the RNG used
 can have an effect on the performance of GAs and GP.
 However, the effect is often statistically insignificant.
 Furthermore, the effect is not always correlated with the quality of the
 RNG, as measured using standard statistical tests.
\layout Subsection

Previous Work on Using Random Number Generators in Hardware
\layout Standard

There are three dominant methods of generating random or pseudo-random sequences
 in hardware: LFSR or Tauseworth generators, generators based on 
\begin_inset ERT
status Open

\layout Standard

\backslash 
ac{CA}
\end_inset 

, and generators that exploit a physical noisy phenomenon such as the noise
 from an electrical circuit, radioactive decay or atmospheric radio noise.
\layout Subsubsection*

LFSR generators
\layout Standard

These were used by Maruyama 
\shape italic 
et al.

\shape default 
 
\begin_inset LatexCommand \cite{maruyama:19}

\end_inset 

.
 In their paper they referred to the generator as a m-sequence, or maximal
 sequence.
 This means that the generator of length 
\begin_inset Formula $n$
\end_inset 

 generates 
\begin_inset Formula $2^{n}-1$
\end_inset 

 numbers.
 Graham 
\begin_inset LatexCommand \cite{Graham:96}

\end_inset 

 implemented a single cycle LFSR.
\layout Standard

An interesting hybrid was used by Tommiska and Vuori 
\begin_inset LatexCommand \cite{tommiska:1996}

\end_inset 

 where three coupled LFSRs were used to provide a random sequence.
 An interesting feature of this work is that the RNG was combined with a
 source of noise.
 The amplified noise from a diode was fed into an analogue to digital converter,
 and the resulting digital values were used to seed the RNG, and also added
 to the LFSR at intervals to perturb its state.
\layout Standard

The manufacturers of FPGAs provide example designs of LFSRs to be used as
 random sequence generators.
 For example Xilinx 
\begin_inset LatexCommand \cite{xilinx:rng:2001}

\end_inset 

, and Altera 
\begin_inset LatexCommand \cite{altera:2001}

\end_inset 

 provide 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
acf{HDL}
\end_inset 

 code for LFSRs.
\layout Subsubsection*


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
ac{CA}
\end_inset 

 generators
\layout Standard

Aporntewan 
\begin_inset LatexCommand \cite{aporntewan:2001}

\end_inset 

 used a one dimensional 2-state CA.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cbstart 
\end_inset 

 Scott 
\begin_inset LatexCommand \cite{scott:1994}

\end_inset 

 used a CA that consisted of 16 cells with 2 different rules as described
 by Wolfram 
\begin_inset LatexCommand \cite{wolfram:1984}

\end_inset 

.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cbend 
\end_inset 

 Shackleford 
\shape italic 
et al.

\shape default 
 
\begin_inset LatexCommand \cite{shackleford:2001}

\end_inset 

 implemented a CA based on the work by Wolfram 
\begin_inset LatexCommand \cite{Wolfram:1986}

\end_inset 

.
 Yoshida 
\shape italic 
et al.

\shape default 
 
\begin_inset LatexCommand \cite{yoshida:2001}

\end_inset 

 also used a CA system combining two CAs that used two different rules.
 
\layout Subsubsection*

Other generators
\layout Standard

L'Ecuyer in 
\begin_inset LatexCommand \cite{Lecuyer:1988}

\end_inset 

 and 
\begin_inset LatexCommand \cite{Lecuyer:1990}

\end_inset 

 showed that a lagged Fibonacci generator gives better results than other
 generators.
 However, Chu and Jones 
\begin_inset LatexCommand \cite{pong:1999}

\end_inset 

 showed that when implemented in an FPGA, a lagged Fibonacci generator requires
 a large amount of FPGA resources and that LFSRs are much more space efficient.
\layout Standard

As already noted, Tommiska and Vuori 
\begin_inset LatexCommand \cite{tommiska:1996}

\end_inset 

 used the noise from a diode to provide a source of true randomness to seed
 the LFSR generator.
 The generator was also perturbed at intervals using the same random noise
 source.
 It would appear that digital circuits, clocked at a regular frequency,
 would themselves make poor random number generators, but the physics of
 semiconductor devices means that there is always a low-level of noise introduce
d into digital semiconductor circuits.
 This can be exploited to produce random sequences, as demonstrated by Fairfield
 
\shape italic 
et al.

\shape default 
 
\begin_inset LatexCommand \cite{fairfield:1984}

\end_inset 

, by exploiting the frequency instabilities inherent in LSI devices.
 However, they report that the generator is slow -- producing random integers
 at a rate of around 3 bytes per second.
 Thermal noise is another frequently used method of generating random sequences
 and was used by Bright and Turton 
\begin_inset LatexCommand \cite{bright:2000}

\end_inset 

.
\layout Standard

Other examples of generators that have used natural sources of noise include
 the radioactive beta decay of radioactive isotopes such as Krypton-85 
\begin_inset LatexCommand \cite{fourmilab:2002}

\end_inset 

 and the visually interesting patterns generated by Lava lamps 
\begin_inset LatexCommand \cite{lavarand:2002}

\end_inset 

.
\layout Standard

Because generators that use natural noise are often slow,  they have the
 drawback that they are unable to generate random numbers at a high enough
 rate to be used as the primary source in an evolutionary algorithm, so
 instead they are often used to seed and/or perturb the standard PRNGs.
 They also often require specialised hardware to implement them.
\layout Subsection


\begin_inset LatexCommand \label{sub:RNG-method}

\end_inset 

Experimental Setup
\layout Standard

The performance of the various RNGs in this section was evaluated using
 three methods: using the Diehard test suite, using the artificial ant problem
 from Chapter 
\begin_inset LatexCommand \ref{main:Optimised implementation}

\end_inset 

 and using Handel-C to implement the generators.
\layout Subsubsection*

Diehard test suite
\layout Standard

The Diehard test suite maintained by Marsaglia 
\begin_inset LatexCommand \cite{diehard:2001}

\end_inset 

 is a de-facto standard for evaluating RNGs and was used to gauge the general
 performance of the RNG.
 The suite consists of up to 15 tests that are modeled on applications of
 random numbers.
 All the RNGs considered in this paper were implemented in ISO-C and were
 submitted to all 15 tests.
 The test method for Diehard is similar to that described in Meysenburg
 and Foster 
\begin_inset LatexCommand \cite{meysenburg:1999:RGQGP}

\end_inset 

.
 Each RNG was used to generate a binary file of about 10\SpecialChar ~
MiB.
 Each Diehard test produces one or more 
\begin_inset Formula $p$
\end_inset 

-values
\begin_inset Foot
collapsed false

\layout Standard


\begin_inset Formula $p$
\end_inset 

-values are given by 
\begin_inset Formula $p=F(X)$
\end_inset 

, where 
\begin_inset Formula $F$
\end_inset 

 is the assumed distribution of the sample random variable 
\begin_inset Formula $X$
\end_inset 

 --- often normal.
 The 
\begin_inset Formula $p$
\end_inset 

-value should be uniform on 
\begin_inset Formula $[0,1)$
\end_inset 

 if the input file contains truly independent random bits.
\end_inset 

.
 A 
\begin_inset Formula $p$
\end_inset 

-value can be considered good, bad, or suspect.
 Meysenburg used a scheme by Johnson 
\begin_inset LatexCommand \cite{Johnson:1996}

\end_inset 

 which assigns a score to a 
\begin_inset Formula $p$
\end_inset 

-value as follows.
 If 
\begin_inset Formula $p\geq 0.998$
\end_inset 

 then it is classified as bad.
 If 
\begin_inset Formula $0.95\leq p<0.998$
\end_inset 

 then it is classified as suspect.
 All other 
\begin_inset Formula $p$
\end_inset 

-values are classified as good.
 Using this classification, every bad 
\begin_inset Formula $p$
\end_inset 

-value scores 4, every suspect 
\begin_inset Formula $p$
\end_inset 

-value scores 2 and good 
\begin_inset Formula $p$
\end_inset 

-values score zero.
 For each RNG, the scores for each test were summed, and the total for each
 RNG is the sum of all the test scores for that RNG.
 Using this scheme, high scores indicate a poor RNG and low scores indicate
 a good RNG.
 The results for each test are given in Appendix 
\begin_inset LatexCommand \ref{main:Random number generator test results}

\end_inset 

.
\layout Subsubsection*

Incorporation of RNGs into hardware GP
\layout Standard

Each RNG was then incorporated into the hardware GP system described in
 Chapter 
\begin_inset LatexCommand \ref{main:Optimised implementation}

\end_inset 

 using the artificial ant problem with the Santa Fe trail.
 The problem was run 500 times, and the number of correct programs that
 appeared was recorded.
 This is used as a measure of how well the RNG performs in a GP system.
 In all cases, the population size is 1024, the maximum program length is
 31 and all experiments were run for 31 generations.
 The ant was allocated 600 timesteps.
 The probability of selecting crossover was 66%, mutation 12.5% and reproduction
 21.5%.
 The crossover operator used the truncating method of limiting the maximum
 program length, as described in Section 
\begin_inset LatexCommand \ref{sec:Truncating crossover}

\end_inset 

.
\layout Subsubsection*

RNG implementation using Handel-C
\layout Standard

Each RNG was also implemented as a stand alone application for an FPGA using
 Handel-C, and the number of slices used and the maximum attainable clock
 frequency was recorded.
 This gives a measure of the hardware resources needed to implement the
 RNG, and also an indication of the logic depth required.
\layout Section


\begin_inset LatexCommand \label{sec:Random-Number-Generator}

\end_inset 

Random Number Generator Implementations
\layout Standard

This section considers several different RNGs including the generators commonly
 used in hardware implementations.
\layout Subsection

LFSR RNG
\layout Standard

The details of the LFSR generator have already been given in Section 
\begin_inset LatexCommand \vref{sec:LFSR-Random-Number-Generator.}

\end_inset 

.
 The obvious weakness of this type of RNG is that sequential values fail
 the serial test described by Knuth 
\begin_inset LatexCommand \cite{Knuth:vol2}

\end_inset 

.
 At any time step 
\begin_inset Formula $t$
\end_inset 

 there are two equally likely values for time 
\begin_inset Formula $t+1$
\end_inset 

.
 If for an LFSR of length 
\begin_inset Formula $n$
\end_inset 

 at time 
\begin_inset Formula $t$
\end_inset 

 the value is 
\begin_inset Formula $v$
\end_inset 

, then at time 
\begin_inset Formula $t+1$
\end_inset 

 the value will be 
\begin_inset Formula $v/2$
\end_inset 

 or 
\begin_inset Formula $v/2+2^{n-1}$
\end_inset 

.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cbstart
\end_inset 

 All the serial tests in this section were performed by generating a file
 of random numbers using each of the generators.
 The file created was about 11\SpecialChar ~
MiB in size (i.e.
 about 2.8 million 32\SpecialChar ~
bit numbers).
 The results for the LFSR RNG 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cbend
\end_inset 

 are shown in Figure 
\begin_inset LatexCommand \ref{fig:LFSR pairs test}

\end_inset 

 where pairs of values 
\begin_inset Formula $v_{t}$
\end_inset 

 and 
\begin_inset Formula $v_{t+1}$
\end_inset 

 are plotted.
 
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/lfsrrng_1.eps
	display color
	size_type 1
	height 8cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 1
	lyxheight 8cm	keepLyXAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:LFSR pairs test}

\end_inset 

Serial test of a simple LFSR RNG.
\end_inset 


\layout Standard

It can be seen that for any value 
\begin_inset Formula $v_{t}$
\end_inset 

 there are only two possible values of 
\begin_inset Formula $v_{t+1}$
\end_inset 

.
 Though the random number generator runs in parallel with the main GP machine,
 it is possible to access sequential values when creating an initial program,
 or when choosing crossover points.
 There is then a possibility of introducing a potentially degrading bias
 by using such an RNG.
 
\layout Subsection

Multiple LFSRs
\layout Standard

One method of obtaining better serial test results when using an LFSR is
 to allow the LFSR to run for a number of cycles before reading another
 number.
 That is, to produce 
\begin_inset Formula $n$
\end_inset 

 random bits from an LFSR of length 
\begin_inset Formula $m$
\end_inset 

 (where 
\begin_inset Formula $n\leq m$
\end_inset 

), the LFSR should be allowed to run for 
\begin_inset Formula $n$
\end_inset 

 cycles between reading the bits.
 Since this would limit the rate at which random numbers could be generated
 in the present design it is not explored any further.
 However, an equivalent result can be obtained by implementing 
\begin_inset Formula $n$
\end_inset 

 LFSRs of length 
\begin_inset Formula $m$
\end_inset 

 and using a single bit from each LFSR at each time step.
 This can also be done using a single long LFSR of 
\begin_inset Formula $n\times m$
\end_inset 

 bits, 
\begin_inset LatexCommand \cite{Stiliadis:1995}

\end_inset 

 effectively implementing 
\begin_inset Formula $n$
\end_inset 

 parallel LFSRs.
 However, implementing a long shift register in a Xilinx Virtex FPGA is
 not efficient because the look up tables can implement a 16 bit shift register
 very easily, but longer shift registers require more extensive routing
 resources.
 
\layout Standard

The effect of using a better RNG was investigated by implementing 32 16
 bit LFSR machines that run in parallel, and initialising each LFSR to a
 different value.
 Bit32 from each LFSR is used to construct a 32 bit random number.
 The serial test result is shown in Figure 
\begin_inset LatexCommand \ref{fig:16 LFSR RNG pairs test}

\end_inset 

, which shows the serial test result for 32 LFSRs is better than the single
 LFSR.
 This generator is referred to as the 32LFSR.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/lfsrrng_skip.eps
	display color
	size_type 1
	height 8cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 1
	lyxwidth 161pt
	lyxheight 113pt
\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:16 LFSR RNG pairs test}

\end_inset 

Serial test for an RNG using 16 parallel LFSRs
\end_inset 


\layout Subsection

Cellular Automata RNG
\layout Standard

Another popular RNG for hardware implementations is based on Cellular Automata
 (CA).
 A one-dimensional (1D) CA consists of a string of cells.
 Each cell has two neighbours - left and right, or in some literature west
 and east respectively.
 At each time step, the value of any cell 
\begin_inset Formula $c$
\end_inset 

 is given by a rule.
 For this implementation, rule 30 is used, which states that for any cell
 
\begin_inset Formula $c$
\end_inset 

 at time 
\begin_inset Formula $t$
\end_inset 

, 
\begin_inset Formula $c_{t+1}=((west_{t}$
\end_inset 

+
\begin_inset Formula $c_{t})\oplus east_{t})$
\end_inset 

, where 
\begin_inset Formula $\oplus $
\end_inset 

 denotes the exclusive OR function.
 In practice the CA is implemented using a single 32 bit word, and for cell
 0, its right-hand neighbour is cell 31, and similarly for cell 31 its left
 hand neighbour is cell 0.
 Figure 
\begin_inset LatexCommand \ref{fig:CA pairs test}

\end_inset 

 shows the result of running this RNG using the serial test.
 As in the simple LFSR RNG there is a distinct pattern to the numbers, but
 for most values of 
\begin_inset Formula $v_{t}$
\end_inset 

 there are several possible values for 
\begin_inset Formula $v_{t+1}$
\end_inset 

.
 This generator is referred to as 1DCA.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/lcarng_1.eps
	display color
	size_type 1
	height 8cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 1
	lyxwidth 161pt
	lyxheight 113pt
\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:CA pairs test}

\end_inset 

Serial test for a 1DCA RNG
\end_inset 


\layout Subsection

Multiple CA generators
\layout Standard

As in the case of the LFSR RNG, if several CAs are combined, it would be
 expected that the results would be much better than the single 1DCA.
 For this test, 32 CAs were implemented, and by taking one bit from each
 CA, a 32 bit random number can be generated.
 The result for the serial test appears to be much more random, as shown
 in Figure 
\begin_inset LatexCommand \ref{fig:CA 16}

\end_inset 

.
 Each CA is initialised with a different pattern.
 This generator is referred to as the 32CA
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename images/lcarng_skip.eps
	display color
	size_type 1
	height 8cm
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 1
	lyxwidth 161pt
	lyxheight 113pt
\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:CA 16}

\end_inset 

Serial test for a 32CA
\end_inset 


\layout Subsection

Standard C RNGs
\layout Standard

Another frequently used RNG is the 
\emph on 
Linear Congruential
\emph default 
 generator that is often found in implementations of the standard C library,
 following the illustration of an example 
\family typewriter 
rand()
\family default 
 function in 
\begin_inset LatexCommand \cite{kandR:1988}

\end_inset 

.
 The general equation for these is:
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
nopagebreak
\end_inset 


\layout Standard


\begin_inset Formula \begin{equation}
I_{j+1}=(aI_{j}+c)\bmod m\label{EQU:LinearCongruential}\end{equation}

\end_inset 

 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
noindent 
\end_inset 

where 
\begin_inset Formula $a,\, c$
\end_inset 

 and 
\begin_inset Formula $m$
\end_inset 

 are constants chosen to produce a maximal length RNG.
 However, as pointed out by many authors (eg:
\begin_inset LatexCommand \cite{press86numerical}

\end_inset 

) these generators are not good.
 A factor against implementing such a generator in hardware is that it requires
 one addition, one multiplication, and one modulus operator, which in Handel-C
 would consume a large amount of silicon and because of the deep logic produced
 when using 32 bit words, would be slow.
 An alternative given by 
\begin_inset LatexCommand \cite{press86numerical}

\end_inset 

 avoids the modulus operator, and is called the Even Quicker Generator (EQG).
 It is claimed that this is about as good as any 32 bit linear congruential
 generator.
 Its equation is:
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
nopagebreak
\end_inset 


\layout Standard


\begin_inset Formula \begin{equation}
I_{j+1}=aI_{j}+c\label{EQU:EvenQuickerGenerator}\end{equation}

\end_inset 


\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
noindent 
\end_inset 

 Values for 
\begin_inset Formula $a=1664525$
\end_inset 

 and 
\begin_inset Formula $c=1013904223$
\end_inset 

 are suggested.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cbstart 
\end_inset 

 Note that there is an implicit mod 
\begin_inset Formula $2^{32}$
\end_inset 

 operator when executed on a 32 bit processor, so the algorithm is equivalent
 to 
\begin_inset LatexCommand \ref{EQU:LinearCongruential}

\end_inset 

.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
cbend 
\end_inset 


\layout Standard

As a sanity check that the experimental method of ranking the RNGs using
 Diehard was the same as that used by Meysenburg, the generator known as
 ``the mother of all generators'' was also implemented and run against the
 Diehard suite.
 This is a multiply with carry generator and is described by Marsaglia 
\begin_inset LatexCommand \cite{marsaglia:1994}

\end_inset 

.
 It was not implemented in the hardware GP system because of its complexity.
\layout Subsection


\begin_inset LatexCommand \label{sub:Non-Random-Sequences}

\end_inset 

Non Random Sequences
\layout Standard

Until now we have considered pseudo random sequences.
 These are sequences where it is hard to guess the next number in a sequence.
 As an experiment, a further set of runs were performed with an obviously
 non-random number generator.
 For this a sequential generator that output the sequence 
\begin_inset Formula $n,n+1,n+2,\ldots $
\end_inset 

 was used.
 Rather surprisingly this also worked to produce 100% correct programs,
 though substantially fewer than the other generators achieved.
 
\layout Subsection

Truly Random Sequences
\layout Standard

All the RNGs considered so far are not true random sequences, relying on
 the manipulation of objects of finite size, and so fail one or more of
 the Diehard battery of tests.
 So a set of random numbers was obtained from a source generated by using
 the atmospheric noise captured by a radio receiver 
\begin_inset LatexCommand \cite{randomorg:2002}

\end_inset 

.
 Each GP run for the artificial ant problem needs about half a million random
 numbers, so a block of 10\SpecialChar ~
MiB was downloaded from 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
url{www.random.org}
\end_inset 

 and a randomly selected 2\SpecialChar ~
MiB block was transferred to one of the SRAM on
 the FPGA system using DMA.
 The FPGA read this block sequentially to get its random numbers.
\layout Section

Experimental Results
\layout Standard

The results from running the Diehard tests are summarised in Table 
\begin_inset LatexCommand \ref{table:Summary of Diehard}

\end_inset 

.
 This shows the total results for each test and ranks them according to
 their Diehard score.
 The worst score that Diehard can award is 876.
 Note that the Sequential generator fails all Diehard tests.
 Appendix 
\begin_inset LatexCommand \ref{main:Random number generator test results}

\end_inset 

 gives the results of the Diehard tests in full.
\layout Standard


\begin_inset Float table
placement htbp
wide false
collapsed false

\layout Caption


\begin_inset LatexCommand \label{table:Summary of Diehard}

\end_inset 

Summary results of running the Diehard tests on the random number generators.
\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="9" columns="2">
<features>
<column alignment="left" valignment="top" width="0pt">
<column alignment="right" valignment="top" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RNG
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Score
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Mother
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

20
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

True
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

22
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

32LFSR
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

162
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

EQG
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

288
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

32CA
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

640
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

1DCA
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

676
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

LFSR
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

756
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Sequential
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
footnote
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

876
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_inset 


\layout Standard


\begin_inset ERT
status Open

\layout Standard

\backslash 
footnotetext{Note. This is not a true RNG. See Section 
\backslash 
ref{sub:Non-Random-Sequences}}
\end_inset 

The number of correct programs that were produced by each random number
 generator was recorded and is shown in Table 
\begin_inset LatexCommand \ref{table:Correct program counts}

\end_inset 

.
 The results are ranked according to the number of correct programs produced.
 The table also shows the slice count for the RNG implemented using Handel-C
 and the maximum frequency as reported by the place and route tools.
 The slice count is a vendor dependent measure of the number of FPGA blocks
 used.
 The clock rate is an indication of the logic depth required to implement
 the generator, with deeper logic exhibiting a greater gate delay and therefore
 a lower maximum clock rate.
 The slice count and frequency for the true RNG assumes that the source
 of random numbers is supplied by an external device to the FPGA, and that
 the FPGA simply needs to read the value from a port and write it to a register.
\layout Standard


\begin_inset Float table
placement htbp
wide false
collapsed false

\layout ShortCaption

Summary of GP performance for all random number generators tested.
\layout Caption


\begin_inset LatexCommand \label{table:Correct program counts}

\end_inset 

Summary of GP performance for all random number generators tested from 500
 runs.
\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="8" columns="4">
<features>
<column alignment="left" valignment="top" width="0pt">
<column alignment="right" valignment="top" width="0pt">
<column alignment="right" valignment="top" width="0pt">
<column alignment="right" valignment="top" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RNG
\end_inset 
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Correct
\end_inset 
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Slice
\end_inset 
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Clock rate
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

32CA
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

82
\end_inset 
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

284
\end_inset 
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

105\SpecialChar ~
MHz
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

True
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

81
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

6
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

>200\SpecialChar ~
MHz
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

32LFSR
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

79
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

130
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

134\SpecialChar ~
MHz
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

EQG
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

78
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

288
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

42\SpecialChar ~
MHz
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

ID CA
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

78
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

22
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

125\SpecialChar ~
MHz
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

LFSR
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

68
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

18
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

188\SpecialChar ~
MHz
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Sequential
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

39
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

21
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

155\SpecialChar ~
MHz
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_inset 


\layout Section

Discussion
\layout Standard

The Diehard score obtained by the mother RNG was close to that obtained
 by Meysenburg, the difference being explained by the fact that Meysenburg
 used the average of 32 runs, while the work described here used a single
 run.
 Despite this difference, this confirms that the experimental method used
 for ranking the RNGs using Diehard is comparable.
\layout Standard

Despite the apparently serious deficiencies found in both the simple LFSR
 used in the original implementation and the simple one dimensional CA random
 number generator, the overall effect of implementing a more sophisticated
 RNG on the overall GP performance appeared to be small.
 This result generally agrees with the work by Meysenburg and Foster 
\begin_inset LatexCommand \cite{meysenburg:1999:RGQGP}

\end_inset 

, with the exception that they did not consider a single-cycle LFSR.
 The single-cycle LFSR performs the least well of the RNGs.
\layout Standard

What was surprising was the emergence of solutions when a non-random sequence
 was used.
 Clearly, a non-random sequence does not allow GP to operate as efficiently
 in terms of producing 100% correct programs, presumably because of the
 failure to explore some areas of the search space.
 Nevertheless, the sequential generator allowed GP to explore enough of
 the search space to discover viable solutions.
\layout Standard

Despite the small differences in performance between the RNGS, with the
 exception of the single-cycle LFSR and the sequential generator, from the
 results we can say that using a different RNG from the single LFSR would
 improve the performance of the hardware GP implementation, and that an
 RNG based on multiple LFSRs or multiple CAs would be a better choice for
 a hardware GP system.
 The use of a truly random number source did not appear to improve performance
 over the 1DCA, 32CA and 32LFSR RNGs.
 This provides more evidence countering the notion that GP needs a very
 high quality RNG.
 
\layout Standard

Table 
\begin_inset LatexCommand \ref{table:Correct program counts}

\end_inset 

 shows that the difference in GP performance between the 32CA, True, 32LFSR,
 EQG and 1DCA generators is small.
 However, these 5 generators have very different Diehard scores, so there
 does not appear to be a straightforward relationship between the Diehard
 score and the performance of GP.
 This raises a question about the role that RNGs play in GP.
 Is a RNG that scores well in some of the standard tests for randomness
 the best RNG for GP?
\layout Standard

When looking at the FPGA slice counts and maximum clock rates, the 32LFSR
 uses about half the FPGA resources that the 32CA does, and exhibits a smaller
 delay than the 32CA.
 This result agrees with Yoshida 
\shape italic 
et al.

\shape default 
 
\begin_inset LatexCommand \cite{yoshida:2001}

\end_inset 

 where they found an LFSR RNG used fewer gates than a CA base RNG.
 As predicted, the EQG uses the most FPGA resources and has very deep logic,
 meaning that it can only run at a much slower rate than any of the other
 generators.
 The EQG RNG could be re-implemented in the FPGA using pipelines to achieve
 much higher clock rate, but since it performed no better than the 32CA
 or 32LFSR, this was not investigated any further.
\layout Section

Summary
\layout Standard

This chapter has presented two behavioural analysis of the hardware GP system.
 First, the behaviour was analysed using the program length distributions,
 and second, the impact of the random number generator was evaluated.
\layout Subsection

Program Length Distribution
\layout Standard

This analysis, based on measuring the program length distributions, was
 inspired by the results from the work on a general schema theory of GP.
 It has led to an implementation of a crossover operator that constrains
 the maximum program lengths in a natural way, without needing to know anything
 about the program structure.
 For the artificial ant problem and Boolean even-6-parity problem another
 mechanism has been discovered that avoids the effects of unconstrained
 program growth, and also also yields more correct programs than the other
 crossover operators examined.
\layout Standard

In conclusion, all three crossover operators are effective in the hardware
 implementation when applied to the artificial ant problem, with the single-chil
d limiting crossover performing ahead of the other two.
 The behavior of the single-child limiting crossover in the presence of
 fitness is interesting and suggests another mechanism for controlling code
 growth.
 
\layout Subsection

Random Number Generator
\layout Standard

The main conclusion from this investigation is that for the hardware GP
 system, the simple LFSR used in the original design can be improved upon
 by using a generator based on multiple LFSRs, multiple CAs, or if available,
 a high speed source of true random numbers.
 A secondary conclusion is that with the exception of the non-random sequence
 and the LFSR generator, there is no significant difference in GP performance
 when different hardware RNGs are used.
\the_end
